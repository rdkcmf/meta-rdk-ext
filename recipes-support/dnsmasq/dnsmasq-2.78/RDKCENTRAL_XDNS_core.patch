Date: Sep 11 07:19:26 2018

From: 98e43f33d5041eb61496c2a0128d611fa105b398 Apr 23 13:04:27 2019

Subject: [PATCH] RDKB-15078: Merge XDNS patches + add patched from meta-rdk-mesh

	This patch updates dnsmasq 2.78, provides IPv6 sppport on
	top of IPv4 to implement feature support for XDNS. Also provides certain validations for
	XDNS override servers

	Adds XDNS support in dnsmasq. Changes in Dnsmasq opensource 2.78.
	Modification in meta-rdk-ext for all platforms.
	Add ccsp-xdns.bb to meta-rdk and package groups

Source: COMCAST


Upstream-Status: Pending

Signed-off-by: Murugan Viswanathan <Murugan.Viswanathan2@cognizant.com>
---

diff -Naur dnsmasq-2.78.orig/src/arp.c dnsmasq-2.78/src/arp.c
--- dnsmasq-2.78.orig/src/arp.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/arp.c	2018-06-21 09:32:24.456039662 +0000
@@ -35,6 +35,11 @@
 static struct arp_record *arps = NULL, *old = NULL, *freelist = NULL;
 static time_t last = 0;
 
+/* <XDNS> */
+#define XDNS_NULL_MAC "00:00:00:00:00:00"
+static struct dnsoverride_record *dnsrecs = NULL;
+/* </XDNS> */
+
 static int filter_mac(int family, char *addrp, char *mac, size_t maclen, void *parmv)
 {
   struct arp_record *arp;
@@ -212,6 +217,148 @@
    return 0;
 }
 
+
+/* <XDNS> - update_dnsoverride_records updates dnsoverride_record. */
+int update_dnsoverride_records(struct dnsoverride_record *precord)
+{
+       struct dnsoverride_record *tmp = dnsrecs;
+
+       //lock - no need. dnsmasq is single threaded
+       dnsrecs = precord;
+       //unlock
+
+       /* clean old records */
+       while(tmp)
+       {
+               struct dnsoverride_record *t = tmp;
+               tmp = tmp->next;
+               free(t);
+       }
+       return 1;//success
+}
+
+/* XDNS find dns record for given mac in dnsrecs. */
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr)
+{
+       if(!macaddr)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Error Param!!"), macaddr);
+               return NULL;
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s)"), macaddr);
+
+       //lock - no need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, macaddr) == 0)
+               {
+                       //found
+                       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) - found."), macaddr);
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Not found!"), macaddr);
+       }
+
+       return p;
+}
+
+/* XDNS - get default record*/
+struct dnsoverride_record* get_dnsoverride_defaultrecord()
+{
+       //lock
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, XDNS_NULL_MAC) == 0)
+               {
+                       //found
+                       my_syslog(LOG_WARNING, _("#### XDNS : found default rec"));
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_defaultrecord() Not found!"));
+       }
+
+       return p;
+}
+
+
+/* find dns server address for given mac in dnsrecs */
+int find_dnsoverride_server(char* macaddr, struct all_addr* serv, int iptype)
+{
+       if(!macaddr || !serv)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param!!"));
+               return 0; //fail
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s)"), macaddr);
+
+       //lock - No need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, macaddr) == 0)
+               {
+                       //found
+                       if(iptype == 4)
+                       {
+                               memcpy(serv, &p->dnsaddr4, sizeof(struct all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv4 server"));
+                       }
+#ifdef HAVE_IPV6
+                       else if(iptype == 6)
+                       {
+                               memcpy(serv, &p->dnsaddr6, sizeof(struct all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv6 server"));
+                       }
+#endif
+                       else
+                       {
+                               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param! invalid iptype: %d !"), iptype);
+                               return 0; // fail
+                       }
+
+                       return 1; //success
+
+               }
+               p = p->next;
+       }
+       //unlock
+
+       my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s) override dns server not found!"), macaddr);
+
+       return 0; // not found
+}
+
+/* find default server address. Default is indicated by mac addr "00:00:00:00:00:00" TODO: Needs protection */
+int find_dnsoverride_defaultserver(struct all_addr* serv, int iptype)
+{
+       if(!serv)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_defaultserver(%x) Error Param!!"), serv);
+               return 0;
+       }
+
+       return find_dnsoverride_server(XDNS_NULL_MAC, serv, iptype);
+}
+
+/* </XDNS> */
+
+
 int do_arp_script_run(void)
 {
   struct arp_record *arp;
diff -Naur dnsmasq-2.78.orig/src/dnsmasq.c dnsmasq-2.78/src/dnsmasq.c
--- dnsmasq-2.78.orig/src/dnsmasq.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/dnsmasq.c	2018-06-21 09:31:48.437078847 +0000
@@ -784,14 +784,14 @@
   if (daemon->port != 0 && option_bool(OPT_NO_RESOLV))
     {
       if (daemon->resolv_files && !daemon->resolv_files->is_default)
-	my_syslog(LOG_WARNING, _("warning: ignoring resolv-file flag because no-resolv is set"));
+        my_syslog(LOG_WARNING, _("#### XDNS ##### dnsmasq.c: warning: ignoring resolv-file flag because no-resolv is set"));
       daemon->resolv_files = NULL;
       if (!daemon->servers)
-	my_syslog(LOG_WARNING, _("warning: no upstream servers configured"));
+        my_syslog(LOG_WARNING, _("i#### XDNS ##### dnsmasq.c: warning: no upstream servers configured"));
     } 
 
   if (daemon->max_logs != 0)
-    my_syslog(LOG_INFO, _("asynchronous logging enabled, queue limit is %d messages"), daemon->max_logs);
+    my_syslog(LOG_INFO, _("#### XDNS ##### dnsmasq.c: asynchronous logging enabled, queue limit is %d messages"), daemon->max_logs);
   
 
 #ifdef HAVE_DHCP
diff -Naur dnsmasq-2.78.orig/src/dnsmasq.h dnsmasq-2.78/src/dnsmasq.h
--- dnsmasq-2.78.orig/src/dnsmasq.h	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/dnsmasq.h	2018-06-21 09:32:24.456039662 +0000
@@ -245,7 +245,11 @@
 #define OPT_MAC_B64        54
 #define OPT_MAC_HEX        55
 #define OPT_TFTP_APREF_MAC 56
-#define OPT_LAST           57
+/* <XDNS> */
+#define OPT_DNS_OVERRIDE   57
+/* </XDNS> */
+#define OPT_LAST           58
+
 
 /* extra flags for my_syslog, we use a couple of facilities since they are known 
    not to occupy the same bits as priorities, no matter how syslog.h is set up. */
@@ -471,6 +475,23 @@
 #endif
 };
 
+/* <MURUGAN> - for XDNS feature */
+#define REC_ADDR_MAX 32  /* Max buffer size MAC or IPv4 */
+#define REC_STR_MAX 256  /* Max string size cpetag */
+
+/* XDNS - mapping of client hwaddr to upstream dns servers */
+struct dnsoverride_record {
+  unsigned char macaddr[REC_ADDR_MAX];
+  char cpetag[REC_STR_MAX];
+  struct all_addr dnsaddr4;
+#ifdef HAVE_IPV6
+  struct all_addr dnsaddr6;
+#endif
+  //int family;
+  struct dnsoverride_record *next;
+};
+/* </MURUGAN */
+
 /* bits in flag param to IPv6 callbacks from iface_enumerate() */
 #define IFACE_TENTATIVE   1
 #define IFACE_DEPRECATED  2
@@ -969,6 +990,7 @@
   struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;
   struct bogus_addr *bogus_addr, *ignore_addr;
   struct server *servers;
+  struct server *dns_override_server; /* for XDNS */
   struct ipsets *ipsets;
   int log_fac; /* log facility */
   char *log_file; /* optional log file */
@@ -1563,4 +1585,9 @@
 
 /* arp.c */
 int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now);
+int update_dnsoverride_records(struct dnsoverride_record *precord);
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr);
+struct dnsoverride_record* get_dnsoverride_defaultrecord();
+int find_dnsoverride_server(char* macaddr, struct all_addr* serv, int iptype);
+int find_dnsoverride_defaultserver(struct all_addr* serv, int iptype);
 int do_arp_script_run(void);
diff -Naur dnsmasq-2.78.orig/src/dnsmasq.h.orig dnsmasq-2.78/src/dnsmasq.h.orig
--- dnsmasq-2.78.orig/src/dnsmasq.h.orig	1970-01-01 00:00:00.000000000 +0000
+++ dnsmasq-2.78/src/dnsmasq.h.orig	2018-06-21 09:31:48.437078847 +0000
@@ -0,0 +1,1590 @@
+/* dnsmasq is Copyright (c) 2000-2017 Simon Kelley
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+     
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#define COPYRIGHT "Copyright (c) 2000-2017 Simon Kelley"
+
+/* We do defines that influence behavior of stdio.h, so complain
+   if included too early. */
+#ifdef _STDIO_H
+#  error "Header file stdio.h included too early!"
+#endif 
+
+#ifndef NO_LARGEFILE
+/* Ensure we can use files >2GB (log files may grow this big) */
+#  define _LARGEFILE_SOURCE 1
+#  define _FILE_OFFSET_BITS 64
+#endif
+
+/* Get linux C library versions and define _GNU_SOURCE for kFreeBSD. */
+#if defined(__linux__) || defined(__GLIBC__)
+#  ifndef __ANDROID__
+#      define _GNU_SOURCE
+#  endif
+#  include <features.h> 
+#endif
+
+/* Need these defined early */
+#if defined(__sun) || defined(__sun__)
+#  define _XPG4_2
+#  define __EXTENSIONS__
+#endif
+
+/* get these before config.h  for IPv6 stuff... */
+#include <sys/types.h> 
+#include <sys/socket.h>
+
+#ifdef __APPLE__
+/* Define before netinet/in.h to select API. OSX Lion onwards. */
+#  define __APPLE_USE_RFC_3542
+#endif
+#include <netinet/in.h>
+
+/* Also needed before config.h. */
+#include <getopt.h>
+
+#include "config.h"
+#include "ip6addr.h"
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+
+#define countof(x)      (long)(sizeof(x) / sizeof(x[0]))
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+
+#include "dns-protocol.h"
+#include "dhcp-protocol.h"
+#ifdef HAVE_DHCP6
+#include "dhcp6-protocol.h"
+#include "radv-protocol.h"
+#endif
+
+#define gettext_noop(S) (S)
+#ifndef LOCALEDIR
+#  define _(S) (S)
+#else
+#  include <libintl.h>
+#  include <locale.h>   
+#  define _(S) gettext(S)
+#endif
+
+#include <arpa/inet.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#if defined(HAVE_SOLARIS_NETWORK)
+#  include <sys/sockio.h>
+#endif
+#include <sys/poll.h>
+#include <sys/wait.h>
+#include <sys/time.h>
+#include <sys/un.h>
+#include <limits.h>
+#include <net/if.h>
+#if defined(HAVE_SOLARIS_NETWORK) && !defined(ifr_mtu)
+/* Some solaris net/if./h omit this. */
+#  define ifr_mtu  ifr_ifru.ifru_metric
+#endif
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <signal.h>
+#include <stddef.h>
+#include <time.h>
+#include <errno.h>
+#include <pwd.h>
+#include <grp.h>
+#include <stdarg.h>
+#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__sun__) || defined (__sun) || defined (__ANDROID__)
+#  include <netinet/if_ether.h>
+#else
+#  include <net/ethernet.h>
+#endif
+#include <net/if_arp.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_icmp.h>
+#include <sys/uio.h>
+#include <syslog.h>
+#include <dirent.h>
+#ifndef HAVE_LINUX_NETWORK
+#  include <net/if_dl.h>
+#endif
+
+#if defined(HAVE_LINUX_NETWORK)
+#include <linux/capability.h>
+/* There doesn't seem to be a universally-available 
+   userspace header for these. */
+extern int capset(cap_user_header_t header, cap_user_data_t data);
+extern int capget(cap_user_header_t header, cap_user_data_t data);
+#define LINUX_CAPABILITY_VERSION_1  0x19980330
+#define LINUX_CAPABILITY_VERSION_2  0x20071026
+#define LINUX_CAPABILITY_VERSION_3  0x20080522
+
+#include <sys/prctl.h>
+#elif defined(HAVE_SOLARIS_NETWORK)
+#include <priv.h>
+#endif
+
+/* daemon is function in the C library.... */
+#define daemon dnsmasq_daemon
+
+/* Async event queue */
+struct event_desc {
+  int event, data, msg_sz;
+};
+
+#define EVENT_RELOAD     1
+#define EVENT_DUMP       2
+#define EVENT_ALARM      3
+#define EVENT_TERM       4
+#define EVENT_CHILD      5
+#define EVENT_REOPEN     6
+#define EVENT_EXITED     7
+#define EVENT_KILLED     8
+#define EVENT_EXEC_ERR   9
+#define EVENT_PIPE_ERR   10
+#define EVENT_USER_ERR   11
+#define EVENT_CAP_ERR    12
+#define EVENT_PIDFILE    13
+#define EVENT_HUSER_ERR  14
+#define EVENT_GROUP_ERR  15
+#define EVENT_DIE        16
+#define EVENT_LOG_ERR    17
+#define EVENT_FORK_ERR   18
+#define EVENT_LUA_ERR    19
+#define EVENT_TFTP_ERR   20
+#define EVENT_INIT       21
+#define EVENT_NEWADDR    22
+#define EVENT_NEWROUTE   23
+#define EVENT_TIME_ERR   24
+#define EVENT_SCRIPT_LOG 25
+
+/* Exit codes. */
+#define EC_GOOD        0
+#define EC_BADCONF     1
+#define EC_BADNET      2
+#define EC_FILE        3
+#define EC_NOMEM       4
+#define EC_MISC        5
+#define EC_INIT_OFFSET 10
+
+/* Trust the compiler dead-code eliminator.... */
+#define option_bool(x) (((x) < 32) ? daemon->options & (1u << (x)) : daemon->options2 & (1u << ((x) - 32)))
+
+#define OPT_BOGUSPRIV      0
+#define OPT_FILTER         1
+#define OPT_LOG            2
+#define OPT_SELFMX         3
+#define OPT_NO_HOSTS       4
+#define OPT_NO_POLL        5
+#define OPT_DEBUG          6
+#define OPT_ORDER          7
+#define OPT_NO_RESOLV      8
+#define OPT_EXPAND         9
+#define OPT_LOCALMX        10
+#define OPT_NO_NEG         11
+#define OPT_NODOTS_LOCAL   12
+#define OPT_NOWILD         13
+#define OPT_ETHERS         14
+#define OPT_RESOLV_DOMAIN  15
+#define OPT_NO_FORK        16
+#define OPT_AUTHORITATIVE  17
+#define OPT_LOCALISE       18
+#define OPT_DBUS           19
+#define OPT_DHCP_FQDN      20
+#define OPT_NO_PING        21
+#define OPT_LEASE_RO       22
+#define OPT_ALL_SERVERS    23
+#define OPT_RELOAD         24
+#define OPT_LOCAL_REBIND   25  
+#define OPT_TFTP_SECURE    26
+#define OPT_TFTP_NOBLOCK   27
+#define OPT_LOG_OPTS       28
+#define OPT_TFTP_APREF_IP  29
+#define OPT_NO_OVERRIDE    30
+#define OPT_NO_REBIND      31
+#define OPT_ADD_MAC        32
+#define OPT_DNSSEC_PROXY   33
+#define OPT_CONSEC_ADDR    34
+#define OPT_CONNTRACK      35
+#define OPT_FQDN_UPDATE    36
+#define OPT_RA             37
+#define OPT_TFTP_LC        38
+#define OPT_CLEVERBIND     39
+#define OPT_TFTP           40
+#define OPT_CLIENT_SUBNET  41
+#define OPT_QUIET_DHCP     42
+#define OPT_QUIET_DHCP6    43
+#define OPT_QUIET_RA	   44
+#define OPT_DNSSEC_VALID   45
+#define OPT_DNSSEC_TIME    46
+#define OPT_DNSSEC_DEBUG   47
+#define OPT_DNSSEC_NO_SIGN 48 
+#define OPT_LOCAL_SERVICE  49
+#define OPT_LOOP_DETECT    50
+#define OPT_EXTRALOG       51
+#define OPT_TFTP_NO_FAIL   52
+#define OPT_SCRIPT_ARP     53
+#define OPT_MAC_B64        54
+#define OPT_MAC_HEX        55
+#define OPT_TFTP_APREF_MAC 56
+/* <XDNS> */
+#define OPT_DNS_OVERRIDE   57
+/* </XDNS> */
+#define OPT_LAST           58
+
+
+/* extra flags for my_syslog, we use a couple of facilities since they are known 
+   not to occupy the same bits as priorities, no matter how syslog.h is set up. */
+#define MS_TFTP   LOG_USER
+#define MS_DHCP   LOG_DAEMON
+#define MS_SCRIPT LOG_MAIL
+
+struct all_addr {
+  union {
+    struct in_addr addr4;
+#ifdef HAVE_IPV6
+    struct in6_addr addr6;
+#endif
+    /* for log_query */
+    struct {
+      unsigned short keytag, algo, digest;
+    } log; 
+    /* for cache_insert of DNSKEY, DS */
+    struct {
+      unsigned short class, type;
+    } dnssec;      
+  } addr;
+};
+
+struct bogus_addr {
+  struct in_addr addr;
+  struct bogus_addr *next;
+};
+
+/* dns doctor param */
+struct doctor {
+  struct in_addr in, end, out, mask;
+  struct doctor *next;
+};
+
+struct mx_srv_record {
+  char *name, *target;
+  int issrv, srvport, priority, weight;
+  unsigned int offset;
+  struct mx_srv_record *next;
+};
+
+struct naptr {
+  char *name, *replace, *regexp, *services, *flags;
+  unsigned int order, pref;
+  struct naptr *next;
+};
+
+#ifndef NO_ID
+#define TXT_STAT_CACHESIZE     1
+#define TXT_STAT_INSERTS       2
+#define TXT_STAT_EVICTIONS     3
+#define TXT_STAT_MISSES        4
+#define TXT_STAT_HITS          5
+#define TXT_STAT_AUTH          6
+#define TXT_STAT_SERVERS       7
+#endif
+
+struct txt_record {
+  char *name;
+  unsigned char *txt;
+  unsigned short class, len;
+  int stat;
+  struct txt_record *next;
+};
+
+struct ptr_record {
+  char *name, *ptr;
+  struct ptr_record *next;
+};
+
+struct cname {
+  int ttl, flag;
+  char *alias, *target;
+  struct cname *next, *targetp;
+}; 
+
+struct ds_config {
+  char *name, *digest;
+  int digestlen, class, algo, keytag, digest_type;
+  struct ds_config *next;
+};
+
+#define ADDRLIST_LITERAL 1
+#define ADDRLIST_IPV6    2
+#define ADDRLIST_REVONLY 4
+
+struct addrlist {
+  struct all_addr addr;
+  int flags, prefixlen; 
+  struct addrlist *next;
+};
+
+#define AUTH6     1
+#define AUTH4     2
+
+struct auth_zone {
+  char *domain;
+  struct auth_name_list {
+    char *name;
+    int flags;
+    struct auth_name_list *next;
+  } *interface_names;
+  struct addrlist *subnet;
+  struct addrlist *exclude;
+  struct auth_zone *next;
+};
+
+
+struct host_record {
+  int ttl;
+  struct name_list {
+    char *name;
+    struct name_list *next;
+  } *names;
+  struct in_addr addr;
+#ifdef HAVE_IPV6
+  struct in6_addr addr6;
+#endif
+  struct host_record *next;
+};
+
+struct interface_name {
+  char *name; /* domain name */
+  char *intr; /* interface name */
+  int family; /* AF_INET, AF_INET6 or zero for both */
+  struct addrlist *addr;
+  struct interface_name *next;
+};
+
+union bigname {
+  char name[MAXDNAME];
+  union bigname *next; /* freelist */
+};
+
+struct blockdata {
+  struct blockdata *next;
+  unsigned char key[KEYBLOCK_LEN];
+};
+
+struct crec { 
+  struct crec *next, *prev, *hash_next;
+  /* union is 16 bytes when doing IPv6, 8 bytes on 32 bit machines without IPv6 */
+  union {
+    struct all_addr addr;
+    struct {
+      union {
+	struct crec *cache;
+	struct interface_name *int_name;
+      } target;
+      unsigned int uid; /* 0 if union is interface-name */
+    } cname;
+    struct {
+      struct blockdata *keydata;
+      unsigned short keylen, flags, keytag;
+      unsigned char algo;
+    } key; 
+    struct {
+      struct blockdata *keydata;
+      unsigned short keylen, keytag;
+      unsigned char algo;
+      unsigned char digest; 
+    } ds; 
+  } addr;
+  time_t ttd; /* time to die */
+  /* used as class if DNSKEY/DS, index to source for F_HOSTS */
+  unsigned int uid; 
+  unsigned short flags;
+  union {
+    char sname[SMALLDNAME];
+    union bigname *bname;
+    char *namep;
+  } name;
+};
+
+#define F_IMMORTAL  (1u<<0)
+#define F_NAMEP     (1u<<1)
+#define F_REVERSE   (1u<<2)
+#define F_FORWARD   (1u<<3)
+#define F_DHCP      (1u<<4)
+#define F_NEG       (1u<<5)       
+#define F_HOSTS     (1u<<6)
+#define F_IPV4      (1u<<7)
+#define F_IPV6      (1u<<8)
+#define F_BIGNAME   (1u<<9)
+#define F_NXDOMAIN  (1u<<10)
+#define F_CNAME     (1u<<11)
+#define F_DNSKEY    (1u<<12)
+#define F_CONFIG    (1u<<13)
+#define F_DS        (1u<<14)
+#define F_DNSSECOK  (1u<<15)
+
+/* below here are only valid as args to log_query: cache
+   entries are limited to 16 bits */
+#define F_UPSTREAM  (1u<<16)
+#define F_RRNAME    (1u<<17)
+#define F_SERVER    (1u<<18)
+#define F_QUERY     (1u<<19)
+#define F_NOERR     (1u<<20)
+#define F_AUTH      (1u<<21)
+#define F_DNSSEC    (1u<<22)
+#define F_KEYTAG    (1u<<23)
+#define F_SECSTAT   (1u<<24)
+#define F_NO_RR     (1u<<25)
+#define F_IPSET     (1u<<26)
+#define F_NOEXTRA   (1u<<27)
+
+/* Values of uid in crecs with F_CONFIG bit set. */
+#define SRC_INTERFACE 0
+#define SRC_CONFIG    1
+#define SRC_HOSTS     2
+#define SRC_AH        3
+
+
+/* struct sockaddr is not large enough to hold any address,
+   and specifically not big enough to hold an IPv6 address.
+   Blech. Roll our own. */
+union mysockaddr {
+  struct sockaddr sa;
+  struct sockaddr_in in;
+#if defined(HAVE_IPV6)
+  struct sockaddr_in6 in6;
+#endif
+};
+
+/* <MURUGAN> - for XDNS feature */
+#define REC_ADDR_MAX 32  /* Max buffer size MAC or IPv4 */
+#define REC_STR_MAX 256  /* Max string size cpetag */
+
+/* map client hwaddr to upstream server */
+struct dnsoverride_record {
+  unsigned char macaddr[REC_ADDR_MAX];
+  char cpetag[REC_STR_MAX];
+  struct all_addr dnsaddr;
+  int family;
+  struct dnsoverride_record *next;
+};
+/* </MURUGAN */
+
+/* bits in flag param to IPv6 callbacks from iface_enumerate() */
+#define IFACE_TENTATIVE   1
+#define IFACE_DEPRECATED  2
+#define IFACE_PERMANENT   4
+
+
+#define SERV_FROM_RESOLV       1  /* 1 for servers from resolv, 0 for command line. */
+#define SERV_NO_ADDR           2  /* no server, this domain is local only */
+#define SERV_LITERAL_ADDRESS   4  /* addr is the answer, not the server */ 
+#define SERV_HAS_DOMAIN        8  /* server for one domain only */
+#define SERV_HAS_SOURCE       16  /* source address defined */
+#define SERV_FOR_NODOTS       32  /* server for names with no domain part only */
+#define SERV_WARNED_RECURSIVE 64  /* avoid warning spam */
+#define SERV_FROM_DBUS       128  /* 1 if source is DBus */
+#define SERV_MARK            256  /* for mark-and-delete */
+#define SERV_TYPE    (SERV_HAS_DOMAIN | SERV_FOR_NODOTS)
+#define SERV_COUNTED         512  /* workspace for log code */
+#define SERV_USE_RESOLV     1024  /* forward this domain in the normal way */
+#define SERV_NO_REBIND      2048  /* inhibit dns-rebind protection */
+#define SERV_FROM_FILE      4096  /* read from --servers-file */
+#define SERV_LOOP           8192  /* server causes forwarding loop */
+#define SERV_DO_DNSSEC     16384  /* Validate DNSSEC when using this server */
+#define SERV_GOT_TCP       32768  /* Got some data from the TCP connection */
+
+struct serverfd {
+  int fd;
+  union mysockaddr source_addr;
+  char interface[IF_NAMESIZE+1];
+  unsigned int ifindex, used;
+  struct serverfd *next;
+};
+
+struct randfd {
+  int fd;
+  unsigned short refcount, family;
+};
+  
+struct server {
+  union mysockaddr addr, source_addr;
+  char interface[IF_NAMESIZE+1];
+  struct serverfd *sfd; 
+  char *domain; /* set if this server only handles a domain. */ 
+  int flags, tcpfd, edns_pktsz;
+  unsigned int queries, failed_queries;
+#ifdef HAVE_LOOP
+  u32 uid;
+#endif
+  struct server *next; 
+};
+
+struct ipsets {
+  char **sets;
+  char *domain;
+  struct ipsets *next;
+};
+
+struct irec {
+  union mysockaddr addr;
+  struct in_addr netmask; /* only valid for IPv4 */
+  int tftp_ok, dhcp_ok, mtu, done, warned, dad, dns_auth, index, multicast_done, found, label;
+  char *name; 
+  struct irec *next;
+};
+
+struct listener {
+  int fd, tcpfd, tftpfd, family;
+  struct irec *iface; /* only sometimes valid for non-wildcard */
+  struct listener *next;
+};
+
+/* interface and address parms from command line. */
+struct iname {
+  char *name;
+  union mysockaddr addr;
+  int used;
+  struct iname *next;
+};
+
+/* subnet parameters from command line */
+struct mysubnet {
+  union mysockaddr addr;
+  int addr_used;
+  int mask;
+};
+
+/* resolv-file parms from command-line */
+struct resolvc {
+  struct resolvc *next;
+  int is_default, logged;
+  time_t mtime;
+  char *name;
+#ifdef HAVE_INOTIFY
+  int wd; /* inotify watch descriptor */
+  char *file; /* pointer to file part if path */
+#endif
+};
+
+/* adn-hosts parms from command-line (also dhcp-hostsfile and dhcp-optsfile and dhcp-hostsdir*/
+#define AH_DIR      1
+#define AH_INACTIVE 2
+#define AH_WD_DONE  4
+#define AH_HOSTS    8
+#define AH_DHCP_HST 16
+#define AH_DHCP_OPT 32
+struct hostsfile {
+  struct hostsfile *next;
+  int flags;
+  char *fname;
+#ifdef HAVE_INOTIFY
+  int wd; /* inotify watch descriptor */
+#endif
+  unsigned int index; /* matches to cache entries for logging */
+};
+
+
+/* DNSSEC status values. */
+#define STAT_SECURE             1
+#define STAT_INSECURE           2
+#define STAT_BOGUS              3
+#define STAT_NEED_DS            4
+#define STAT_NEED_KEY           5
+#define STAT_TRUNCATED          6
+#define STAT_SECURE_WILDCARD    7
+#define STAT_OK                 8
+#define STAT_ABANDONED          9
+
+#define FREC_NOREBIND           1
+#define FREC_CHECKING_DISABLED  2
+#define FREC_HAS_SUBNET         4
+#define FREC_DNSKEY_QUERY       8
+#define FREC_DS_QUERY          16
+#define FREC_AD_QUESTION       32
+#define FREC_DO_QUESTION       64
+#define FREC_ADDED_PHEADER    128
+#define FREC_TEST_PKTSZ       256
+#define FREC_HAS_EXTRADATA    512        
+
+#ifdef HAVE_DNSSEC
+#define HASH_SIZE 20 /* SHA-1 digest size */
+#else
+#define HASH_SIZE sizeof(int)
+#endif
+
+struct frec {
+  union mysockaddr source;
+  struct all_addr dest;
+  struct server *sentto; /* NULL means free */
+  struct randfd *rfd4;
+#ifdef HAVE_IPV6
+  struct randfd *rfd6;
+#endif
+  unsigned int iface;
+  unsigned short orig_id, new_id;
+  int log_id, fd, forwardall, flags;
+  time_t time;
+  unsigned char *hash[HASH_SIZE];
+#ifdef HAVE_DNSSEC 
+  int class, work_counter;
+  struct blockdata *stash; /* Saved reply, whilst we validate */
+  size_t stash_len;
+  struct frec *dependent; /* Query awaiting internally-generated DNSKEY or DS query */
+  struct frec *blocking_query; /* Query which is blocking us. */
+#endif
+  struct frec *next;
+};
+
+/* flags in top of length field for DHCP-option tables */
+#define OT_ADDR_LIST    0x8000
+#define OT_RFC1035_NAME 0x4000
+#define OT_INTERNAL     0x2000
+#define OT_NAME         0x1000
+#define OT_CSTRING      0x0800
+#define OT_DEC          0x0400 
+#define OT_TIME         0x0200
+
+/* actions in the daemon->helper RPC */
+#define ACTION_DEL           1
+#define ACTION_OLD_HOSTNAME  2
+#define ACTION_OLD           3
+#define ACTION_ADD           4
+#define ACTION_TFTP          5
+#define ACTION_ARP           6
+#define ACTION_ARP_DEL       7
+
+#define LEASE_NEW            1  /* newly created */
+#define LEASE_CHANGED        2  /* modified */
+#define LEASE_AUX_CHANGED    4  /* CLID or expiry changed */
+#define LEASE_AUTH_NAME      8  /* hostname came from config, not from client */
+#define LEASE_USED          16  /* used this DHCPv6 transaction */
+#define LEASE_NA            32  /* IPv6 no-temporary lease */
+#define LEASE_TA            64  /* IPv6 temporary lease */
+#define LEASE_HAVE_HWADDR  128  /* Have set hwaddress */
+
+struct dhcp_lease {
+  int clid_len;          /* length of client identifier */
+  unsigned char *clid;   /* clientid */
+  char *hostname, *fqdn; /* name from client-hostname option or config */
+  char *old_hostname;    /* hostname before it moved to another lease */
+  int flags;
+  time_t expires;        /* lease expiry */
+#ifdef HAVE_BROKEN_RTC
+  unsigned int length;
+#endif
+  int hwaddr_len, hwaddr_type;
+  unsigned char hwaddr[DHCP_CHADDR_MAX]; 
+  struct in_addr addr, override, giaddr;
+  unsigned char *extradata;
+  unsigned int extradata_len, extradata_size;
+  int last_interface;
+  int new_interface;     /* save possible originated interface */
+  int new_prefixlen;     /* and its prefix length */
+#ifdef HAVE_DHCP6
+  struct in6_addr addr6;
+  int iaid;
+  struct slaac_address {
+    struct in6_addr addr;
+    time_t ping_time;
+    int backoff; /* zero -> confirmed */
+    struct slaac_address *next;
+  } *slaac_address;
+  int vendorclass_count;
+#endif
+  struct dhcp_lease *next;
+};
+
+struct dhcp_netid {
+  char *net;
+  struct dhcp_netid *next;
+};
+
+struct dhcp_netid_list {
+  struct dhcp_netid *list;
+  struct dhcp_netid_list *next;
+};
+
+struct tag_if {
+  struct dhcp_netid_list *set;
+  struct dhcp_netid *tag;
+  struct tag_if *next;
+};
+
+struct delay_config {
+  int delay;
+  struct dhcp_netid *netid;
+  struct delay_config *next;
+};
+
+struct hwaddr_config {
+  int hwaddr_len, hwaddr_type;
+  unsigned char hwaddr[DHCP_CHADDR_MAX];
+  unsigned int wildcard_mask;
+  struct hwaddr_config *next;
+};
+
+struct dhcp_config {
+  unsigned int flags;
+  int clid_len;          /* length of client identifier */
+  unsigned char *clid;   /* clientid */
+  char *hostname, *domain;
+  struct dhcp_netid_list *netid;
+#ifdef HAVE_DHCP6
+  struct in6_addr addr6;
+#endif
+  struct in_addr addr;
+  time_t decline_time;
+  unsigned int lease_time;
+  struct hwaddr_config *hwaddr;
+  struct dhcp_config *next;
+};
+
+#define have_config(config, mask) ((config) && ((config)->flags & (mask))) 
+
+#define CONFIG_DISABLE           1
+#define CONFIG_CLID              2
+#define CONFIG_TIME              8
+#define CONFIG_NAME             16
+#define CONFIG_ADDR             32
+#define CONFIG_NOCLID          128
+#define CONFIG_FROM_ETHERS     256    /* entry created by /etc/ethers */
+#define CONFIG_ADDR_HOSTS      512    /* address added by from /etc/hosts */
+#define CONFIG_DECLINED       1024    /* address declined by client */
+#define CONFIG_BANK           2048    /* from dhcp hosts file */
+#define CONFIG_ADDR6          4096
+#define CONFIG_WILDCARD       8192
+
+struct dhcp_opt {
+  int opt, len, flags;
+  union {
+    int encap;
+    unsigned int wildcard_mask;
+    unsigned char *vendor_class;
+  } u;
+  unsigned char *val;
+  struct dhcp_netid *netid;
+  struct dhcp_opt *next;
+};
+
+#define DHOPT_ADDR               1
+#define DHOPT_STRING             2
+#define DHOPT_ENCAPSULATE        4
+#define DHOPT_ENCAP_MATCH        8
+#define DHOPT_FORCE             16
+#define DHOPT_BANK              32
+#define DHOPT_ENCAP_DONE        64
+#define DHOPT_MATCH            128
+#define DHOPT_VENDOR           256
+#define DHOPT_HEX              512
+#define DHOPT_VENDOR_MATCH    1024
+#define DHOPT_RFC3925         2048
+#define DHOPT_TAGOK           4096
+#define DHOPT_ADDR6           8192
+
+struct dhcp_boot {
+  char *file, *sname, *tftp_sname;
+  struct in_addr next_server;
+  struct dhcp_netid *netid;
+  struct dhcp_boot *next;
+};
+
+struct pxe_service {
+  unsigned short CSA, type; 
+  char *menu, *basename, *sname;
+  struct in_addr server;
+  struct dhcp_netid *netid;
+  struct pxe_service *next;
+};
+
+#define MATCH_VENDOR     1
+#define MATCH_USER       2
+#define MATCH_CIRCUIT    3
+#define MATCH_REMOTE     4
+#define MATCH_SUBSCRIBER 5
+
+/* vendorclass, userclass, remote-id or circuit-id */
+struct dhcp_vendor {
+  int len, match_type;
+  unsigned int enterprise;
+  char *data;
+  struct dhcp_netid netid;
+  struct dhcp_vendor *next;
+};
+
+struct dhcp_mac {
+  unsigned int mask;
+  int hwaddr_len, hwaddr_type;
+  unsigned char hwaddr[DHCP_CHADDR_MAX];
+  struct dhcp_netid netid;
+  struct dhcp_mac *next;
+};
+
+struct dhcp_bridge {
+  char iface[IF_NAMESIZE];
+  struct dhcp_bridge *alias, *next;
+};
+
+struct cond_domain {
+  char *domain, *prefix;
+  struct in_addr start, end;
+#ifdef HAVE_IPV6
+  struct in6_addr start6, end6;
+#endif
+  int is6;
+  struct cond_domain *next;
+}; 
+
+#ifdef OPTION6_PREFIX_CLASS 
+struct prefix_class {
+  int class;
+  struct dhcp_netid tag;
+  struct prefix_class *next;
+};
+#endif
+
+struct ra_interface {
+  char *name;
+  char *mtu_name;
+  int interval, lifetime, prio, mtu;
+  struct ra_interface *next;
+};
+
+struct dhcp_context {
+  unsigned int lease_time, addr_epoch;
+  struct in_addr netmask, broadcast;
+  struct in_addr local, router;
+  struct in_addr start, end; /* range of available addresses */
+#ifdef HAVE_DHCP6
+  struct in6_addr start6, end6; /* range of available addresses */
+  struct in6_addr local6;
+  int prefix, if_index;
+  unsigned int valid, preferred, saved_valid;
+  time_t ra_time, ra_short_period_start, address_lost_time;
+  char *template_interface;
+#endif
+  int flags;
+  struct dhcp_netid netid, *filter;
+  struct dhcp_context *next, *current;
+};
+
+#define CONTEXT_STATIC         (1u<<0)
+#define CONTEXT_NETMASK        (1u<<1)
+#define CONTEXT_BRDCAST        (1u<<2)
+#define CONTEXT_PROXY          (1u<<3)
+#define CONTEXT_RA_ROUTER      (1u<<4)
+#define CONTEXT_RA_DONE        (1u<<5)
+#define CONTEXT_RA_NAME        (1u<<6)
+#define CONTEXT_RA_STATELESS   (1u<<7)
+#define CONTEXT_DHCP           (1u<<8)
+#define CONTEXT_DEPRECATE      (1u<<9)
+#define CONTEXT_TEMPLATE       (1u<<10)    /* create contexts using addresses */
+#define CONTEXT_CONSTRUCTED    (1u<<11)
+#define CONTEXT_GC             (1u<<12)
+#define CONTEXT_RA             (1u<<13)
+#define CONTEXT_CONF_USED      (1u<<14)
+#define CONTEXT_USED           (1u<<15)
+#define CONTEXT_OLD            (1u<<16)
+#define CONTEXT_V6             (1u<<17)
+#define CONTEXT_RA_OFF_LINK    (1u<<18)
+
+struct ping_result {
+  struct in_addr addr;
+  time_t time;
+  unsigned int hash;
+  struct ping_result *next;
+};
+
+struct tftp_file {
+  int refcount, fd;
+  off_t size;
+  dev_t dev;
+  ino_t inode;
+  char filename[];
+};
+
+struct tftp_transfer {
+  int sockfd;
+  time_t timeout;
+  int backoff;
+  unsigned int block, blocksize, expansion;
+  off_t offset;
+  union mysockaddr peer;
+  char opt_blocksize, opt_transize, netascii, carrylf;
+  struct tftp_file *file;
+  struct tftp_transfer *next;
+};
+
+struct addr_list {
+  struct in_addr addr;
+  struct addr_list *next;
+};
+
+struct tftp_prefix {
+  char *interface;
+  char *prefix;
+  int missing;
+  struct tftp_prefix *next;
+};
+
+struct dhcp_relay {
+  struct all_addr local, server;
+  char *interface; /* Allowable interface for replies from server, and dest for IPv6 multicast */
+  int iface_index; /* working - interface in which requests arrived, for return */
+  struct dhcp_relay *current, *next;
+};
+
+extern struct daemon {
+  /* datastuctures representing the command-line and 
+     config file arguments. All set (including defaults)
+     in option.c */
+
+  unsigned int options, options2;
+  struct resolvc default_resolv, *resolv_files;
+  time_t last_resolv;
+  char *servers_file;
+  struct mx_srv_record *mxnames;
+  struct naptr *naptr;
+  struct txt_record *txt, *rr;
+  struct ptr_record *ptr;
+  struct host_record *host_records, *host_records_tail;
+  struct cname *cnames;
+  struct auth_zone *auth_zones;
+  struct interface_name *int_names;
+  char *mxtarget;
+  struct mysubnet *add_subnet4;
+  struct mysubnet *add_subnet6;
+  char *lease_file;
+  char *username, *groupname, *scriptuser;
+  char *luascript;
+  char *authserver, *hostmaster;
+  struct iname *authinterface;
+  struct name_list *secondary_forward_server;
+  int group_set, osport;
+  char *domain_suffix;
+  struct cond_domain *cond_domain, *synth_domains;
+  char *runfile; 
+  char *lease_change_command;
+  struct iname *if_names, *if_addrs, *if_except, *dhcp_except, *auth_peers, *tftp_interfaces;
+  struct bogus_addr *bogus_addr, *ignore_addr;
+  struct server *servers;
+  struct server *dns_override_server; /* for XDNS */
+  struct ipsets *ipsets;
+  int log_fac; /* log facility */
+  char *log_file; /* optional log file */
+  int max_logs;  /* queue limit */
+  int cachesize, ftabsize;
+  int port, query_port, min_port, max_port;
+  unsigned long local_ttl, neg_ttl, max_ttl, min_cache_ttl, max_cache_ttl, auth_ttl, dhcp_ttl, use_dhcp_ttl;
+  char *dns_client_id;
+  struct hostsfile *addn_hosts;
+  struct dhcp_context *dhcp, *dhcp6;
+  struct ra_interface *ra_interfaces;
+  struct dhcp_config *dhcp_conf;
+  struct dhcp_opt *dhcp_opts, *dhcp_match, *dhcp_opts6, *dhcp_match6;
+  struct dhcp_vendor *dhcp_vendors;
+  struct dhcp_mac *dhcp_macs;
+  struct dhcp_boot *boot_config;
+  struct pxe_service *pxe_services;
+  struct tag_if *tag_if; 
+  struct addr_list *override_relays;
+  struct dhcp_relay *relay4, *relay6;
+  struct delay_config *delay_conf;
+  int override;
+  int enable_pxe;
+  int doing_ra, doing_dhcp6;
+  struct dhcp_netid_list *dhcp_ignore, *dhcp_ignore_names, *dhcp_gen_names; 
+  struct dhcp_netid_list *force_broadcast, *bootp_dynamic;
+  struct hostsfile *dhcp_hosts_file, *dhcp_opts_file, *dynamic_dirs;
+  int dhcp_max, tftp_max, tftp_mtu;
+  int dhcp_server_port, dhcp_client_port;
+  int start_tftp_port, end_tftp_port; 
+  unsigned int min_leasetime;
+  struct doctor *doctors;
+  unsigned short edns_pktsz;
+  char *tftp_prefix; 
+  struct tftp_prefix *if_prefix; /* per-interface TFTP prefixes */
+  unsigned int duid_enterprise, duid_config_len;
+  unsigned char *duid_config;
+  char *dbus_name;
+  unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
+#ifdef OPTION6_PREFIX_CLASS 
+  struct prefix_class *prefix_classes;
+#endif
+#ifdef HAVE_DNSSEC
+  struct ds_config *ds;
+  int dnssec_no_time_check;
+  int back_to_the_future;
+  char *timestamp_file;
+#endif
+
+  /* globally used stuff for DNS */
+  char *packet; /* packet buffer */
+  int packet_buff_sz; /* size of above */
+  char *namebuff; /* MAXDNAME size buffer */
+#ifdef HAVE_DNSSEC
+  char *keyname; /* MAXDNAME size buffer */
+  char *workspacename; /* ditto */
+#endif
+  unsigned int local_answer, queries_forwarded, auth_answer;
+  struct frec *frec_list;
+  struct serverfd *sfds;
+  struct irec *interfaces;
+  struct listener *listeners;
+  struct server *last_server;
+  time_t forwardtime;
+  int forwardcount;
+  struct server *srv_save; /* Used for resend on DoD */
+  size_t packet_len;       /*      "        "        */
+  struct randfd *rfd_save; /*      "        "        */
+  pid_t tcp_pids[MAX_PROCS];
+  struct randfd randomsocks[RANDOM_SOCKS];
+  int v6pktinfo; 
+  struct addrlist *interface_addrs; /* list of all addresses/prefix lengths associated with all local interfaces */
+  int log_id, log_display_id; /* ids of transactions for logging */
+  union mysockaddr *log_source_addr;
+
+  /* DHCP state */
+  int dhcpfd, helperfd, pxefd; 
+#ifdef HAVE_INOTIFY
+  int inotifyfd;
+#endif
+#if defined(HAVE_LINUX_NETWORK)
+  int netlinkfd;
+#elif defined(HAVE_BSD_NETWORK)
+  int dhcp_raw_fd, dhcp_icmp_fd, routefd;
+#endif
+  struct iovec dhcp_packet;
+  char *dhcp_buff, *dhcp_buff2, *dhcp_buff3;
+  struct ping_result *ping_results;
+  FILE *lease_stream;
+  struct dhcp_bridge *bridges;
+#ifdef HAVE_DHCP6
+  int duid_len;
+  unsigned char *duid;
+  struct iovec outpacket;
+  int dhcp6fd, icmp6fd;
+#endif
+  /* DBus stuff */
+  /* void * here to avoid depending on dbus headers outside dbus.c */
+  void *dbus;
+#ifdef HAVE_DBUS
+  struct watch *watches;
+#endif
+
+  /* TFTP stuff */
+  struct tftp_transfer *tftp_trans, *tftp_done_trans;
+
+  /* utility string buffer, hold max sized IP address as string */
+  char *addrbuff;
+  char *addrbuff2; /* only allocated when OPT_EXTRALOG */
+
+} *daemon;
+
+/* cache.c */
+void cache_init(void);
+void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg); 
+char *record_source(unsigned int index);
+char *querystr(char *desc, unsigned short type);
+struct crec *cache_find_by_addr(struct crec *crecp,
+				struct all_addr *addr, time_t now, 
+				unsigned int prot);
+struct crec *cache_find_by_name(struct crec *crecp, 
+				char *name, time_t now, unsigned int prot);
+void cache_end_insert(void);
+void cache_start_insert(void);
+struct crec *cache_insert(char *name, struct all_addr *addr,
+			  time_t now, unsigned long ttl, unsigned short flags);
+void cache_reload(void);
+void cache_add_dhcp_entry(char *host_name, int prot, struct all_addr *host_address, time_t ttd);
+struct in_addr a_record_from_hosts(char *name, time_t now);
+void cache_unhash_dhcp(void);
+void dump_cache(time_t now);
+#ifndef NO_ID
+int cache_make_stat(struct txt_record *t);
+#endif
+char *cache_get_name(struct crec *crecp);
+char *cache_get_cname_target(struct crec *crecp);
+struct crec *cache_enumerate(int init);
+int read_hostsfile(char *filename, unsigned int index, int cache_size, 
+		   struct crec **rhash, int hashsz);
+
+/* blockdata.c */
+#ifdef HAVE_DNSSEC
+void blockdata_init(void);
+void blockdata_report(void);
+struct blockdata *blockdata_alloc(char *data, size_t len);
+void *blockdata_retrieve(struct blockdata *block, size_t len, void *data);
+void blockdata_free(struct blockdata *blocks);
+#endif
+
+/* domain.c */
+char *get_domain(struct in_addr addr);
+#ifdef HAVE_IPV6
+char *get_domain6(struct in6_addr *addr);
+#endif
+int is_name_synthetic(int flags, char *name, struct all_addr *addr);
+int is_rev_synth(int flag, struct all_addr *addr, char *name);
+
+/* rfc1035.c */
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
+                 char *name, int isExtract, int extrabytes);
+unsigned char *skip_name(unsigned char *ansp, struct dns_header *header, size_t plen, int extrabytes);
+unsigned char *skip_questions(struct dns_header *header, size_t plen);
+unsigned char *skip_section(unsigned char *ansp, int count, struct dns_header *header, size_t plen);
+unsigned int extract_request(struct dns_header *header, size_t qlen, 
+			       char *name, unsigned short *typep);
+size_t setup_reply(struct dns_header *header, size_t  qlen,
+		   struct all_addr *addrp, unsigned int flags,
+		   unsigned long ttl);
+int extract_addresses(struct dns_header *header, size_t qlen, char *name,
+		      time_t now, char **ipsets, int is_sign, int check_rebind,
+		      int no_cache_dnssec, int secure, int *doctored);
+size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
+		      struct in_addr local_addr, struct in_addr local_netmask, 
+		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader);
+int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
+			     struct bogus_addr *baddr, time_t now);
+int check_for_ignored_address(struct dns_header *header, size_t qlen, struct bogus_addr *baddr);
+int check_for_local_domain(char *name, time_t now);
+unsigned int questions_crc(struct dns_header *header, size_t plen, char *name);
+size_t resize_packet(struct dns_header *header, size_t plen, 
+		  unsigned char *pheader, size_t hlen);
+int add_resource_record(struct dns_header *header, char *limit, int *truncp,
+			int nameoffset, unsigned char **pp, unsigned long ttl, 
+			int *offset, unsigned short type, unsigned short class, char *format, ...);
+unsigned char *skip_questions(struct dns_header *header, size_t plen);
+int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
+		 char *name, int isExtract, int extrabytes);
+int in_arpa_name_2_addr(char *namein, struct all_addr *addrp);
+int private_net(struct in_addr addr, int ban_localhost);
+
+/* auth.c */
+#ifdef HAVE_AUTH
+size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, 
+		   time_t now, union mysockaddr *peer_addr, int local_query,
+		   int do_bit, int have_pseudoheader);
+int in_zone(struct auth_zone *zone, char *name, char **cut);
+#endif
+
+/* dnssec.c */
+size_t dnssec_generate_query(struct dns_header *header, unsigned char *end, char *name, int class, int type, union mysockaddr *addr, int edns_pktsz);
+int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
+int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
+int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int *class,
+			  int check_unsigned, int *neganswer, int *nons);
+int dnskey_keytag(int alg, int flags, unsigned char *key, int keylen);
+size_t filter_rrsigs(struct dns_header *header, size_t plen);
+unsigned char* hash_questions(struct dns_header *header, size_t plen, char *name);
+int setup_timestamp(void);
+
+/* util.c */
+void rand_init(void);
+unsigned short rand16(void);
+u32 rand32(void);
+u64 rand64(void);
+int legal_hostname(char *name);
+char *canonicalise(char *in, int *nomem);
+unsigned char *do_rfc1035_name(unsigned char *p, char *sval, char *limit);
+void *safe_malloc(size_t size);
+void safe_pipe(int *fd, int read_noblock);
+void *whine_malloc(size_t size);
+int sa_len(union mysockaddr *addr);
+int sockaddr_isequal(union mysockaddr *s1, union mysockaddr *s2);
+int hostname_isequal(const char *a, const char *b);
+time_t dnsmasq_time(void);
+int netmask_length(struct in_addr mask);
+int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask);
+#ifdef HAVE_IPV6
+int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen);
+u64 addr6part(struct in6_addr *addr);
+void setaddr6part(struct in6_addr *addr, u64 host);
+#endif
+int retry_send(ssize_t rc);
+void prettyprint_time(char *buf, unsigned int t);
+int prettyprint_addr(union mysockaddr *addr, char *buf);
+int parse_hex(char *in, unsigned char *out, int maxlen, 
+	      unsigned int *wildcard_mask, int *mac_type);
+int memcmp_masked(unsigned char *a, unsigned char *b, int len, 
+		  unsigned int mask);
+int expand_buf(struct iovec *iov, size_t size);
+char *print_mac(char *buff, unsigned char *mac, int len);
+int read_write(int fd, unsigned char *packet, int size, int rw);
+
+int wildcard_match(const char* wildcard, const char* match);
+int wildcard_matchn(const char* wildcard, const char* match, int num);
+
+/* log.c */
+void die(char *message, char *arg1, int exit_code);
+int log_start(struct passwd *ent_pw, int errfd);
+int log_reopen(char *log_file);
+
+void my_syslog(int priority, const char *format, ...);
+
+void set_log_writer(void);
+void check_log_writer(int force);
+void flush_log(void);
+
+/* option.c */
+void read_opts (int argc, char **argv, char *compile_opts);
+char *option_string(int prot, unsigned int opt, unsigned char *val, 
+		    int opt_len, char *buf, int buf_len);
+void reread_dhcp(void);
+void read_servers_file(void);
+void set_option_bool(unsigned int opt);
+void reset_option_bool(unsigned int opt);
+struct hostsfile *expand_filelist(struct hostsfile *list);
+char *parse_server(char *arg, union mysockaddr *addr, 
+		   union mysockaddr *source_addr, char *interface, int *flags);
+int option_read_dynfile(char *file, int flags);
+
+/* forward.c */
+void reply_query(int fd, int family, time_t now);
+void receive_query(struct listener *listen, time_t now);
+unsigned char *tcp_request(int confd, time_t now,
+			   union mysockaddr *local_addr, struct in_addr netmask, int auth_dns);
+void server_gone(struct server *server);
+struct frec *get_new_frec(time_t now, int *wait, int force);
+int send_from(int fd, int nowild, char *packet, size_t len, 
+	       union mysockaddr *to, struct all_addr *source,
+	       unsigned int iface);
+void resend_query(void);
+struct randfd *allocate_rfd(int family);
+void free_rfd(struct randfd *rfd);
+
+/* network.c */
+int indextoname(int fd, int index, char *name);
+int local_bind(int fd, union mysockaddr *addr, char *intname, int is_tcp);
+int random_sock(int family);
+void pre_allocate_sfds(void);
+int reload_servers(char *fname);
+void mark_servers(int flag);
+void cleanup_servers(void);
+void add_update_server(int flags,
+		       union mysockaddr *addr,
+		       union mysockaddr *source_addr,
+		       const char *interface,
+		       const char *domain);
+void check_servers(void);
+int enumerate_interfaces(int reset);
+void create_wildcard_listeners(void);
+void create_bound_listeners(int dienow);
+void warn_bound_listeners(void);
+void warn_wild_labels(void);
+void warn_int_names(void);
+int is_dad_listeners(void);
+int iface_check(int family, struct all_addr *addr, char *name, int *auth);
+int loopback_exception(int fd, int family, struct all_addr *addr, char *name);
+int label_exception(int index, int family, struct all_addr *addr);
+int fix_fd(int fd);
+int tcp_interface(int fd, int af);
+#ifdef HAVE_IPV6
+int set_ipv6pktinfo(int fd);
+#endif
+#ifdef HAVE_DHCP6
+void join_multicast(int dienow);
+#endif
+#if defined(HAVE_LINUX_NETWORK) || defined(HAVE_BSD_NETWORK)
+void newaddress(time_t now);
+#endif
+
+
+/* dhcp.c */
+#ifdef HAVE_DHCP
+void dhcp_init(void);
+void dhcp_packet(time_t now, int pxe_fd);
+struct dhcp_context *address_available(struct dhcp_context *context, 
+				       struct in_addr taddr,
+				       struct dhcp_netid *netids);
+struct dhcp_context *narrow_context(struct dhcp_context *context, 
+				    struct in_addr taddr,
+				    struct dhcp_netid *netids);
+struct ping_result *do_icmp_ping(time_t now, struct in_addr addr,
+				 unsigned int hash, int loopback);
+int address_allocate(struct dhcp_context *context,
+		     struct in_addr *addrp, unsigned char *hwaddr, int hw_len,
+		     struct dhcp_netid *netids, time_t now, int loopback);
+void dhcp_read_ethers(void);
+struct dhcp_config *config_find_by_address(struct dhcp_config *configs, struct in_addr addr);
+char *host_from_dns(struct in_addr addr);
+#endif
+
+/* lease.c */
+#ifdef HAVE_DHCP
+void lease_update_file(time_t now);
+void lease_update_dns(int force);
+void lease_init(time_t now);
+struct dhcp_lease *lease4_allocate(struct in_addr addr);
+#ifdef HAVE_DHCP6
+struct dhcp_lease *lease6_allocate(struct in6_addr *addrp, int lease_type);
+struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
+			       int lease_type, int iaid, struct in6_addr *addr);
+void lease6_reset(void);
+struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid);
+struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix, u64 addr);
+u64 lease_find_max_addr6(struct dhcp_context *context);
+void lease_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface);
+void lease_update_slaac(time_t now);
+void lease_set_iaid(struct dhcp_lease *lease, int iaid);
+void lease_make_duid(time_t now);
+#endif
+void lease_set_hwaddr(struct dhcp_lease *lease, const unsigned char *hwaddr,
+		      const unsigned char *clid, int hw_len, int hw_type,
+		      int clid_len, time_t now, int force);
+void lease_set_hostname(struct dhcp_lease *lease, const char *name, int auth, char *domain, char *config_domain);
+void lease_set_expires(struct dhcp_lease *lease, unsigned int len, time_t now);
+void lease_set_interface(struct dhcp_lease *lease, int interface, time_t now);
+struct dhcp_lease *lease_find_by_client(unsigned char *hwaddr, int hw_len, int hw_type,  
+					unsigned char *clid, int clid_len);
+struct dhcp_lease *lease_find_by_addr(struct in_addr addr);
+struct in_addr lease_find_max_addr(struct dhcp_context *context);
+void lease_prune(struct dhcp_lease *target, time_t now);
+void lease_update_from_configs(void);
+int do_script_run(time_t now);
+void rerun_scripts(void);
+void lease_find_interfaces(time_t now);
+#ifdef HAVE_SCRIPT
+void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data, 
+			 unsigned int len, int delim);
+#endif
+#endif
+
+/* rfc2131.c */
+#ifdef HAVE_DHCP
+size_t dhcp_reply(struct dhcp_context *context, char *iface_name, int int_index,
+		  size_t sz, time_t now, int unicast_dest, int loopback,
+		  int *is_inform, int pxe, struct in_addr fallback, time_t recvtime);
+unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr, 
+			       int clid_len, unsigned char *clid, int *len_out);
+#endif
+
+/* dnsmasq.c */
+#ifdef HAVE_DHCP
+int make_icmp_sock(void);
+int icmp_ping(struct in_addr addr);
+int delay_dhcp(time_t start, int sec, int fd, uint32_t addr, unsigned short id);
+#endif
+void queue_event(int event);
+void send_alarm(time_t event, time_t now);
+void send_event(int fd, int event, int data, char *msg);
+void clear_cache_and_reload(time_t now);
+
+/* netlink.c */
+#ifdef HAVE_LINUX_NETWORK
+void netlink_init(void);
+void netlink_multicast(void);
+#endif
+
+/* bpf.c */
+#ifdef HAVE_BSD_NETWORK
+void init_bpf(void);
+void send_via_bpf(struct dhcp_packet *mess, size_t len,
+		  struct in_addr iface_addr, struct ifreq *ifr);
+void route_init(void);
+void route_sock(void);
+#endif
+
+/* bpf.c or netlink.c */
+int iface_enumerate(int family, void *parm, int (callback)());
+
+/* dbus.c */
+#ifdef HAVE_DBUS
+char *dbus_init(void);
+void check_dbus_listeners(void);
+void set_dbus_listeners(void);
+#  ifdef HAVE_DHCP
+void emit_dbus_signal(int action, struct dhcp_lease *lease, char *hostname);
+#  endif
+#endif
+
+/* ipset.c */
+#ifdef HAVE_IPSET
+void ipset_init(void);
+int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags, int remove);
+#endif
+
+/* helper.c */
+#if defined(HAVE_SCRIPT)
+int create_helper(int event_fd, int err_fd, uid_t uid, gid_t gid, long max_fd);
+void helper_write(void);
+void queue_script(int action, struct dhcp_lease *lease, 
+		  char *hostname, time_t now);
+#ifdef HAVE_TFTP
+void queue_tftp(off_t file_len, char *filename, union mysockaddr *peer);
+#endif
+void queue_arp(int action, unsigned char *mac, int maclen,
+	       int family, struct all_addr *addr);
+int helper_buf_empty(void);
+#endif
+
+/* tftp.c */
+#ifdef HAVE_TFTP
+void tftp_request(struct listener *listen, time_t now);
+void check_tftp_listeners(time_t now);
+int do_tftp_script_run(void);
+#endif
+
+/* conntrack.c */
+#ifdef HAVE_CONNTRACK
+int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr,
+		      int istcp, unsigned int *markp);
+#endif
+
+/* dhcp6.c */
+#ifdef HAVE_DHCP6
+void dhcp6_init(void);
+void dhcp6_packet(time_t now);
+struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
+				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans);
+int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr);
+struct dhcp_context *address6_available(struct dhcp_context *context, 
+					struct in6_addr *taddr,
+					struct dhcp_netid *netids,
+					int plain_range);
+struct dhcp_context *address6_valid(struct dhcp_context *context, 
+				    struct in6_addr *taddr,
+				    struct dhcp_netid *netids,
+				    int plain_range);
+struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, 
+					    int prefix, u64 addr);
+void make_duid(time_t now);
+void dhcp_construct_contexts(time_t now);
+void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, 
+		    unsigned int *maclenp, unsigned int *mactypep, time_t now);
+#endif
+  
+/* rfc3315.c */
+#ifdef HAVE_DHCP6
+unsigned short dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,  
+			   struct in6_addr *fallback, struct in6_addr *ll_addr, struct in6_addr *ula_addr,
+			   size_t sz, struct in6_addr *client_addr, time_t now);
+void relay_upstream6(struct dhcp_relay *relay, ssize_t sz, struct in6_addr *peer_address, 
+		     u32 scope_id, time_t now);
+
+unsigned short relay_reply6( struct sockaddr_in6 *peer, ssize_t sz, char *arrival_interface);
+#endif
+
+/* dhcp-common.c */
+#ifdef HAVE_DHCP
+void dhcp_common_init(void);
+ssize_t recv_dhcp_packet(int fd, struct msghdr *msg);
+struct dhcp_netid *run_tag_if(struct dhcp_netid *tags);
+struct dhcp_netid *option_filter(struct dhcp_netid *tags, struct dhcp_netid *context_tags,
+				 struct dhcp_opt *opts);
+int match_netid(struct dhcp_netid *check, struct dhcp_netid *pool, int tagnotneeded);
+char *strip_hostname(char *hostname);
+void log_tags(struct dhcp_netid *netid, u32 xid);
+int match_bytes(struct dhcp_opt *o, unsigned char *p, int len);
+void dhcp_update_configs(struct dhcp_config *configs);
+void display_opts(void);
+int lookup_dhcp_opt(int prot, char *name);
+int lookup_dhcp_len(int prot, int val);
+char *option_string(int prot, unsigned int opt, unsigned char *val, 
+		    int opt_len, char *buf, int buf_len);
+struct dhcp_config *find_config(struct dhcp_config *configs,
+				struct dhcp_context *context,
+				unsigned char *clid, int clid_len,
+				unsigned char *hwaddr, int hw_len, 
+				int hw_type, char *hostname);
+int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len, int type);
+#ifdef HAVE_LINUX_NETWORK
+char *whichdevice(void);
+void bindtodevice(char *device, int fd);
+#endif
+#  ifdef HAVE_DHCP6
+void display_opts6(void);
+#  endif
+void log_context(int family, struct dhcp_context *context);
+void log_relay(int family, struct dhcp_relay *relay);
+#endif
+
+/* outpacket.c */
+#ifdef HAVE_DHCP6
+void end_opt6(int container);
+void reset_counter(void);
+int save_counter(int newval);
+void *expand(size_t headroom);
+int new_opt6(int opt);
+void *put_opt6(void *data, size_t len);
+void put_opt6_long(unsigned int val);
+void put_opt6_short(unsigned int val);
+void put_opt6_char(unsigned int val);
+void put_opt6_string(char *s);
+#endif
+
+/* radv.c */
+#ifdef HAVE_DHCP6
+void ra_init(time_t now);
+void icmp6_packet(time_t now);
+time_t periodic_ra(time_t now);
+void ra_start_unsolicited(time_t now, struct dhcp_context *context);
+#endif
+
+/* slaac.c */ 
+#ifdef HAVE_DHCP6
+void slaac_add_addrs(struct dhcp_lease *lease, time_t now, int force);
+time_t periodic_slaac(time_t now, struct dhcp_lease *leases);
+void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface, struct dhcp_lease *leases);
+#endif
+
+/* loop.c */
+#ifdef HAVE_LOOP
+void loop_send_probes(void);
+int detect_loop(char *query, int type);
+#endif
+
+/* inotify.c */
+#ifdef HAVE_INOTIFY
+void inotify_dnsmasq_init(void);
+int inotify_check(time_t now);
+void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz);
+#endif
+
+/* poll.c */
+void poll_reset(void);
+int poll_check(int fd, short event);
+void poll_listen(int fd, short event);
+int do_poll(int timeout);
+
+/* rrfilter.c */
+size_t rrfilter(struct dns_header *header, size_t plen, int mode);
+u16 *rrfilter_desc(int type);
+int expand_workspace(unsigned char ***wkspc, int *szp, int new);
+
+/* edns0.c */
+unsigned char *find_pseudoheader(struct dns_header *header, size_t plen,
+				   size_t *len, unsigned char **p, int *is_sign, int *is_last);
+size_t add_pseudoheader(struct dns_header *header, size_t plen, unsigned char *limit, 
+			unsigned short udp_sz, int optno, unsigned char *opt, size_t optlen, int set_do, int replace);
+size_t add_do_bit(struct dns_header *header, size_t plen, unsigned char *limit);
+size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *limit, 
+			union mysockaddr *source, time_t now, int *check_subnet);
+int check_source(struct dns_header *header, size_t plen, unsigned char *pseudoheader, union mysockaddr *peer);
+
+/* arp.c */
+int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now);
+int update_dnsoverride_records(struct dnsoverride_record *precord);
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr);
+struct dnsoverride_record* get_dnsoverride_defaultrecord();
+int find_dnsoverride_server(char* macaddr, struct all_addr* serv);
+int find_dnsoverride_defaultserver(struct all_addr* serv);
+int do_arp_script_run(void);
diff -Naur dnsmasq-2.78.orig/src/edns0.c dnsmasq-2.78/src/edns0.c
--- dnsmasq-2.78.orig/src/edns0.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/edns0.c	2018-06-21 09:32:55.807135141 +0000
@@ -264,6 +264,55 @@
   out[3] = char64(in[2]);
 }
 
+/* XDNS - Add cpe tag for XDNS if found */
+static size_t add_cpe_tag(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       unsigned char mac[DHCP_CHADDR_MAX] = {0};
+       int maclen = 0;
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+
+       struct dnsoverride_record* dnsrec = NULL;
+       unsigned char* cpetag = NULL;
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+               print_mac(strmac, mac, maclen);
+
+               dnsrec = get_dnsoverride_record(strmac);
+               if(!dnsrec)
+                       dnsrec = get_dnsoverride_defaultrecord();
+
+               if(dnsrec && dnsrec->cpetag[0])
+               {
+                       //my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() - found cpetag: %s"), dnsrec->cpetag);
+                       cpetag = dnsrec->cpetag;
+               }
+               else
+               {
+                       my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() Could not find cpetag for mac %s"), strmac);
+               }
+       }
+
+       //if cpetag not found try to use the one from dnsmasq options
+       if(cpetag == NULL)
+       {
+               cpetag = (unsigned char *)daemon->dns_client_id;
+       }
+
+       // if no cpetag found return. Don't call add header.
+       if(cpetag == NULL)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : no cpetag found in dnsmasq config"));
+               return plen;
+       }
+
+       my_syslog(LOG_WARNING, _("### XDNS - add cpe tag \'%s\' to edns0 header for mac [%s]"), cpetag, strmac);
+       return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, cpetag, strlen(cpetag), 0, 1);
+}
+//</XDNS>
+
+
 static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
 {
   int maclen, replace = 2; /* can't get mac address, just delete any incoming. */
@@ -287,15 +336,140 @@
   return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMDEVICEID, (unsigned char *)encode, strlen(encode), 0, replace); 
 }
 
+// XDNS
+void set_option_dnsoverride()
+{
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options |= 1u << OPT_DNS_OVERRIDE;
+  else
+    daemon->options2 |= 1u << (OPT_DNS_OVERRIDE - 32);
+}
+
+// XDNS
+void reset_option_dnsoverride()
+{
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options &= ~(1u << OPT_DNS_OVERRIDE);
+  else
+    daemon->options2 &= ~(1u << (OPT_DNS_OVERRIDE - 32));
+}
 
-static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+// XDNS
+static size_t add_xdns_server(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
 {
-  int maclen;
+  int maclen = 0;
   unsigned char mac[DHCP_CHADDR_MAX];
 
+       // find mac from socket addr
   if ((maclen = find_mac(l3, mac, 1, now)) != 0)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0); 
-    
+  {
+       // get mac in string format
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+       print_mac(strmac, mac, maclen);
+
+               my_syslog(LOG_INFO, _("### XDNS - add_xdns_server() for mac [%s]"), strmac);
+
+               // find family type from socket addr
+               int iptype = 4;
+               if(l3->sa.sa_family == AF_INET)
+               {
+                       iptype = 4;
+               }
+#ifdef HAVE_IPV6
+               else if(l3->sa.sa_family == AF_INET6)
+               {
+                       iptype = 6;
+               }
+#endif
+
+               // get appropriate ipv4 or ipv6 dnsoverride address using mac addr
+               struct all_addr dnsaddr;
+               memset(&dnsaddr, 0, sizeof(struct all_addr));
+
+               struct server *serv = NULL;
+
+               // if xdns addr for same iptype, if not found try for other iptype
+               // then try the default.
+               if(!find_dnsoverride_server(strmac, &dnsaddr, iptype))
+               {
+                      if(find_dnsoverride_server(strmac, &dnsaddr, (iptype==4)?6:4))//try other type
+                      {
+                             iptype = (iptype==4)?6:4;
+                      }
+                      else if(!find_dnsoverride_defaultserver(&dnsaddr, iptype))
+                      {
+                            if(find_dnsoverride_defaultserver(&dnsaddr, (iptype==4)?6:4))//try other type
+                            {
+                                   iptype = (iptype==4)?6:4;
+                            }
+                            else
+                            {
+                                   my_syslog(LOG_WARNING, _("#### XDNS : add_xdns_server() Could't find xdns server for [%s] or the default server!"), strmac);
+                                   reset_option_dnsoverride();
+                                   return plen;
+                            }
+                      }
+               }
+               //else found xdns server to use.
+
+               serv = daemon->dns_override_server;
+               if(!serv) // if first time, daemon->dns_override_server is NULL. Allocate
+               {
+                      serv = whine_malloc(sizeof (struct server)); //allocated once & reused. Not freed.
+                      if(serv)
+                      {
+                            memset(serv, 0, sizeof(struct server));
+                      }
+                      daemon->dns_override_server = serv;
+               }
+
+               if(serv)
+               {
+                       if(iptype == 4)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv4 dns_override_server entry in daemon"));
+                              //serv->addr.in.sin_addr = dnsaddr.addr.addr4;
+                               memcpy(&serv->addr.in.sin_addr, &dnsaddr.addr.addr4, sizeof(struct in_addr));
+                               serv->addr.sa.sa_family = AF_INET;
+                       }
+#ifdef HAVE_IPV6
+                       else if(iptype == 6)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv6 dns_override_server entry in daemon"));
+                               //serv->addr.in6.sin6_addr = dnsaddr.addr.addr6;
+                               memcpy(&serv->addr.in6.sin6_addr, &dnsaddr.addr.addr6, sizeof(struct in6_addr));
+                               serv->addr.sa.sa_family = AF_INET6;
+                       }
+#endif
+                   // Trigger overriding of upstream server
+                   set_option_dnsoverride();
+                }
+    }
+	else
+	{
+		reset_option_dnsoverride();
+		my_syslog(LOG_WARNING, _("#### XDNS : could not find MAC from l3 sockaddr !"));
+	}
+
+       return plen;
+}
+
+static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       my_syslog(LOG_WARNING, _("#### XDNS : add_mac() called"));
+       int maclen = 0;
+       unsigned char mac[DHCP_CHADDR_MAX];
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+          plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0);
+       }
+       else
+       {
+       	my_syslog(LOG_WARNING, _("#### XDNS : add_mac() maclen = 0 !!"));
+       	reset_option_dnsoverride();
+       }
   return plen; 
 }
 
@@ -435,10 +609,16 @@
   if (option_bool(OPT_MAC_B64) || option_bool(OPT_MAC_HEX))
     plen = add_dns_client(header, plen, limit, source, now);
 
-  if (daemon->dns_client_id)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, 
-			    (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
-  
+  /* <XDNS> */
+  plen = add_xdns_server(header, plen, limit, source, now);
+
+  //if (daemon->dns_client_id)
+  //  plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID,
+  //               (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
+  plen = add_cpe_tag(header, plen, limit, source, now);
+
+  /* </XDNS> */
+ 
   if (option_bool(OPT_CLIENT_SUBNET))
     {
       plen = add_source_addr(header, plen, limit, source); 
diff -Naur dnsmasq-2.78.orig/src/forward.c dnsmasq-2.78/src/forward.c
--- dnsmasq-2.78.orig/src/forward.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/forward.c	2018-06-21 09:32:55.811135025 +0000
@@ -449,9 +449,56 @@
 	    {
 	      int fd;
 
+// < XDNS for IPv6>
+                 if(option_bool(OPT_DNS_OVERRIDE) && daemon->dns_override_server)
+                 {
+                                 my_syslog(LOG_INFO, _("#### XDNS - finding server socket to use based on dns_override_server family "));
+       #ifdef HAVE_IPV6
+                                 if (daemon->dns_override_server->addr.sa.sa_family == AF_INET6)
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET6 family"));
+                                         if (!forward->rfd6 &&
+                                                         !(forward->rfd6 = allocate_rfd(AF_INET6)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd6;
+                                         fd = forward->rfd6->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP6 fd to use: %d "), fd);
+                                 }
+                                 else
+       #endif
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET family"));
+                                         if (!forward->rfd4 &&
+                                                         !(forward->rfd4 = allocate_rfd(AF_INET)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd4;
+                                         fd = forward->rfd4->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP4 fd to use: %d "), fd);
+                                 }
+
+       #ifdef HAVE_CONNTRACK
+                                 /* Copy connection mark of incoming query to outgoing connection. */
+                                 if (option_bool(OPT_CONNTRACK))
+                                 {
+                                         unsigned int mark;
+                                         if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
+                                                 setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                                 }
+       #endif
+
+                 }
+//</ XDNS for IPv6>
+
+                 else
+                 {
+                         //my_syslog(LOG_INFO, _("#### XDNS - OPT_DNS_OVERRIDE not set or dns_override_server empty. finding fd regular way "));
+
 	      /* find server socket to use, may need to get random one. */
 	      if (start->sfd)
+                         {
 		fd = start->sfd->fd;
+                                 my_syslog(LOG_INFO, _("#### XDNS - found server socket to use: %d "), start->sfd->fd);
+                         }
 	      else 
 		{
 #ifdef HAVE_IPV6
@@ -482,6 +529,7 @@
 			setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
 		    }
 #endif
+                        }
 		}
 	      
 #ifdef HAVE_DNSSEC
@@ -499,13 +547,94 @@
 		    PUTSHORT(start->edns_pktsz, pheader);
 		}
 #endif
+                 //<XDNS>
+                       //=====
+                 //my_syslog(LOG_INFO, _("#### XDNS - List of nameservers: "));
+                        struct server *indx;
+                for (indx = daemon->servers; indx; indx = indx->next)
+                {
+                         char strprn[64] = {0}; memset(strprn, 0, 64);
+                         if(indx->addr.sa.sa_family == AF_INET)
+                         {
+                                 inet_ntop(AF_INET, &(indx->addr.in.sin_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in.sin_port, indx->addr.in.sin_family);
+
+                        }
+                         else if(indx->addr.sa.sa_family == AF_INET6)
+                         {
+                                 inet_ntop(AF_INET6, &(indx->addr.in6.sin6_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in6.sin6_port, indx->addr.in6.sin6_family);
+                         }
+                 }
+
+
+			if(option_bool(OPT_DNS_OVERRIDE) && daemon->dns_override_server)
+			{
+			  char strprn[64] = {0};
+			  if(daemon->dns_override_server->addr.sa.sa_family == AF_INET)
+			  {
+				  memset(strprn, 0, 64);
+				  if(inet_ntop(AF_INET, &(daemon->dns_override_server->addr.in.sin_addr), strprn, 64))
+				  {
+					  if(strprn[0] != 0 && strcmp(strprn, "0.0.0.0") != 0)
+					  {
+						  memcpy(&start->addr.in.sin_addr, &daemon->dns_override_server->addr.in.sin_addr, sizeof(struct in_addr));
+						  start->addr.in.sin_family = AF_INET;
+			   			  //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv4 xDNS addr"));
+					  }
+				  }
+			  }
+			  else if(daemon->dns_override_server->addr.sa.sa_family == AF_INET6)
+			  {
+				  memset(strprn, 0, 64);
+				  if(inet_ntop(AF_INET6, &(daemon->dns_override_server->addr.in6.sin6_addr), strprn, 64))
+				  {
+					  if(strprn[0] != 0 && strcmp(strprn, "::") != 0)
+					  {
+				  		  memcpy(&start->addr.in6.sin6_addr, &daemon->dns_override_server->addr.in6.sin6_addr, sizeof(struct in6_addr));
+				  		  start->addr.in6.sin6_family = AF_INET6;
+			   			  //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv6 xDNS addr"));
+					  }
+				  }
+			  }
+			  else
+			  {
+				  my_syslog(LOG_WARNING, _("#### XDNS - dns_override_server family error!!"));
+			  }
+			}
+			else
+			{
+			  //my_syslog(LOG_WARNING, _("#### XDNS - Did not modify upstream addr!"));
+			}
 
-	      if (retry_send(sendto(fd, (char *)header, plen, 0,
-				    &start->addr.sa,
-				    sa_len(&start->addr))))
-		continue;
-	    
-	      if (errno == 0)
+                 // Print where udp send is sending to:
+                 char strprn[64] = {0}; memset(strprn, 0, 64);
+                 if(start->addr.sa.sa_family == AF_INET)
+                         inet_ntop(AF_INET, &(start->addr.in.sin_addr), strprn, 64);
+                 else if(start->addr.sa.sa_family == AF_INET6)
+                         inet_ntop(AF_INET6, &(start->addr.in6.sin6_addr), strprn, 64);
+
+			  my_syslog(LOG_INFO, _("#### XDNS - sendto (%u, 0x%x, len = %d) to %s : %s)"),
+				  fd,
+				  (int)&start->addr.sa,
+				  sa_len(&start->addr),
+				  (start->addr.sa.sa_family == AF_INET6)?"ipv6":"ipv4", strprn);
+
+                 //=====
+                 // </XDNS>
+
+                 if (retry_send(
+                         sendto(fd,
+                                 (char *)header, plen, 0,
+                                 (const struct sockaddr *)&start->addr.sa,
+                                 (socklen_t)sa_len(&start->addr))))
+             {
+                 my_syslog(LOG_WARNING, _("#### XDNS : retry_send() retry..."));
+                 continue;
+             }
+    
+
+		if (errno == 0) //succeeded
 		{
 		  /* Keep info in case we want to re-send this packet */
 		  daemon->srv_save = start;
@@ -528,8 +657,12 @@
 		    break;
 		  forward->forwardall++;
 		}
-	    } 
-	  
+		else
+		{
+		         my_syslog(LOG_WARNING, _("#### XDNS : sendto() failed!"));
+		}
+	}
+ 
 	  if (!(start = start->next))
  	    start = daemon->servers;
 	  
diff -Naur dnsmasq-2.78.orig/src/network.c dnsmasq-2.78/src/network.c
--- dnsmasq-2.78.orig/src/network.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/network.c	2018-06-21 09:32:55.815134910 +0000
@@ -1598,89 +1598,208 @@
   cleanup_servers();
 }
 
+/* XDNS - Helper to create override server entries in record. Builds pprec list and returns the head. */
+static int create_dnsoverride_servers(struct dnsoverride_record **pprec, char* macaddr, char *srvaddr4, char *srvaddr6, char *cpetag)
+{
+       if(!macaddr || !srvaddr4) //MAC and Serv addr are must. cpetag is optional
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - mandatory fields (macaddr or ipv4addr) missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+#ifdef HAVE_IPV6
+       if(srvaddr6 == NULL)
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - ipv6 addr missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+
+#endif
+
+
+       my_syslog(LOG_ERR, _("### XDNS # macaddr : \"%s\""), macaddr);
+       my_syslog(LOG_ERR, _("### XDNS # srvaddr4 : \"%s\""), srvaddr4);
+#ifdef HAVE_IPV6
+       my_syslog(LOG_ERR, _("### XDNS # srvaddr6 : \"%s\""), srvaddr6);
+#endif
+
+       my_syslog(LOG_ERR, _("### XDNS # cpetag  : \"%s\""), cpetag);
+
+       //create entry and attach to record. This entries are maintained in arp.c. Cleanup is done there.
+       struct dnsoverride_record* entry = NULL;
+       if ((entry = whine_malloc(sizeof(struct dnsoverride_record))))
+       {
+               memset(entry, 0, sizeof(struct dnsoverride_record));
+
+               if(strlen(macaddr) < REC_ADDR_MAX)
+               {
+                       strcpy(entry->macaddr, macaddr);
+               }
+
+               if (inet_pton(AF_INET, srvaddr4, &entry->dnsaddr4.addr.addr4) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IP4 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+#ifdef HAVE_IPV6
+               if (inet_pton(AF_INET6, srvaddr6, &entry->dnsaddr6.addr.addr6) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IPv6 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+#endif
+               if(cpetag && strlen(cpetag) < REC_STR_MAX)
+               {
+                       strcpy(entry->cpetag, cpetag);
+               }
+
+
+               entry->next = *pprec;
+               *pprec = entry;
+       }
+       return 1; //success
+}
+
+
 /* Return zero if no servers found, in that case we keep polling.
    This is a protection against an update-time/write race on resolv.conf */
 int reload_servers(char *fname)
 {
-  FILE *f;
-  char *line;
-  int gotone = 0;
-
-  /* buff happens to be MAXDNAME long... */
-  if (!(f = fopen(fname, "r")))
-    {
-      my_syslog(LOG_ERR, _("failed to read %s: %s"), fname, strerror(errno));
-      return 0;
-    }
-   
-  mark_servers(SERV_FROM_RESOLV);
-    
-  while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
-    {
-      union mysockaddr addr, source_addr;
-      char *token = strtok(line, " \t\n\r");
-      
-      if (!token)
-	continue;
-      if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0)
-	continue;
-      if (!(token = strtok(NULL, " \t\n\r")))
-	continue;
-      
-      memset(&addr, 0, sizeof(addr));
-      memset(&source_addr, 0, sizeof(source_addr));
-      
-      if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
+       FILE *f;
+       char *line;
+       int gotone = 0;
+
+       /* XDNS - dns override servers record */
+       struct dnsoverride_record *prec = NULL;
+
+       /* buff happens to be MAXDNAME long... */
+       if (!(f = fopen(fname, "r")))
+       {
+               my_syslog(LOG_ERR, _("!!!!!! XDNS !!!!!! - failed to read %s: %s"), fname, strerror(errno));
+               return 0;
+       }
+       else
+       {
+               my_syslog(LOG_ERR, _("#############   XDNS : reload_servers()     read file :   %s    #############"), fname);
+       }
+
+       mark_servers(SERV_FROM_RESOLV);
+
+       while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
 	{
+               union mysockaddr addr, source_addr;
+               char *token = strtok(line, " \t\n\r");
+               //my_syslog(LOG_ERR, _("### XDNS ### token : \"%s\""), token);
+
+               if (!token)
+                       continue;
+               if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0 && strcmp(token, "dnsoverride") != 0)
+                       continue;
+
+               /***************** <XDNS> case dnsoverride **********************/
+               if(strcmp(token, "dnsoverride") == 0)
+               {
+                       char *macaddr = NULL, *srvaddr4 = NULL, *cpetag = NULL;
+#ifdef HAVE_IPV6
+                       char *srvaddr6 = NULL;
+#endif
+                       if(!(macaddr = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read macaddr! fetch next dnsoverride entry."));
+
+                               continue; //fetch next record if macaddr not found
+                       }
+
+                       if(!(srvaddr4 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip4 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip4 addr not found for mac
+                       }
+
+#ifdef HAVE_IPV6
+                       if(!(srvaddr6 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip6 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip6 addr not found for mac
+                       }
+#endif
+                       cpetag = strtok(NULL, " \t\n\r"); //cpetag optional. proceed even if not found.
+
+                       // process dns override token. Build dnsoverride records.
+#ifdef HAVE_IPV6
+                       create_dnsoverride_servers(&prec, macaddr, srvaddr4, srvaddr6, cpetag);
+#else
+                       create_dnsoverride_servers(&prec, macaddr, srvaddr4, NULL, cpetag);
+#endif
+                       continue;
+
+               }
+               /***************** </XDNS> ***************************************/
+
+
+               if (!(token = strtok(NULL, " \t\n\r")))
+                       continue;
+
+               memset(&addr, 0, sizeof(addr));
+               memset(&source_addr, 0, sizeof(source_addr));
+
+               if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
+               {
 #ifdef HAVE_SOCKADDR_SA_LEN
-	  source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
+                       source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
 #endif
-	  source_addr.in.sin_family = addr.in.sin_family = AF_INET;
-	  addr.in.sin_port = htons(NAMESERVER_PORT);
-	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
-	  source_addr.in.sin_port = htons(daemon->query_port);
-	}
-#ifdef HAVE_IPV6
-      else 
-	{	
-	  int scope_index = 0;
-	  char *scope_id = strchr(token, '%');
-	  
-	  if (scope_id)
-	    {
-	      *(scope_id++) = 0;
-	      scope_index = if_nametoindex(scope_id);
-	    }
-	  
-	  if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
-	    {
+                       source_addr.in.sin_family = addr.in.sin_family = AF_INET;
+                       addr.in.sin_port = htons(NAMESERVER_PORT);
+                       source_addr.in.sin_addr.s_addr = INADDR_ANY;
+                       source_addr.in.sin_port = htons(daemon->query_port);
+               }
+#ifdef HAVE_IPV6
+               else
+               {
+                       int scope_index = 0;
+                       char *scope_id = strchr(token, '%');
+
+                       if (scope_id)
+                       {
+                               *(scope_id++) = 0;
+                               scope_index = if_nametoindex(scope_id);
+                       }
+
+                       if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
+                       {
 #ifdef HAVE_SOCKADDR_SA_LEN
-	      source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
+                               source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
 #endif
-	      source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
-	      source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
-	      addr.in6.sin6_port = htons(NAMESERVER_PORT);
-	      addr.in6.sin6_scope_id = scope_index;
-	      source_addr.in6.sin6_addr = in6addr_any;
-	      source_addr.in6.sin6_port = htons(daemon->query_port);
-	      source_addr.in6.sin6_scope_id = 0;
-	    }
-	  else
-	    continue;
-	}
+                               source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
+                               source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
+                               addr.in6.sin6_port = htons(NAMESERVER_PORT);
+                               addr.in6.sin6_scope_id = scope_index;
+                               source_addr.in6.sin6_addr = in6addr_any;
+                               source_addr.in6.sin6_port = htons(daemon->query_port);
+                               source_addr.in6.sin6_scope_id = 0;
+                       }
+                       else
+                               continue;
+               }
+
 #else /* IPV6 */
-      else
-	continue;
-#endif 
-
-      add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
-      gotone = 1;
-    }
-  
-  fclose(f);
-  cleanup_servers();
+               else
+                       continue;
+#endif
+
+               add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
+               gotone = 1;
+       }
+
+       /* XDNS - Call to update the records in arp dnsoverride records*/
+       update_dnsoverride_records(prec);
 
-  return gotone;
+       fclose(f);
+       cleanup_servers();
+       return gotone;
 }
 
 /* Called when addresses are added or deleted from an interface */
diff -Naur dnsmasq-2.78.orig/src/option.c dnsmasq-2.78/src/option.c
--- dnsmasq-2.78.orig/src/option.c	2018-06-21 09:30:17.431704407 +0000
+++ dnsmasq-2.78/src/option.c	2018-06-21 09:31:48.437078847 +0000
@@ -160,6 +160,7 @@
 #define LOPT_DHCPTTL       348
 #define LOPT_TFTP_MTU      349
 #define LOPT_REPLY_DELAY   350
+#define LOPT_DNSOVERRIDE   351
  
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -201,6 +202,7 @@
     { "strict-order", 0, 0, 'o' },
     { "server", 1, 0, 'S' },
     { "rev-server", 1, 0, LOPT_REV_SERV },
+    { "dnsoverride", 2, 0, LOPT_DNSOVERRIDE },
     { "local", 1, 0, LOPT_LOCAL },
     { "address", 1, 0, 'A' },
     { "conf-file", 2, 0, 'C' },
@@ -1538,7 +1540,10 @@
     case 'C': /* --conf-file */
       {
 	char *file = opt_string_alloc(arg);
-	if (file)
+
+     //my_syslog(LOG_WARNING, _("#### XDNS #### option.c - case --conf-file: %s"), file);
+
+      if (file)
 	  {
 	    one_file(file, 0);
 	    free(file);
@@ -4186,7 +4191,9 @@
   volatile int lineno = 0;
   char *buff = daemon->namebuff;
   
-  while (fgets(buff, MAXDNAME, f))
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_file() start"));
+
+   while (fgets(buff, MAXDNAME, f))
     {
       int white, i;
       volatile int option = (hard_opt == LOPT_REV_SERV) ? 0 : hard_opt;
@@ -4316,6 +4323,8 @@
 
   mem_recover = 0;
   fclose(f);
+
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_file() end"));
 }
 
 #ifdef HAVE_DHCP
@@ -4504,6 +4513,7 @@
 void read_servers_file(void)
 {
   FILE *f;
+ // my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_servers_file(): %s"), daemon->servers_file);
 
   if (!(f = fopen(daemon->servers_file, "r")))
     {
@@ -4513,7 +4523,8 @@
   
   mark_servers(SERV_FROM_FILE);
   cleanup_servers();
-  
+
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_servers_file() calling read_file()")); 
   read_file(daemon->servers_file, f, LOPT_REV_SERV);
 }
  
