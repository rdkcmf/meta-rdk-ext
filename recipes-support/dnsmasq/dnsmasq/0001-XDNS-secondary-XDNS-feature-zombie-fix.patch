From 73c85672d2cff81a9a59bfcfe849dd61d67de73a Mon Sep 17 00:00:00 2001
From: Goutam Damodaran <Goutam_Damodaran@Comcast.com>
Date: Tue, 10 Mar 2020 06:51:27 +0000
Subject: [PATCH] XDNS & secondary XDNS feature & zombie fix
Source: COMCAST
Upstream-Status: Pending
Signed-off-by: Goutam Damodaran <Goutam_Damodaran@Comcast.com>
---
 src/arp.c     | 162 ++++++++++++++++++++++++++++
 src/dnsmasq.c |   6 ++
 src/dnsmasq.h |  28 ++++-
 src/edns0.c   | 250 +++++++++++++++++++++++++++++++++++++++++--
 src/forward.c | 165 +++++++++++++++++++++++++---
 src/network.c | 290 ++++++++++++++++++++++++++++++++++++++------------
 src/option.c  |  12 ++-
 7 files changed, 817 insertions(+), 96 deletions(-)

diff --git a/src/arp.c b/src/arp.c
index 8beaed4..20a543c 100644
--- a/src/arp.c
+++ b/src/arp.c
@@ -34,6 +34,10 @@ struct arp_record {
 
 static struct arp_record *arps = NULL, *old = NULL, *freelist = NULL;
 static time_t last = 0;
+/* <XDNS> */
+#define XDNS_NULL_MAC "00:00:00:00:00:00"
+static struct dnsoverride_record *dnsrecs = NULL;
+/* </XDNS> */
 
 static int filter_mac(int family, char *addrp, char *mac, size_t maclen, void *parmv)
 {
@@ -212,6 +216,164 @@ int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now)
    return 0;
 }
 
+/* <XDNS> - update_dnsoverride_records updates dnsoverride_record. */
+int update_dnsoverride_records(struct dnsoverride_record *precord)
+{
+       struct dnsoverride_record *tmp = dnsrecs;
+
+       //lock - no need. dnsmasq is single threaded
+       dnsrecs = precord;
+       //unlock
+
+       /* clean old records */
+       while(tmp)
+       {
+               struct dnsoverride_record *t = tmp;
+               tmp = tmp->next;
+               free(t);
+       }
+       return 1;//success
+}
+
+/* XDNS find dns record for given mac in dnsrecs. */
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr)
+{
+       if(!macaddr)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Error Param!!"), macaddr);
+               return NULL;
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s)"), macaddr);
+
+       //lock - no need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, macaddr) == 0)
+               {
+                       //found
+                       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) - found."), macaddr);
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Not found!"), macaddr);
+       }
+
+       return p;
+}
+
+/* XDNS - get default record*/
+struct dnsoverride_record* get_dnsoverride_defaultrecord()
+{
+       //lock
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, XDNS_NULL_MAC) == 0)
+               {
+                       //found
+                       my_syslog(LOG_WARNING, _("#### XDNS : found default rec"));
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_defaultrecord() Not found!"));
+       }
+
+       return p;
+}
+
+
+/* find dns server address for given mac in dnsrecs */
+int find_dnsoverride_server(char* macaddr, struct all_addr* serv, int iptype,int count)
+{
+       if(!macaddr || !serv)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param!!"));
+               return 0; //fail
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s)"), macaddr);
+
+       //lock - No need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+	       if(strcmp(p->macaddr, macaddr) == 0 && count==0)		       
+               {
+                      //found
+                       if(iptype == 4)
+                       {
+                               memcpy(serv, &p->dnsaddr4, sizeof(struct all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv4 server"));
+                       }
+#ifdef HAVE_IPV6
+                       else if(iptype == 6)
+                       {
+                               memcpy(serv, &p->dnsaddr6, sizeof(struct all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv6 server"));
+                       }
+#endif
+                       else
+                       {
+                               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param! invalid iptype: %d !"), iptype);
+                               return 0; // fail
+                       }
+
+                       return 1; //success
+
+               }
+	       if(strcmp(p->macaddr, macaddr) == 0 && count==1){      //for secondary XDNS
+			count--;
+		}
+		p = p->next;       
+       }
+       //unlock
+
+       my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s) override dns server not found!"), macaddr);
+
+       return 0; // not found
+}
+
+/* find default(primary and secondary) server address. Default is indicated by mac addr "00:00:00:00:00:00" TODO: Needs protection */
+int find_dnsoverride_defaultserver(struct all_addr* serv1,struct all_addr* serv2, int iptype,int* primary)
+{
+       int retval;	
+       if(!serv1)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_defaultserver(%x) Error Param!!"), serv1);
+	       return 0;
+       }
+
+       if(retval=find_dnsoverride_server(XDNS_NULL_MAC, serv1, iptype,0))                // For Primary Default server
+	{
+			*primary=1;
+		if(serv2)
+		{
+       			if(find_dnsoverride_server(XDNS_NULL_MAC, serv2, iptype,1))              // For secondary Default server
+				*primary=2;
+		}
+		else
+		{
+			my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_defaultserver(%x)secondary XDNS Error Param!!"), serv2);
+		}
+	}
+	
+	return retval;       
+}
+
+/* </XDNS> */
+
 int do_arp_script_run(void)
 {
   struct arp_record *arp;
diff --git a/src/dnsmasq.c b/src/dnsmasq.c
index f2eff78..cf6a77e 100644
--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -1752,6 +1752,12 @@ static void check_dns_listeners(time_t now)
 			break;
 		      }
 		}
+        /* In problem case we are seeing PARENT and CHILD processes are getting accessing the common resource
+        * That causing to Child process to die with may be SIGPIPE, which is ignored by parent causing the child
+        * proces to get into Zombie. To mitigate this problem we are introducing 100ms delay in parent process.
+        * For the actual fix, we are going to introduce proper locking mechanism for common resources. */
+	      my_syslog(LOG_INFO,"%s:%d Sleeping in parent for pid %d",__FUNCTION__,__LINE__,p);
+          usleep(100000); 	      
 	      while (retry_send(close(confd)));
 
 	      /* The child can use up to TCP_MAX_QUERIES ids, so skip that many. */
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index fe1e2d5..6722476 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -263,7 +263,10 @@ struct event_desc {
 #define OPT_TFTP_APREF_MAC 56
 #define OPT_RAPID_COMMIT   57
 #define OPT_UBUS           58
-#define OPT_LAST           59
+/* <XDNS> */
+#define OPT_DNS_OVERRIDE   59
+/* </XDNS> */
+#define OPT_LAST           60
 
 /* extra flags for my_syslog, we use a couple of facilities since they are known 
    not to occupy the same bits as priorities, no matter how syslog.h is set up. */
@@ -502,6 +505,22 @@ union mysockaddr {
 #endif
 };
 
+/* XDNS feature */
+#define REC_ADDR_MAX 32  /* Max buffer size MAC or IPv4 */
+#define REC_STR_MAX 256  /* Max string size cpetag */
+
+/* XDNS - mapping of client hwaddr to upstream dns servers */
+struct dnsoverride_record {
+  unsigned char macaddr[REC_ADDR_MAX];
+  char cpetag[REC_STR_MAX];
+  struct all_addr dnsaddr4;
+#ifdef HAVE_IPV6
+  struct all_addr dnsaddr6;
+#endif
+  //int family;
+  struct dnsoverride_record *next;
+};
+
 /* bits in flag param to IPv6 callbacks from iface_enumerate() */
 #define IFACE_TENTATIVE   1
 #define IFACE_DEPRECATED  2
@@ -1020,6 +1039,8 @@ extern struct daemon {
   struct bogus_addr *bogus_addr, *ignore_addr;
   struct server *servers;
   struct ipsets *ipsets;
+  struct server *dns_override_server; /* for XDNS */
+  struct server *dns_override_server2; /* for Secondary XDNS */
   int log_fac; /* log facility */
   char *log_file; /* optional log file */
   int max_logs;  /* queue limit */
@@ -1643,6 +1664,11 @@ int check_source(struct dns_header *header, size_t plen, unsigned char *pseudohe
 
 /* arp.c */
 int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now);
+int update_dnsoverride_records(struct dnsoverride_record *precord);
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr);
+struct dnsoverride_record* get_dnsoverride_defaultrecord();
+int find_dnsoverride_server(char* macaddr, struct all_addr* serv, int iptype,int count);
+int find_dnsoverride_defaultserver(struct all_addr* serv1,struct all_addr* serv2, int iptype,int* primary);
 int do_arp_script_run(void);
 
 /* dump.c */
diff --git a/src/edns0.c b/src/edns0.c
index af33877..f95fb69 100644
--- a/src/edns0.c
+++ b/src/edns0.c
@@ -15,6 +15,7 @@
 */
 
 #include "dnsmasq.h"
+#define XDNS_NULL_MAC "00:00:00:00:00:00"
 
 unsigned char *find_pseudoheader(struct dns_header *header, size_t plen, size_t  *len, unsigned char **p, int *is_sign, int *is_last)
 {
@@ -264,6 +265,54 @@ static void encoder(unsigned char *in, char *out)
   out[3] = char64(in[2]);
 }
 
+/* XDNS - Add cpe tag for XDNS if found */
+static size_t add_cpe_tag(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       unsigned char mac[DHCP_CHADDR_MAX] = {0};
+       int maclen = 0;
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+
+       struct dnsoverride_record* dnsrec = NULL;
+       unsigned char* cpetag = NULL;
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+               print_mac(strmac, mac, maclen);
+
+               dnsrec = get_dnsoverride_record(strmac);
+               if(!dnsrec)
+                       dnsrec = get_dnsoverride_defaultrecord();
+
+               if(dnsrec && dnsrec->cpetag[0])
+               {
+                       //my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() - found cpetag: %s"), dnsrec->cpetag);
+                       cpetag = dnsrec->cpetag;
+               }
+               else
+               {
+                       my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() Could not find cpetag for mac %s"), strmac);
+               }
+       }
+
+       //if cpetag not found try to use the one from dnsmasq options
+       if(cpetag == NULL)
+       {
+               cpetag = (unsigned char *)daemon->dns_client_id;
+       }
+
+       // if no cpetag found return. Don't call add header.
+       if(cpetag == NULL)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : no cpetag found in dnsmasq config"));
+               return plen;
+       }
+
+       my_syslog(LOG_WARNING, _("### XDNS - add cpe tag \'%s\' to edns0 header for mac [%s]"), cpetag, strmac);
+       return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, cpetag, strlen(cpetag), 0, 1);
+}
+//</XDNS>
+
 static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
 {
   int maclen, replace = 2; /* can't get mac address, just delete any incoming. */
@@ -287,16 +336,191 @@ static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned ch
   return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMDEVICEID, (unsigned char *)encode, strlen(encode), 0, replace); 
 }
 
+// XDNS
+void set_option_dnsoverride()
+{
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options |= 1u << OPT_DNS_OVERRIDE;
+  else
+    daemon->options2 |= 1u << (OPT_DNS_OVERRIDE - 32);
+}
 
-static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+// XDNS
+void reset_option_dnsoverride()
 {
-  int maclen;
-  unsigned char mac[DHCP_CHADDR_MAX];
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options &= ~(1u << OPT_DNS_OVERRIDE);
+  else
+    daemon->options2 &= ~(1u << (OPT_DNS_OVERRIDE - 32));
+}
 
+// XDNS
+static size_t add_xdns_server(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+  int maclen = 0;
+  unsigned char mac[DHCP_CHADDR_MAX];
+	// find mac from socket addr
   if ((maclen = find_mac(l3, mac, 1, now)) != 0)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0); 
-    
-  return plen; 
+  {
+       // get mac in string format
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+       print_mac(strmac, mac, maclen);
+
+               my_syslog(LOG_INFO, _("### XDNS - add_xdns_server() for mac [%s]"), strmac);
+
+               // find family type from socket addr
+               int iptype = 4;
+               if(l3->sa.sa_family == AF_INET)
+               {
+                       iptype = 4;
+               }
+#ifdef HAVE_IPV6
+              else if(l3->sa.sa_family == AF_INET6)
+               {
+                       iptype = 6;
+               }
+#endif
+
+               // get appropriate ipv4 or ipv6 dnsoverride address using mac addr
+               struct all_addr dnsaddr;
+	       struct all_addr secondarydnsaddr;
+       	       int primary=0;	       
+               memset(&dnsaddr, 0, sizeof(struct all_addr));
+	       memset(&secondarydnsaddr, 0, sizeof(struct all_addr));	
+
+               // if xdns addr for same iptype, if not found try for other iptype
+               // then try the default.
+	       if(!find_dnsoverride_server(strmac, &dnsaddr, iptype,0))		       
+               {
+                      if(find_dnsoverride_server(strmac, &dnsaddr, (iptype==4)?6:4,0))//try other type
+                      {		       
+                             iptype = (iptype==4)?6:4;
+                      }
+		      else if(!find_dnsoverride_defaultserver(&dnsaddr,&secondarydnsaddr,iptype,&primary))
+                      {
+			    if(find_dnsoverride_defaultserver(&dnsaddr,&secondarydnsaddr, (iptype==4)?6:4,&primary))//try other type		    
+                            {
+                                   iptype = (iptype==4)?6:4;
+                            }
+                            else
+                            {
+                                   my_syslog(LOG_WARNING, _("#### XDNS : add_xdns_server() Could't find xdns server for [%s] or the default server!"), strmac);
+                                   reset_option_dnsoverride();
+                                   return plen;
+                            }
+                      }
+               }
+               //else found xdns server to use.
+		if(primary==2)      // For secondary XDNS server
+		{
+		
+			struct server *secondserv = NULL;
+			char string[64]={0};
+               		secondserv = daemon->dns_override_server2;
+               		if(!secondserv) // if first time, daemon->dns_override_server2 is NULL. Allocate
+               		{
+                      		secondserv = whine_malloc(sizeof (struct server)); //allocated once & reused. Not freed.
+                      		if(secondserv)
+                      		{
+                            		memset(secondserv, 0, sizeof(struct server));
+                     		}
+                      		daemon->dns_override_server2 = secondserv;
+             		}
+
+               		if(secondserv)
+               		{
+                       		if(iptype == 4)
+                       		{
+                               		my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv4 dns_override_server entry in daemon"));
+                              		//serv->addr.in.sin_addr = secondarydnsaddr.addr.addr4;
+                              		memcpy(&secondserv->addr.in.sin_addr, &secondarydnsaddr.addr.addr4, sizeof(struct in_addr));
+                               		secondserv->addr.sa.sa_family = AF_INET;
+					inet_ntop(AF_INET, &(secondarydnsaddr.addr.addr4), string, 64);
+					my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv4 dns_override_server string:%s!"),string);
+                     		}
+#ifdef HAVE_IPV6
+                       		else if(iptype == 6)
+                       		{
+                               		my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv6 dns_override_server entry in daemon"));
+                               		//serv->addr.in6.sin6_addr = secondarydnsaddr.addr.addr6;
+                               		memcpy(&secondserv->addr.in6.sin6_addr, &secondarydnsaddr.addr.addr6, sizeof(struct in6_addr));
+                               		secondserv->addr.sa.sa_family = AF_INET6;
+                                        inet_ntop(AF_INET6, &(secondarydnsaddr.addr.addr6), string, 64);
+                                        my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv6 dns_override_server string:%s!"),string);
+                       		}
+#endif
+               	 		}
+   		 	}
+			else
+			{
+				daemon->dns_override_server2=NULL;
+				my_syslog(LOG_WARNING, _("### XDNS - secondary XDNS server does not exist!"));
+			
+			}
+
+		
+
+	
+	       struct server *serv = NULL;
+               serv = daemon->dns_override_server;
+               if(!serv) // if first time, daemon->dns_override_server is NULL. Allocate
+               {
+                      serv = whine_malloc(sizeof (struct server)); //allocated once & reused. Not freed.
+                      if(serv)
+                      {
+                            memset(serv, 0, sizeof(struct server));
+                      }
+                      daemon->dns_override_server = serv;
+               }
+
+               if(serv)
+               {
+                       if(iptype == 4)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv4 dns_override_server entry in daemon"));
+                              //serv->addr.in.sin_addr = dnsaddr.addr.addr4;
+                               memcpy(&serv->addr.in.sin_addr, &dnsaddr.addr.addr4, sizeof(struct in_addr));
+                               serv->addr.sa.sa_family = AF_INET;
+                       }
+#ifdef HAVE_IPV6
+                       else if(iptype == 6)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv6 dns_override_server entry in daemon"));
+                               //serv->addr.in6.sin6_addr = dnsaddr.addr.addr6;
+                               memcpy(&serv->addr.in6.sin6_addr, &dnsaddr.addr.addr6, sizeof(struct in6_addr));
+                               serv->addr.sa.sa_family = AF_INET6;
+                       }
+#endif
+                   // Trigger overriding of upstream server
+                   set_option_dnsoverride();
+                }
+    }
+	else
+	{
+		reset_option_dnsoverride();
+		my_syslog(LOG_WARNING, _("#### XDNS : could not find MAC from l3 sockaddr !"));
+	}
+
+       return plen;
+}
+
+static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       my_syslog(LOG_WARNING, _("#### XDNS : add_mac() called"));
+       int maclen = 0;
+       unsigned char mac[DHCP_CHADDR_MAX];
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+          plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0);
+       }
+       else
+       {
+       	my_syslog(LOG_WARNING, _("#### XDNS : add_mac() maclen = 0 !!"));
+       	reset_option_dnsoverride();
+       }  
+	  return plen; 
 }
 
 struct subnet_opt {
@@ -435,10 +659,16 @@ size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *l
   if (option_bool(OPT_MAC_B64) || option_bool(OPT_MAC_HEX))
     plen = add_dns_client(header, plen, limit, source, now);
 
-  if (daemon->dns_client_id)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, 
-			    (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
-  
+  /* <XDNS> */
+  plen = add_xdns_server(header, plen, limit, source, now);
+
+  //if (daemon->dns_client_id)
+  //  plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID,
+  //               (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
+  plen = add_cpe_tag(header, plen, limit, source, now);
+
+  /* </XDNS> */
+   
   if (option_bool(OPT_CLIENT_SUBNET))
     {
       plen = add_source_addr(header, plen, limit, source); 
diff --git a/src/forward.c b/src/forward.c
index 3dd8633..aff6f74 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -260,6 +260,7 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
   struct all_addr *addrp = NULL;
   unsigned int flags = 0;
   struct server *start = NULL;
+  struct server *secondstart = NULL;
 #ifdef HAVE_DNSSEC
   void *hash = hash_questions(header, plen, daemon->namebuff);
   int do_dnssec = 0;
@@ -457,7 +458,7 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 	  if (forward->flags & FREC_TEST_PKTSZ)
 	    PUTSHORT(SAFE_PKTSZ, pheader);
 	}
-      
+      int primaryxdns=0;
       while (1)
 	{ 
 	  /* only send to servers dealing with our domain.
@@ -469,10 +470,56 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 	    {
 	      int fd;
+// < XDNS for IPv6>
+                 if(option_bool(OPT_DNS_OVERRIDE) && daemon->dns_override_server)
+                 {
+                                 my_syslog(LOG_INFO, _("#### XDNS - finding server socket to use based on dns_override_server family "));
+       #ifdef HAVE_IPV6
+                                 if (daemon->dns_override_server->addr.sa.sa_family == AF_INET6)
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET6 family"));
+                                         if (!forward->rfd6 &&
+                                                         !(forward->rfd6 = allocate_rfd(AF_INET6)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd6;
+                                         fd = forward->rfd6->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP6 fd to use: %d "), fd);
+                                 }
+                                 else
+       #endif
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET family"));
+                                         if (!forward->rfd4 &&
+                                                         !(forward->rfd4 = allocate_rfd(AF_INET)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd4;
+                                         fd = forward->rfd4->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP4 fd to use: %d "), fd);
+                                 }
+
+       #ifdef HAVE_CONNTRACK
+                                 /* Copy connection mark of incoming query to outgoing connection. */
+                                 if (option_bool(OPT_CONNTRACK))
+                                 {
+                                         unsigned int mark;
+                                         if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
+                                                 setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                                 }
+       #endif
+
+                 }
+//</ XDNS for IPv6>
+
+                 else
+                 {
+                         //my_syslog(LOG_INFO, _("#### XDNS - OPT_DNS_OVERRIDE not set or dns_override_server empty. finding fd regular way "));
 
 	      /* find server socket to use, may need to get random one. */
 	      if (start->sfd)
+		{		      
 		fd = start->sfd->fd;
+		my_syslog(LOG_INFO, _("#### XDNS - found server socket to use: %d "), start->sfd->fd);
+		}
 	      else 
 		{
 #ifdef HAVE_IPV6
@@ -520,13 +567,103 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 		    PUTSHORT(start->edns_pktsz, pheader);
 		}
 #endif
+                 //<XDNS>
+                       //=====
+                 //my_syslog(LOG_INFO, _("#### XDNS - List of nameservers: "));
+                        struct server *indx;
+                for (indx = daemon->servers; indx; indx = indx->next)
+                {
+                         char strprn[64] = {0}; memset(strprn, 0, 64);
+                         if(indx->addr.sa.sa_family == AF_INET)
+                         {
+                                 inet_ntop(AF_INET, &(indx->addr.in.sin_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in.sin_port, indx->addr.in.sin_family);
+
+                        }
+                         else if(indx->addr.sa.sa_family == AF_INET6)
+                         {
+                                 inet_ntop(AF_INET6, &(indx->addr.in6.sin6_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in6.sin6_port, indx->addr.in6.sin6_family);
+                         }
+                 }
+
+                struct server *xdnsserver;
+                if(!primaryxdns)
+                {
+                        xdnsserver=daemon->dns_override_server;
+                }
+                else
+                {
+                        xdnsserver=daemon->dns_override_server2;
+                }
+
+			if(option_bool(OPT_DNS_OVERRIDE) && xdnsserver)				
+			{
+			  char strprn[64] = {0};
+			  if(xdnsserver->addr.sa.sa_family == AF_INET)				  
+			  {
+				  memset(strprn, 0, 64);
+				  if(inet_ntop(AF_INET, &(xdnsserver->addr.in.sin_addr), strprn, 64))					  
+				  {
+					  if(strprn[0] != 0 && strcmp(strprn, "0.0.0.0") != 0)
+					  {
+						  memcpy(&start->addr.in.sin_addr, &xdnsserver->addr.in.sin_addr, sizeof(struct in_addr));						  
+						  start->addr.in.sin_family = AF_INET;
+			   			  //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv4 xDNS addr"));
+					  }
+				  }
+			  }
+		          else if(xdnsserver->addr.sa.sa_family == AF_INET6)				  
+			  {
+				  memset(strprn, 0, 64);
+				  if(inet_ntop(AF_INET6, &(xdnsserver->addr.in6.sin6_addr), strprn, 64))				  
+				  {
+					  if(strprn[0] != 0 && strcmp(strprn, "::") != 0)
+					  {
+				  		  memcpy(&start->addr.in6.sin6_addr, &xdnsserver->addr.in6.sin6_addr, sizeof(struct in6_addr));						  
+				  		  start->addr.in6.sin6_family = AF_INET6;
+			   			  //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv6 xDNS addr"));
+					  }
+				  }
+			  }
+			  else
+			  {
+				  my_syslog(LOG_WARNING, _("#### XDNS - dns_override_server family error!!"));
+			  }
+			}
+			else
+			{
+			  //my_syslog(LOG_WARNING, _("#### XDNS - Did not modify upstream addr!"));
+			}
 
-	      if (retry_send(sendto(fd, (char *)header, plen, 0,
-				    &start->addr.sa,
-				    sa_len(&start->addr))))
-		continue;
-	    
-	      if (errno == 0)
+                 // Print where udp send is sending to:
+                 char strprn[64] = {0}; memset(strprn, 0, 64);
+                 if(start->addr.sa.sa_family == AF_INET)
+                         inet_ntop(AF_INET, &(start->addr.in.sin_addr), strprn, 64);
+                 else if(start->addr.sa.sa_family == AF_INET6)
+                         inet_ntop(AF_INET6, &(start->addr.in6.sin6_addr), strprn, 64);
+
+			  my_syslog(LOG_INFO, _("#### XDNS - sendto (%u, 0x%x, len = %d) to %s : %s)"),
+				  fd,
+				  (int)&start->addr.sa,
+				  sa_len(&start->addr),
+				  (start->addr.sa.sa_family == AF_INET6)?"ipv6":"ipv4", strprn);
+
+                 //=====
+                 // </XDNS>
+
+                 if (retry_send(
+                         sendto(fd,
+                                 (char *)header, plen, 0,
+                                 (const struct sockaddr *)&start->addr.sa,
+                                 (socklen_t)sa_len(&start->addr))))
+             {
+                 my_syslog(LOG_WARNING, _("#### XDNS : retry_send() retry..."));
+                 continue;
+             }
+    
+
+		if (errno == 0) //succeeded      
 		{
 #ifdef HAVE_DUMPFILE
 		  dump_packet(DUMP_UP_QUERY, (void *)header, plen, NULL, &start->addr);
@@ -553,15 +690,18 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 		    break;
 		  forward->forwardall++;
 		}
-	    } 
-	  
+		else
+		{
+		         my_syslog(LOG_WARNING, _("#### XDNS : sendto() failed!"));
+		}
+	}	  
 	  if (!(start = start->next))
  	    start = daemon->servers;
 	  
 	  if (start == firstsentto)
 	    break;
-	}
-      
+	  }
+	}  
       if (forwarded)
 	return 1;
       
@@ -581,8 +721,7 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 
   return 0;
 }
-
-static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
+size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
 			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader, 
 			    int check_subnet, union mysockaddr *query_source)
 {
diff --git a/src/network.c b/src/network.c
index 8ae7a70..cc2307d 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1616,89 +1616,243 @@ void check_servers(void)
   cleanup_servers();
 }
 
+/*XDNS- prints the linked list containg Primary and secondary DNS servers*/
+void print_dnsoverride_servers(struct dnsoverride_record *pprec)
+{
+
+        struct dnsoverride_record* p= pprec;
+	int i=0;
+        while(p != NULL)
+        {
+		char ipv4add[64] = {0};
+		char ipv6add[64] = {0};
+		inet_ntop(AF_INET, &(p->dnsaddr4.addr.addr4), ipv4add, 64);
+		inet_ntop(AF_INET6, &(p->dnsaddr6.addr.addr6), ipv6add, 64);
+       		my_syslog(LOG_ERR, _("### XDNS # macaddr[%d] : \"%s\""), i, p->macaddr);
+       		my_syslog(LOG_ERR, _("### XDNS # srvaddr4[%d] : \"%s\""), i, ipv4add);
+#ifdef HAVE_IPV6
+       		my_syslog(LOG_ERR, _("### XDNS # srvaddr6[%d] : \"%s\""), i, ipv6add);
+#endif
+
+     		my_syslog(LOG_ERR, _("### XDNS # cpetag[%d] : \"%s\""), i, p->cpetag);
+                p=p->next;
+		i++;
+
+        }
+
+}
+
+/* XDNS - Helper to create override server entries in record. Builds pprec list and returns the head. */
+static int create_dnsoverride_servers(struct dnsoverride_record **pprec, char* macaddr, char *srvaddr4, char *srvaddr6, char *cpetag)
+{
+       if(!macaddr || !srvaddr4) //MAC and Serv addr are must. cpetag is optional
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - mandatory fields (macaddr or ipv4addr) missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+#ifdef HAVE_IPV6
+       if(srvaddr6 == NULL)
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - ipv6 addr missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+
+#endif
+
+
+       my_syslog(LOG_ERR, _("### XDNS # macaddr : \"%s\""), macaddr);
+      my_syslog(LOG_ERR, _("### XDNS # srvaddr4 : \"%s\""), srvaddr4);
+#ifdef HAVE_IPV6
+       my_syslog(LOG_ERR, _("### XDNS # srvaddr6 : \"%s\""), srvaddr6);
+#endif
+
+       my_syslog(LOG_ERR, _("### XDNS # cpetag  : \"%s\""), cpetag);
+
+       //create entry and attach to record. This entries are maintained in arp.c. Cleanup is done there.
+       struct dnsoverride_record* entry = NULL;
+       struct dnsoverride_record* temp = NULL;
+       if ((entry = whine_malloc(sizeof(struct dnsoverride_record))))
+       {
+               memset(entry, 0, sizeof(struct dnsoverride_record));
+
+               if(strlen(macaddr) < REC_ADDR_MAX)
+               {
+                       strcpy(entry->macaddr, macaddr);
+               }
+
+               if (inet_pton(AF_INET, srvaddr4, &entry->dnsaddr4.addr.addr4) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IP4 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+#ifdef HAVE_IPV6
+               if (inet_pton(AF_INET6, srvaddr6, &entry->dnsaddr6.addr.addr6) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IPv6 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+#endif
+               if(cpetag && strlen(cpetag) < REC_STR_MAX)
+               {
+                       strcpy(entry->cpetag, cpetag);
+               }
+
+  
+               entry->next = NULL;
+               if(*pprec == NULL)
+		{
+			*pprec = entry;
+		}
+		else
+		{
+		       (*pprec)->next = (struct dnsoverride_record*)entry;	
+		}
+       }
+       return 1; //success
+}
+
+
 /* Return zero if no servers found, in that case we keep polling.
    This is a protection against an update-time/write race on resolv.conf */
 int reload_servers(char *fname)
 {
-  FILE *f;
-  char *line;
-  int gotone = 0;
+       FILE *f;
+       char *line;
+       int gotone = 0;
 
-  /* buff happens to be MAXDNAME long... */
-  if (!(f = fopen(fname, "r")))
-    {
-      my_syslog(LOG_ERR, _("failed to read %s: %s"), fname, strerror(errno));
-      return 0;
-    }
-   
-  mark_servers(SERV_FROM_RESOLV);
-    
-  while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
-    {
-      union mysockaddr addr, source_addr;
-      char *token = strtok(line, " \t\n\r");
-      
-      if (!token)
-	continue;
-      if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0)
-	continue;
-      if (!(token = strtok(NULL, " \t\n\r")))
-	continue;
-      
-      memset(&addr, 0, sizeof(addr));
-      memset(&source_addr, 0, sizeof(source_addr));
-      
-      if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
-	{
+       /* XDNS - dns override servers record */
+       struct dnsoverride_record *prec = NULL;
+
+       /* buff happens to be MAXDNAME long... */
+       if (!(f = fopen(fname, "r")))
+       {
+               my_syslog(LOG_ERR, _("!!!!!! XDNS !!!!!! - failed to read %s: %s"), fname, strerror(errno));
+               return 0;
+       }
+       else
+       {
+               my_syslog(LOG_ERR, _("#############   XDNS : reload_servers()     read file :   %s    #############"), fname);
+       }
+
+       mark_servers(SERV_FROM_RESOLV);
+
+       while ((line = fgets(daemon->namebuff, MAXDNAME, f)))	
+       {
+               union mysockaddr addr, source_addr;
+               char *token = strtok(line, " \t\n\r");
+               //my_syslog(LOG_ERR, _("### XDNS ### token : \"%s\""), token);
+
+               if (!token)
+                       continue;
+               if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0 && strcmp(token, "dnsoverride") != 0)
+                       continue;
+
+               /***************** <XDNS> case dnsoverride **********************/
+               if(strcmp(token, "dnsoverride") == 0)
+               {
+                       char *macaddr = NULL, *srvaddr4 = NULL, *cpetag = NULL;
+#ifdef HAVE_IPV6
+                       char *srvaddr6 = NULL;
+#endif
+                       if(!(macaddr = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read macaddr! fetch next dnsoverride entry."));
+
+                               continue; //fetch next record if macaddr not found
+                       }
+
+                       if(!(srvaddr4 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip4 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip4 addr not found for mac
+                       }
+
+#ifdef HAVE_IPV6
+                       if(!(srvaddr6 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip6 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip6 addr not found for mac
+                       }
+#endif
+                       cpetag = strtok(NULL, " \t\n\r"); //cpetag optional. proceed even if not found.
+
+                       // process dns override token. Build dnsoverride records.
+#ifdef HAVE_IPV6
+                       create_dnsoverride_servers(&prec, macaddr, srvaddr4, srvaddr6, cpetag);
+#else
+                       create_dnsoverride_servers(&prec, macaddr, srvaddr4, NULL, cpetag);
+#endif
+                       continue;
+
+               }
+               /***************** </XDNS> ***************************************/
+
+
+               if (!(token = strtok(NULL, " \t\n\r")))
+                       continue;
+
+               memset(&addr, 0, sizeof(addr));
+               memset(&source_addr, 0, sizeof(source_addr));
+
+               if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
+               {
 #ifdef HAVE_SOCKADDR_SA_LEN
 	  source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
 #endif
-	  source_addr.in.sin_family = addr.in.sin_family = AF_INET;
-	  addr.in.sin_port = htons(NAMESERVER_PORT);
-	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
-	  source_addr.in.sin_port = htons(daemon->query_port);
-	}
+                       source_addr.in.sin_family = addr.in.sin_family = AF_INET;
+                       addr.in.sin_port = htons(NAMESERVER_PORT);
+                       source_addr.in.sin_addr.s_addr = INADDR_ANY;
+                       source_addr.in.sin_port = htons(daemon->query_port);
+               }
 #ifdef HAVE_IPV6
-      else 
-	{	
-	  int scope_index = 0;
-	  char *scope_id = strchr(token, '%');
-	  
-	  if (scope_id)
-	    {
-	      *(scope_id++) = 0;
-	      scope_index = if_nametoindex(scope_id);
-	    }
-	  
-	  if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
-	    {
+               else
+               {
+                       int scope_index = 0;
+                       char *scope_id = strchr(token, '%');
+
+                       if (scope_id)
+                       {
+                               *(scope_id++) = 0;
+                               scope_index = if_nametoindex(scope_id);
+                       }
+
+                       if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
+                       {
 #ifdef HAVE_SOCKADDR_SA_LEN
 	      source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
 #endif
-	      source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
-	      source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
-	      addr.in6.sin6_port = htons(NAMESERVER_PORT);
-	      addr.in6.sin6_scope_id = scope_index;
-	      source_addr.in6.sin6_addr = in6addr_any;
-	      source_addr.in6.sin6_port = htons(daemon->query_port);
-	      source_addr.in6.sin6_scope_id = 0;
-	    }
-	  else
-	    continue;
-	}
+                               source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
+                               source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
+                               addr.in6.sin6_port = htons(NAMESERVER_PORT);
+                               addr.in6.sin6_scope_id = scope_index;
+                               source_addr.in6.sin6_addr = in6addr_any;
+                               source_addr.in6.sin6_port = htons(daemon->query_port);
+                               source_addr.in6.sin6_scope_id = 0;
+                       }
+                       else
+                               continue;
+               }
+
 #else /* IPV6 */
-      else
-	continue;
-#endif 
+               else
+                       continue;
+#endif
 
-      add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
-      gotone = 1;
-    }
-  
-  fclose(f);
-  cleanup_servers();
+               add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
+               gotone = 1;
+       }
 
-  return gotone;
+       /* XDNS - Call to update the records in arp dnsoverride records*/
+       print_dnsoverride_servers(prec);
+       update_dnsoverride_records(prec);
+ 
+       fclose(f);
+       cleanup_servers();
+       return gotone;
 }
 
 /* Called when addresses are added or deleted from an interface */
diff --git a/src/option.c b/src/option.c
index 44b1dc5..b9a5932 100644
--- a/src/option.c
+++ b/src/option.c
@@ -166,7 +166,8 @@ struct myoption {
 #define LOPT_UBUS          354
 #define LOPT_NAME_MATCH    355
 #define LOPT_CAA           356
- 
+#define LOPT_DNSOVERRIDE   357
+
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
 #else
@@ -207,6 +208,7 @@ static const struct myoption opts[] =
     { "strict-order", 0, 0, 'o' },
     { "server", 1, 0, 'S' },
     { "rev-server", 1, 0, LOPT_REV_SERV },
+    { "dnsoverride", 2, 0, LOPT_DNSOVERRIDE },
     { "local", 1, 0, LOPT_LOCAL },
     { "address", 1, 0, 'A' },
     { "conf-file", 2, 0, 'C' },
@@ -1556,6 +1558,7 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
     case 'C': /* --conf-file */
       {
 	char *file = opt_string_alloc(arg);
+	//my_syslog(LOG_WARNING, _("#### XDNS #### option.c - case --conf-file: %s"), file);
 	if (file)
 	  {
 	    one_file(file, 0);
@@ -4276,7 +4279,7 @@ static void read_file(char *file, FILE *f, int hard_opt)
 {
   volatile int lineno = 0;
   char *buff = daemon->namebuff;
-  
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_file() start"));  
   while (fgets(buff, MAXDNAME, f))
     {
       int white, i;
@@ -4407,6 +4410,7 @@ static void read_file(char *file, FILE *f, int hard_opt)
 
   mem_recover = 0;
   fclose(f);
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_file() end"));
 }
 
 #if defined(HAVE_DHCP) && defined(HAVE_INOTIFY)
@@ -4595,7 +4599,7 @@ struct hostsfile *expand_filelist(struct hostsfile *list)
 void read_servers_file(void)
 {
   FILE *f;
-
+  my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_servers_file(): %s"), daemon->servers_file);
   if (!(f = fopen(daemon->servers_file, "r")))
     {
        my_syslog(LOG_ERR, _("cannot read %s: %s"), daemon->servers_file, strerror(errno));
@@ -4604,7 +4608,7 @@ void read_servers_file(void)
   
   mark_servers(SERV_FROM_FILE);
   cleanup_servers();
-  
+  //my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_servers_file() calling read_file()"));
   read_file(daemon->servers_file, f, LOPT_REV_SERV);
 }
  
