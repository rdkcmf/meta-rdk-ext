From 2f6ed2de3c6248607e3b476d3b0ad9f32a07e8ad Mon Sep 17 00:00:00 2001
From: Jaga <jagadheesan_duraisamy@comcast.com>
Date: Fri, 14 Aug 2020 19:12:30 +0000
Subject: [PATCH] dnsmasq-2.81-XDNS-secondary-XDNS-feature-zombie-fix

---
 src/arp.c     | 163 +++++++++++++++++++++++++++++++++
 src/dnsmasq.h |  26 +++++-
 src/edns0.c   | 242 ++++++++++++++++++++++++++++++++++++++++++++++--
 src/forward.c | 155 +++++++++++++++++++++++++++++--
 src/network.c | 248 +++++++++++++++++++++++++++++++++++++++-----------
 src/option.c  |   5 +-
 6 files changed, 767 insertions(+), 72 deletions(-)

diff --git a/src/arp.c b/src/arp.c
index 3329d6d..550dc84 100644
--- a/src/arp.c
+++ b/src/arp.c
@@ -35,6 +35,11 @@ struct arp_record {
 static struct arp_record *arps = NULL, *old = NULL, *freelist = NULL;
 static time_t last = 0;
 
+/* <XDNS> */
+#define XDNS_NULL_MAC "00:00:00:00:00:00"
+static struct dnsoverride_record *dnsrecs = NULL;
+/* </XDNS> */
+
 static int filter_mac(int family, char *addrp, char *mac, size_t maclen, void *parmv)
 {
   struct arp_record *arp;
@@ -199,6 +204,164 @@ int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now)
    return 0;
 }
 
+/* <XDNS> - update_dnsoverride_records updates dnsoverride_record. */
+int update_dnsoverride_records(struct dnsoverride_record *precord)
+{
+       struct dnsoverride_record *tmp = dnsrecs;
+
+       //lock - no need. dnsmasq is single threaded
+       dnsrecs = precord;
+       //unlock
+
+       /* clean old records */
+       while(tmp)
+       {
+               struct dnsoverride_record *t = tmp;
+               tmp = tmp->next;
+               free(t);
+       }
+       return 1;//success
+}
+
+/* XDNS find dns record for given mac in dnsrecs. */
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr)
+{
+       if(!macaddr)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Error Param!!"), macaddr);
+               return NULL;
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s)"), macaddr);
+
+       //lock - no need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, macaddr) == 0)
+               {
+                       //found
+                       //my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) - found."), macaddr);
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_record(%s) Not found!"), macaddr);
+       }
+
+       return p;
+}
+
+/* XDNS - get default record*/
+struct dnsoverride_record* get_dnsoverride_defaultrecord()
+{
+       //lock
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+               if(strcmp(p->macaddr, XDNS_NULL_MAC) == 0)
+               {
+                       //found
+                       my_syslog(LOG_WARNING, _("#### XDNS : found default rec"));
+                       break;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       if(!p)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : get_dnsoverride_defaultrecord() Not found!"));
+       }
+
+       return p;
+}
+
+
+/* find dns server address for given mac in dnsrecs */
+int find_dnsoverride_server(char* macaddr, union all_addr* serv, int iptype,int count)
+{
+       if(!macaddr || !serv)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param!!"));
+               return 0; //fail
+       }
+
+       //my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s)"), macaddr);
+
+       //lock - No need. dnsmasq is single threaded
+       struct dnsoverride_record *p = dnsrecs;
+       while(p)
+       {
+              if(strcmp(p->macaddr, macaddr) == 0 && count==0)
+               {
+                      //found
+                       if(iptype == 4)
+                       {
+                               memcpy(serv, &p->dnsaddr4, sizeof(union all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv4 server"));
+                       }
+                       else if(iptype == 6)
+                       {
+                               memcpy(serv, &p->dnsaddr6, sizeof(union all_addr));
+                               my_syslog(LOG_WARNING, _("#### XDNS : found ipv6 server"));
+                       }
+                       else
+                       {
+                               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server() Error Param! invalid iptype: %d !"), iptype);
+                               return 0; // fail
+                       }
+
+                       return 1; //success
+
+               }
+              if(strcmp(p->macaddr, macaddr) == 0 && count==1){      //for secondary XDNS
+                       count--;
+               }
+               p = p->next;
+       }
+       //unlock
+
+       my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_server(%s) override dns server not found!"), macaddr);
+
+       return 0; // not found
+}
+
+/* find default(primary and secondary) server address. Default is indicated by mac addr "00:00:00:00:00:00" TODO: Needs protection */
+int find_dnsoverride_defaultserver(union all_addr* serv1,union all_addr* serv2, int iptype,int* primary)
+{
+       int retval;
+       if(!serv1)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_defaultserver(%x) Error Param!!"), serv1);
+              return 0;
+       }
+
+       if(retval=find_dnsoverride_server(XDNS_NULL_MAC, serv1, iptype,0))                // For Primary Default server
+       {
+                       *primary=1;
+               if(serv2)
+               {
+                               if(find_dnsoverride_server(XDNS_NULL_MAC, serv2, iptype,1))              // For secondary Default server
+                               *primary=2;
+               }
+               else
+               {
+                       my_syslog(LOG_WARNING, _("#### XDNS : find_dnsoverride_defaultserver(%x)secondary XDNS Error Param!!"), serv2);
+               }
+       }
+
+       return retval;
+}
+
+
+/* </XDNS> */
+
+
 int do_arp_script_run(void)
 {
   struct arp_record *arp;
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index 1c27a3d..a95b757 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -269,7 +269,10 @@ struct event_desc {
 #define OPT_IGNORE_CLID    59
 #define OPT_SINGLE_PORT    60
 #define OPT_LEASE_RENEW    61
-#define OPT_LAST           62
+/* <XDNS> */
+#define OPT_DNS_OVERRIDE   62
+/* </XDNS> */
+#define OPT_LAST           63
 
 #define OPTION_BITS (sizeof(unsigned int)*8)
 #define OPTION_SIZE ( (OPT_LAST/OPTION_BITS)+((OPT_LAST%OPTION_BITS)!=0) )
@@ -506,6 +509,20 @@ union mysockaddr {
   struct sockaddr_in6 in6;
 };
 
+/* XDNS feature */
+#define REC_ADDR_MAX 32  /* Max buffer size MAC or IPv4 */
+#define REC_STR_MAX 256  /* Max string size cpetag */
+
+/* XDNS - mapping of client hwaddr to upstream dns servers */
+struct dnsoverride_record {
+  unsigned char macaddr[REC_ADDR_MAX];
+  char cpetag[REC_STR_MAX];
+  union all_addr dnsaddr4;
+  union all_addr dnsaddr6;
+  //int family;
+  struct dnsoverride_record *next;
+};
+
 /* bits in flag param to IPv6 callbacks from iface_enumerate() */
 #define IFACE_TENTATIVE   1
 #define IFACE_DEPRECATED  2
@@ -1026,6 +1043,8 @@ extern struct daemon {
   struct bogus_addr *bogus_addr, *ignore_addr;
   struct server *servers;
   struct ipsets *ipsets;
+  struct server *dns_override_server; /* for XDNS */
+  struct server *dns_override_server2; /* for Secondary XDNS */
   int log_fac; /* log facility */
   char *log_file; /* optional log file */
   int max_logs;  /* queue limit */
@@ -1692,6 +1711,11 @@ int check_source(struct dns_header *header, size_t plen, unsigned char *pseudohe
 
 /* arp.c */
 int find_mac(union mysockaddr *addr, unsigned char *mac, int lazy, time_t now);
+int update_dnsoverride_records(struct dnsoverride_record *precord);
+struct dnsoverride_record* get_dnsoverride_record(char* macaddr);
+struct dnsoverride_record* get_dnsoverride_defaultrecord();
+int find_dnsoverride_server(char* macaddr, union all_addr* serv, int iptype,int count);
+int find_dnsoverride_defaultserver(union all_addr* serv1,union all_addr* serv2, int iptype,int* primary);
 int do_arp_script_run(void);
 
 /* dump.c */
diff --git a/src/edns0.c b/src/edns0.c
index d75d3cc..16c413e 100644
--- a/src/edns0.c
+++ b/src/edns0.c
@@ -15,6 +15,7 @@
 */
 
 #include "dnsmasq.h"
+#define XDNS_NULL_MAC "00:00:00:00:00:00"
 
 unsigned char *find_pseudoheader(struct dns_header *header, size_t plen, size_t  *len, unsigned char **p, int *is_sign, int *is_last)
 {
@@ -264,6 +265,55 @@ static void encoder(unsigned char *in, char *out)
   out[3] = char64(in[2]);
 }
 
+/* XDNS - Add cpe tag for XDNS if found */
+static size_t add_cpe_tag(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       unsigned char mac[DHCP_CHADDR_MAX] = {0};
+       int maclen = 0;
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+
+       struct dnsoverride_record* dnsrec = NULL;
+       unsigned char* cpetag = NULL;
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+               print_mac(strmac, mac, maclen);
+
+               dnsrec = get_dnsoverride_record(strmac);
+               if(!dnsrec)
+                       dnsrec = get_dnsoverride_defaultrecord();
+
+               if(dnsrec && dnsrec->cpetag[0])
+               {
+                       //my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() - found cpetag: %s"), dnsrec->cpetag);
+                       cpetag = dnsrec->cpetag;
+               }
+               else
+               {
+                       my_syslog(LOG_WARNING, _("#### XDNS add_cpe_tag() Could not find cpetag for mac %s"), strmac);
+               }
+       }
+
+       //if cpetag not found try to use the one from dnsmasq options
+       if(cpetag == NULL)
+       {
+               cpetag = (unsigned char *)daemon->dns_client_id;
+       }
+
+       // if no cpetag found return. Don't call add header.
+       if(cpetag == NULL)
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : no cpetag found in dnsmasq config"));
+               return plen;
+       }
+
+       my_syslog(LOG_WARNING, _("### XDNS - add cpe tag \'%s\' to edns0 header for mac [%s]"), cpetag, strmac);
+       return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, cpetag, strlen(cpetag), 0, 1);
+}
+//</XDNS>
+
+
 static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
 {
   int maclen, replace = 2; /* can't get mac address, just delete any incoming. */
@@ -287,16 +337,185 @@ static size_t add_dns_client(struct dns_header *header, size_t plen, unsigned ch
   return add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMDEVICEID, (unsigned char *)encode, strlen(encode), 0, replace); 
 }
 
+// XDNS
+void set_option_dnsoverride()
+{
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options[0] |= 1u << OPT_DNS_OVERRIDE;
+  else
+    daemon->options[1] |= 1u << (OPT_DNS_OVERRIDE - 32);
+}
 
-static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+// XDNS
+void reset_option_dnsoverride()
+ {
+  if (OPT_DNS_OVERRIDE < 32)
+    daemon->options[0] &= ~(1u << OPT_DNS_OVERRIDE);
+  else
+    daemon->options[1] &= ~(1u << (OPT_DNS_OVERRIDE - 32));
+}
+
+// XDNS
+static size_t add_xdns_server(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
 {
-  int maclen;
+  int maclen = 0;
   unsigned char mac[DHCP_CHADDR_MAX];
 
+  // find mac from socket addr
   if ((maclen = find_mac(l3, mac, 1, now)) != 0)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0); 
-    
-  return plen; 
+  {
+       // get mac in string format
+       char strmac[REC_ADDR_MAX] = {0};
+       memset(strmac, 0, REC_ADDR_MAX);
+       print_mac(strmac, mac, maclen);
+
+               my_syslog(LOG_INFO, _("### XDNS - add_xdns_server() for mac [%s]"), strmac);
+
+               // find family type from socket addr
+               int iptype = 4;
+               if(l3->sa.sa_family == AF_INET)
+               {
+                       iptype = 4;
+               }
+              else if(l3->sa.sa_family == AF_INET6)
+               {
+                       iptype = 6;
+               }
+
+               // get appropriate ipv4 or ipv6 dnsoverride address using mac addr
+               union all_addr dnsaddr;
+              union all_addr secondarydnsaddr;
+                      int primary=0;
+               memset(&dnsaddr, 0, sizeof(union all_addr));
+              memset(&secondarydnsaddr, 0, sizeof(union all_addr));
+
+               // if xdns addr for same iptype, if not found try for other iptype
+               // then try the default.
+              if(!find_dnsoverride_server(strmac, &dnsaddr, iptype,0))
+               {
+                      if(find_dnsoverride_server(strmac, &dnsaddr, (iptype==4)?6:4,0))//try other type
+                      {
+                             iptype = (iptype==4)?6:4;
+                      }
+                     else if(!find_dnsoverride_defaultserver(&dnsaddr,&secondarydnsaddr,iptype,&primary))
+                      {
+                           if(find_dnsoverride_defaultserver(&dnsaddr,&secondarydnsaddr, (iptype==4)?6:4,&primary))//try other type
+                            {
+                                   iptype = (iptype==4)?6:4;
+                            }
+                            else
+                            {
+                                   my_syslog(LOG_WARNING, _("#### XDNS : add_xdns_server() Could't find xdns server for [%s] or the default server!"), strmac);
+                                   reset_option_dnsoverride();
+                                   return plen;
+                            }
+                      }
+               }
+               //else found xdns server to use.
+               if(primary==2)      // For secondary XDNS server
+               {
+
+                       struct server *secondserv = NULL;
+                       char string[64]={0};
+                               secondserv = daemon->dns_override_server2;
+                               if(!secondserv) // if first time, daemon->dns_override_server2 is NULL. Allocate
+                               {
+                               secondserv = whine_malloc(sizeof (struct server)); //allocated once & reused. Not freed.
+                               if(secondserv)
+                               {
+                                       memset(secondserv, 0, sizeof(struct server));
+                               }
+                               daemon->dns_override_server2 = secondserv;
+                       }
+
+                               if(secondserv)
+                               {
+                                       if(iptype == 4)
+                                       {
+                                               my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv4 dns_override_server entry in daemon"));
+                                       //serv->addr.in.sin_addr = secondarydnsaddr.addr4;
+                                       memcpy(&secondserv->addr.in.sin_addr, &secondarydnsaddr.addr4, sizeof(struct in_addr));
+                                               secondserv->addr.sa.sa_family = AF_INET;
+                                       inet_ntop(AF_INET, &(secondarydnsaddr.addr4), string, 64);
+                                       my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv4 dns_override_server string:%s!"),string);
+                               }
+                                       else if(iptype == 6)
+                                       {
+                                               my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv6 dns_override_server entry in daemon"));
+                                               //serv->addr.in6.sin6_addr = secondarydnsaddr.addr6;
+                                               memcpy(&secondserv->addr.in6.sin6_addr, &secondarydnsaddr.addr6, sizeof(struct in6_addr));
+                                               secondserv->addr.sa.sa_family = AF_INET6;
+                                        inet_ntop(AF_INET6, &(secondarydnsaddr.addr6), string, 64);
+                                        my_syslog(LOG_WARNING, _("### XDNS - set secondary ipv6 dns_override_server string:%s!"),string);
+                                       }
+                                 }
+                       }
+                       else
+                       {
+                               daemon->dns_override_server2=NULL;
+                               my_syslog(LOG_WARNING, _("### XDNS - secondary XDNS server does not exist!"));
+
+                       }
+
+
+
+              struct server *serv = NULL;
+               serv = daemon->dns_override_server;
+               if(!serv) // if first time, daemon->dns_override_server is NULL. Allocate
+               {
+                      serv = whine_malloc(sizeof (struct server)); //allocated once & reused. Not freed.
+                      if(serv)
+                      {
+                            memset(serv, 0, sizeof(struct server));
+                      }
+                      daemon->dns_override_server = serv;
+               }
+
+               if(serv)
+               {
+                       if(iptype == 4)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv4 dns_override_server entry in daemon"));
+                              //serv->addr.in.sin_addr = dnsaddr.addr4;
+                               memcpy(&serv->addr.in.sin_addr, &dnsaddr.addr4, sizeof(struct in_addr));
+                               serv->addr.sa.sa_family = AF_INET;
+                       }
+                       else if(iptype == 6)
+                       {
+                               my_syslog(LOG_WARNING, _("### XDNS - set ipv6 dns_override_server entry in daemon"));
+                               //serv->addr.in6.sin6_addr = dnsaddr.addr6;
+                               memcpy(&serv->addr.in6.sin6_addr, &dnsaddr.addr6, sizeof(struct in6_addr));
+                               serv->addr.sa.sa_family = AF_INET6;
+                       }
+                   // Trigger overriding of upstream server
+                   set_option_dnsoverride();
+                }
+    }
+       else
+       {
+               reset_option_dnsoverride();
+               my_syslog(LOG_WARNING, _("#### XDNS : could not find MAC from l3 sockaddr !"));
+       }
+
+       return plen;
+}
+
+static size_t add_mac(struct dns_header *header, size_t plen, unsigned char *limit, union mysockaddr *l3, time_t now)
+{
+       my_syslog(LOG_WARNING, _("#### XDNS : add_mac() called"));
+       int maclen = 0;
+       unsigned char mac[DHCP_CHADDR_MAX];
+
+       if ((maclen = find_mac(l3, mac, 1, now)) != 0)
+       {
+          plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_MAC, mac, maclen, 0, 0);
+       }
+       else
+       {
+               my_syslog(LOG_WARNING, _("#### XDNS : add_mac() maclen = 0 !!"));
+               reset_option_dnsoverride();
+       }
+         return plen;
 }
 
 struct subnet_opt {
@@ -423,9 +642,16 @@ size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *l
   if (option_bool(OPT_MAC_B64) || option_bool(OPT_MAC_HEX))
     plen = add_dns_client(header, plen, limit, source, now);
 
-  if (daemon->dns_client_id)
-    plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, 
-			    (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
+  /* <XDNS> */
+  plen = add_xdns_server(header, plen, limit, source, now);
+
+  //if (daemon->dns_client_id)
+  //  plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID,
+  //               (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
+  plen = add_cpe_tag(header, plen, limit, source, now);
+
+  /* </XDNS> */
+
   
   if (option_bool(OPT_CLIENT_SUBNET))
     {
diff --git a/src/forward.c b/src/forward.c
index fde554d..40a096a 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -257,6 +257,7 @@ static int forward_query(int udpfd, unio
   union all_addr *addrp = NULL;
   unsigned int flags = 0;
   struct server *start = NULL;
+  struct server *secondstart = NULL;
   void *hash = hash_questions(header, plen, daemon->namebuff);
 #ifdef HAVE_DNSSEC
   int do_dnssec = 0;
@@ -449,6 +450,7 @@ static int forward_query(int udpfd, unio
 	    PUTSHORT(SAFE_PKTSZ, pheader);
 	}
       
+      int primaryxdns=0;
       while (1)
 	{ 
 	  /* only send to servers dealing with our domain.
@@ -460,10 +462,54 @@ static int forward_query(int udpfd, unio
 	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 	    {
 	      int fd;
+// < XDNS for IPv6>
+                 if(option_bool(OPT_DNS_OVERRIDE) && daemon->dns_override_server)
+                 {
+                                 my_syslog(LOG_INFO, _("#### XDNS - finding server socket to use based on dns_override_server family "));
+                                 if (daemon->dns_override_server->addr.sa.sa_family == AF_INET6)
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET6 family"));
+                                         if (!forward->rfd6 &&
+                                                         !(forward->rfd6 = allocate_rfd(AF_INET6)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd6;
+                                         fd = forward->rfd6->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP6 fd to use: %d "), fd);
+                                 }
+                                 else
+                                 {
+                                         my_syslog(LOG_INFO, _("#### XDNS - AF_INET family"));
+                                         if (!forward->rfd4 &&
+                                                         !(forward->rfd4 = allocate_rfd(AF_INET)))
+                                                 break;
+                                         daemon->rfd_save = forward->rfd4;
+                                         fd = forward->rfd4->fd;
+                                         my_syslog(LOG_INFO, _("#### XDNS - found IP4 fd to use: %d "), fd);
+                                 }
+
+       #ifdef HAVE_CONNTRACK
+                                 /* Copy connection mark of incoming query to outgoing connection. */
+                                 if (option_bool(OPT_CONNTRACK))
+                                 {
+                                         unsigned int mark;
+                                         if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
+                                                 setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                                 }
+       #endif
+
+                 }
+//</ XDNS for IPv6>
+
+                 else
+                 {
+                         //my_syslog(LOG_INFO, _("#### XDNS - OPT_DNS_OVERRIDE not set or dns_override_server empty. finding fd regular way "));
 
 	      /* find server socket to use, may need to get random one. */
 	      if (start->sfd)
+	      {
 		fd = start->sfd->fd;
+		my_syslog(LOG_INFO, _("#### XDNS - found server socket to use: %d "), start->sfd->fd);
+	      }
 	      else 
 		{
 		  if (start->addr.sa.sa_family == AF_INET6)
@@ -510,12 +556,102 @@ static int forward_query(int udpfd, unio
 		}
 #endif
 
-	      if (retry_send(sendto(fd, (char *)header, plen, 0,
-				    &start->addr.sa,
-				    sa_len(&start->addr))))
-		continue;
-	    
-	      if (errno == 0)
+                 //<XDNS>
+                       //=====
+                 //my_syslog(LOG_INFO, _("#### XDNS - List of nameservers: "));
+                        struct server *indx;
+                for (indx = daemon->servers; indx; indx = indx->next)
+                {
+                         char strprn[64] = {0}; memset(strprn, 0, 64);
+                         if(indx->addr.sa.sa_family == AF_INET)
+                         {
+                                 inet_ntop(AF_INET, &(indx->addr.in.sin_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in.sin_port, indx->addr.in.sin_family);
+
+                        }
+                         else if(indx->addr.sa.sa_family == AF_INET6)
+                         {
+                                 inet_ntop(AF_INET6, &(indx->addr.in6.sin6_addr), strprn, 64);
+                                 //my_syslog(LOG_INFO, _("            [%s]     port: 0x%x family: %d"), strprn, indx->addr.in6.sin6_port, indx->addr.in6.sin6_family);
+                         }
+                 }
+
+                struct server *xdnsserver;
+                if(!primaryxdns)
+                {
+                        xdnsserver=daemon->dns_override_server;
+                }
+                else
+                {
+                        xdnsserver=daemon->dns_override_server2;
+                }
+                       if(option_bool(OPT_DNS_OVERRIDE) && xdnsserver)
+                       {
+                         char strprn[64] = {0};
+                         if(xdnsserver->addr.sa.sa_family == AF_INET)
+                         {
+                                 memset(strprn, 0, 64);
+                                 if(inet_ntop(AF_INET, &(xdnsserver->addr.in.sin_addr), strprn, 64))                
+                                 {
+                                         if(strprn[0] != 0 && strcmp(strprn, "0.0.0.0") != 0)
+                                         {
+                                                 memcpy(&start->addr.in.sin_addr, &xdnsserver->addr.in.sin_addr, sizeof(struct in_addr));
+                                                 start->addr.in.sin_family = AF_INET;
+                                                 //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv4 xDNS addr"));
+                                         }
+                                 }
+                         }
+                         else if(xdnsserver->addr.sa.sa_family == AF_INET6)
+                         {
+                                 memset(strprn, 0, 64);
+                                 if(inet_ntop(AF_INET6, &(xdnsserver->addr.in6.sin6_addr), strprn, 64))             
+                                 {
+                                         if(strprn[0] != 0 && strcmp(strprn, "::") != 0)
+                                         {
+                                                 memcpy(&start->addr.in6.sin6_addr, &xdnsserver->addr.in6.sin6_addr, sizeof(struct in6_addr));
+                                                 start->addr.in6.sin6_family = AF_INET6;
+                                                 //my_syslog(LOG_WARNING, _("#### XDNS - Overriding upstream address with IPv6 xDNS addr"));
+                                         }
+                                 }
+                         }
+                         else
+                         {
+                                 my_syslog(LOG_WARNING, _("#### XDNS - dns_override_server family error!!"));
+                         }
+                       }
+                       else
+                       {
+                         //my_syslog(LOG_WARNING, _("#### XDNS - Did not modify upstream addr!"));
+                       }
+
+                 // Print where udp send is sending to:
+                 char strprn[64] = {0}; memset(strprn, 0, 64);
+                 if(start->addr.sa.sa_family == AF_INET)
+                         inet_ntop(AF_INET, &(start->addr.in.sin_addr), strprn, 64);
+                 else if(start->addr.sa.sa_family == AF_INET6)
+                         inet_ntop(AF_INET6, &(start->addr.in6.sin6_addr), strprn, 64);
+
+                         my_syslog(LOG_INFO, _("#### XDNS - sendto (%u, 0x%x, len = %d) to %s : %s)"),
+                                 fd,
+                                 (int)&start->addr.sa,
+                                 sa_len(&start->addr),
+                                 (start->addr.sa.sa_family == AF_INET6)?"ipv6":"ipv4", strprn);
+
+                 //=====
+                 // </XDNS>
+
+                 if (retry_send(
+                         sendto(fd,
+                                 (char *)header, plen, 0,
+                                 (const struct sockaddr *)&start->addr.sa,
+                                 (socklen_t)sa_len(&start->addr))))
+             {
+                 my_syslog(LOG_WARNING, _("#### XDNS : retry_send() retry..."));
+                 continue;
+             }
+
+
+               if (errno == 0) //succeeded
 		{
 #ifdef HAVE_DUMPFILE
 		  dump_packet(DUMP_UP_QUERY, (void *)header, plen, NULL, &start->addr);
@@ -540,6 +676,10 @@ static int forward_query(int udpfd, unio
 		    break;
 		  forward->forwardall++;
 		}
+               else
+               {
+                        my_syslog(LOG_WARNING, _("#### XDNS : sendto() failed!"));
+               }
 	    } 
 	  
 	  if (!(start = start->next))
@@ -547,6 +687,7 @@ static int forward_query(int udpfd, unio
 	  
 	  if (start == firstsentto)
 	    break;
+	 }
 	}
       
       if (forwarded)
@@ -569,7 +710,7 @@ static int forward_query(int udpfd, unio
   return 0;
 }
 
-static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
+size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
 			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader, 
 			    int check_subnet, union mysockaddr *query_source)
 {
diff --git a/src/network.c b/src/network.c
index 4bada37..e8f7347 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1583,6 +1583,98 @@ void check_servers(void)
   cleanup_servers();
 }
 
+/*XDNS- prints the linked list containg Primary and secondary DNS servers*/
+void print_dnsoverride_servers(struct dnsoverride_record *pprec)
+{
+
+        struct dnsoverride_record* p= pprec;
+       int i=0;
+        while(p != NULL)
+        {
+               char ipv4add[64] = {0};
+               char ipv6add[64] = {0};
+               inet_ntop(AF_INET, &(p->dnsaddr4.addr4), ipv4add, 64);
+               inet_ntop(AF_INET6, &(p->dnsaddr6.addr6), ipv6add, 64);
+                       my_syslog(LOG_ERR, _("### XDNS # macaddr[%d] : \"%s\""), i, p->macaddr);
+                       my_syslog(LOG_ERR, _("### XDNS # srvaddr4[%d] : \"%s\""), i, ipv4add);
+                       my_syslog(LOG_ERR, _("### XDNS # srvaddr6[%d] : \"%s\""), i, ipv6add);
+
+               my_syslog(LOG_ERR, _("### XDNS # cpetag[%d] : \"%s\""), i, p->cpetag);
+                p=p->next;
+               i++;
+
+        }
+
+}
+
+/* XDNS - Helper to create override server entries in record. Builds pprec list and returns the head. */
+static int create_dnsoverride_servers(struct dnsoverride_record **pprec, char* macaddr, char *srvaddr4, char *srvaddr6, char *cpetag)
+{
+       if(!macaddr || !srvaddr4) //MAC and Serv addr are must. cpetag is optional
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - mandatory fields (macaddr or ipv4addr) missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+       if(srvaddr6 == NULL)
+       {
+               my_syslog(LOG_ERR, _("### XDNS # parse error - ipv6 addr missing, skipping xdns entry !!"));
+               return 0; //fail
+       }
+
+
+       my_syslog(LOG_ERR, _("### XDNS # macaddr : \"%s\""), macaddr);
+      my_syslog(LOG_ERR, _("### XDNS # srvaddr4 : \"%s\""), srvaddr4);
+       my_syslog(LOG_ERR, _("### XDNS # srvaddr6 : \"%s\""), srvaddr6);
+
+       my_syslog(LOG_ERR, _("### XDNS # cpetag  : \"%s\""), cpetag);
+
+       //create entry and attach to record. This entries are maintained in arp.c. Cleanup is done there.
+       struct dnsoverride_record* entry = NULL;
+       struct dnsoverride_record* temp = NULL;
+       if ((entry = whine_malloc(sizeof(struct dnsoverride_record))))
+       {
+               memset(entry, 0, sizeof(struct dnsoverride_record));
+
+               if(strlen(macaddr) < REC_ADDR_MAX)
+               {
+                       strcpy(entry->macaddr, macaddr);
+               }
+
+               if (inet_pton(AF_INET, srvaddr4, &entry->dnsaddr4.addr4) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IP4 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+               if (inet_pton(AF_INET6, srvaddr6, &entry->dnsaddr6.addr6) != 1)
+               {
+                       my_syslog(LOG_ERR, _("### XDNS # Error converting IPv6 addr!"));
+                       free(entry);
+                       return 0;
+               }
+
+               if(cpetag && strlen(cpetag) < REC_STR_MAX)
+               {
+                       strcpy(entry->cpetag, cpetag);
+               }
+
+
+               entry->next = NULL;
+               if(*pprec == NULL)
+               {
+                       *pprec = entry;
+               }
+               else
+               {
+                      (*pprec)->next = (struct dnsoverride_record*)entry;
+               }
+       }
+       return 1; //success
+}
+
+
+
 /* Return zero if no servers found, in that case we keep polling.
    This is a protection against an update-time/write race on resolv.conf */
 int reload_servers(char *fname)
@@ -1591,71 +1683,117 @@ int reload_servers(char *fname)
   char *line;
   int gotone = 0;
 
-  /* buff happens to be MAXDNAME long... */
-  if (!(f = fopen(fname, "r")))
-    {
-      my_syslog(LOG_ERR, _("failed to read %s: %s"), fname, strerror(errno));
-      return 0;
-    }
-   
-  mark_servers(SERV_FROM_RESOLV);
-    
-  while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
-    {
-      union mysockaddr addr, source_addr;
-      char *token = strtok(line, " \t\n\r");
-      
-      if (!token)
-	continue;
-      if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0)
-	continue;
-      if (!(token = strtok(NULL, " \t\n\r")))
-	continue;
-      
-      memset(&addr, 0, sizeof(addr));
-      memset(&source_addr, 0, sizeof(source_addr));
-      
-      if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
-	{
+       /* XDNS - dns override servers record */
+       struct dnsoverride_record *prec = NULL;
+
+       /* buff happens to be MAXDNAME long... */
+       if (!(f = fopen(fname, "r")))
+       {
+               my_syslog(LOG_ERR, _("!!!!!! XDNS !!!!!! - failed to read %s: %s"), fname, strerror(errno));
+               return 0;
+       }
+       else
+       {
+               my_syslog(LOG_ERR, _("#############   XDNS : reload_servers()     read file :   %s    #############"), fname);
+       }
+
+       mark_servers(SERV_FROM_RESOLV);
+
+       while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
+       {
+               union mysockaddr addr, source_addr;
+               char *token = strtok(line, " \t\n\r");
+               //my_syslog(LOG_ERR, _("### XDNS ### token : \"%s\""), token);
+
+               if (!token)
+                       continue;
+               if (strcmp(token, "nameserver") != 0 && strcmp(token, "server") != 0 && strcmp(token, "dnsoverride") != 0)
+                       continue;
+
+               /***************** <XDNS> case dnsoverride **********************/
+               if(strcmp(token, "dnsoverride") == 0)
+               {
+                       char *macaddr = NULL, *srvaddr4 = NULL, *cpetag = NULL;
+                       char *srvaddr6 = NULL;
+                       if(!(macaddr = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read macaddr! fetch next dnsoverride entry."));
+
+                               continue; //fetch next record if macaddr not found
+                       }
+
+                       if(!(srvaddr4 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip4 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip4 addr not found for mac
+                       }
+
+                       if(!(srvaddr6 = strtok(NULL, " \t\n\r")))
+                       {
+                               my_syslog(LOG_ERR, _("### XDNS # cannot read ip6 addr! fetch next dnsoverride entry."));
+                               continue; //fetch next record if server ip6 addr not found for mac
+                       }
+                       cpetag = strtok(NULL, " \t\n\r"); //cpetag optional. proceed even if not found.
+
+                       // process dns override token. Build dnsoverride records.
+                       create_dnsoverride_servers(&prec, macaddr, srvaddr4, srvaddr6, cpetag);
+                       continue;
+
+               }
+               /***************** </XDNS> ***************************************/
+
+
+               if (!(token = strtok(NULL, " \t\n\r")))
+                       continue;
+
+               memset(&addr, 0, sizeof(addr));
+               memset(&source_addr, 0, sizeof(source_addr));
+
+               if ((addr.in.sin_addr.s_addr = inet_addr(token)) != (in_addr_t) -1)
+               {
+
 #ifdef HAVE_SOCKADDR_SA_LEN
-	  source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
+	  		source_addr.in.sin_len = addr.in.sin_len = sizeof(source_addr.in);
 #endif
-	  source_addr.in.sin_family = addr.in.sin_family = AF_INET;
-	  addr.in.sin_port = htons(NAMESERVER_PORT);
-	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
-	  source_addr.in.sin_port = htons(daemon->query_port);
-	}
-      else 
-	{	
-	  int scope_index = 0;
-	  char *scope_id = strchr(token, '%');
+	  		source_addr.in.sin_family = addr.in.sin_family = AF_INET;
+	  		addr.in.sin_port = htons(NAMESERVER_PORT);
+	  		source_addr.in.sin_addr.s_addr = INADDR_ANY;
+	  		source_addr.in.sin_port = htons(daemon->query_port);
+	       }
+      	       else 
+	       {	
+	  		int scope_index = 0;
+	  		char *scope_id = strchr(token, '%');
 	  
-	  if (scope_id)
-	    {
-	      *(scope_id++) = 0;
-	      scope_index = if_nametoindex(scope_id);
-	    }
+	 		if (scope_id)
+	    		{
+	      			*(scope_id++) = 0;
+	      			scope_index = if_nametoindex(scope_id);
+	    		}
 	  
-	  if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
-	    {
+	  		if (inet_pton(AF_INET6, token, &addr.in6.sin6_addr) > 0)
+	    		{
 #ifdef HAVE_SOCKADDR_SA_LEN
-	      source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
+	      			source_addr.in6.sin6_len = addr.in6.sin6_len = sizeof(source_addr.in6);
 #endif
-	      source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
-	      source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
-	      addr.in6.sin6_port = htons(NAMESERVER_PORT);
-	      addr.in6.sin6_scope_id = scope_index;
-	      source_addr.in6.sin6_addr = in6addr_any;
-	      source_addr.in6.sin6_port = htons(daemon->query_port);
-	      source_addr.in6.sin6_scope_id = 0;
-	    }
-	  else
-	    continue;
-	}
+			        source_addr.in6.sin6_family = addr.in6.sin6_family = AF_INET6;
+	      			source_addr.in6.sin6_flowinfo = addr.in6.sin6_flowinfo = 0;
+	      			addr.in6.sin6_port = htons(NAMESERVER_PORT);
+	      			addr.in6.sin6_scope_id = scope_index;
+	      			source_addr.in6.sin6_addr = in6addr_any;
+	      			source_addr.in6.sin6_port = htons(daemon->query_port);
+	      			source_addr.in6.sin6_scope_id = 0;
+	    		}
+	  		else
+	    			continue;
+	  	}
 
       add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
       gotone = 1;
     }
+       /* XDNS - Call to update the records in arp dnsoverride records*/
+       print_dnsoverride_servers(prec);
+       update_dnsoverride_records(prec);
   
   fclose(f);
   cleanup_servers();
diff --git a/src/option.c b/src/option.c
index 1f698da..b8bca1d 100644
--- a/src/option.c
+++ b/src/option.c
@@ -167,7 +167,8 @@ struct myoption {
 #define LOPT_IGNORE_CLID   358
 #define LOPT_SINGLE_PORT   359
 #define LOPT_SCRIPT_TIME   360
- 
+#define LOPT_DNSOVERRIDE   361
+
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
 #else
@@ -208,6 +209,7 @@ static const struct myoption opts[] =
     { "strict-order", 0, 0, 'o' },
     { "server", 1, 0, 'S' },
     { "rev-server", 1, 0, LOPT_REV_SERV },
+    { "dnsoverride", 2, 0, LOPT_DNSOVERRIDE },
     { "local", 1, 0, LOPT_LOCAL },
     { "address", 1, 0, 'A' },
     { "conf-file", 2, 0, 'C' },
@@ -4856,6 +4858,7 @@ void read_servers_file(void)
 {
   FILE *f;
 
+  my_syslog(LOG_WARNING, _("#### XDNS #### option.c-read_servers_file(): %s"), daemon->servers_file);
   if (!(f = fopen(daemon->servers_file, "r")))
     {
        my_syslog(LOG_ERR, _("cannot read %s: %s"), daemon->servers_file, strerror(errno));
