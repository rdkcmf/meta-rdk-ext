Subject: CVE-2018-16301

Description: Handle very large -f files by rejecting them.
_read(), on Windows, has a 32-bit size argument and a 32-bit return
value, so reject -f files that have more than 2^31-1 characters.

Add some #defines so that, on Windows, we use _fstati64 to get the size
of that file, to handle large files.

Don't assume that our definition for ssize_t is the same size as size_t;
by the time we want to print the return value of the read, we know it'll
fit into an int, so just cast it to int and print it with %d.

Backported from tcpdump-4.99.0 (faf8fb70af3a013e5d662b8283dec742fd6b1a77)
---

Index: tcpdump-4.9.3/netdissect-stdinc.h
===================================================================
--- tcpdump-4.9.3.orig/netdissect-stdinc.h
+++ tcpdump-4.9.3/netdissect-stdinc.h
@@ -149,13 +149,19 @@
 #ifdef _MSC_VER
 #define stat _stat
 #define open _open
-#define fstat _fstat
 #define read _read
 #define close _close
 #define O_RDONLY _O_RDONLY
 #endif  /* _MSC_VER */
 
 /*
+ *    * We define our_fstat64 as _fstati64, and define our_statb as
+ *       * struct _stati64, so we get 64-bit file sizes.
+ *          */
+#define our_fstat _fstati64
+#define our_statb struct _stati64
+
+/*
  * With MSVC, for C, __inline is used to make a function an inline.
  */
 #ifdef _MSC_VER
@@ -211,6 +217,13 @@ typedef char* caddr_t;
 
 #include <arpa/inet.h>
 
+/*
+ *  * We should have large file support enabled, if it's available,
+ *   * so just use fstat as our_fstat and struct stat as our_statb.
+ *    */
+#define our_fstat fstat
+#define our_statb struct stat
+
 #endif /* _WIN32 */
 
 #ifndef HAVE___ATTRIBUTE__
Index: tcpdump-4.9.3/tcpdump.c
===================================================================
--- tcpdump-4.9.3.orig/tcpdump.c
+++ tcpdump-4.9.3/tcpdump.c
@@ -108,6 +108,7 @@ The Regents of the University of Califor
 #endif /* HAVE_CAP_NG_H */
 #endif /* HAVE_LIBCAP_NG */
 
+#include "netdissect-stdinc.h"
 #include "netdissect.h"
 #include "interface.h"
 #include "addrtoname.h"
@@ -861,15 +862,22 @@ read_infile(char *fname)
 {
 	register int i, fd, cc;
 	register char *cp;
-	struct stat buf;
+	our_statb buf;
 
 	fd = open(fname, O_RDONLY|O_BINARY);
 	if (fd < 0)
 		error("can't open %s: %s", fname, pcap_strerror(errno));
 
-	if (fstat(fd, &buf) < 0)
+	if (our_fstat(fd, &buf) < 0)
 		error("can't stat %s: %s", fname, pcap_strerror(errno));
 
+	/*
+	 * 	 * Reject files whose size doesn't fit into an int; a filter
+	 * 	 	 * *that* large will probably be too big.
+	 * 	 	 	 */
+		if (buf.st_size > INT_MAX)
+					error("%s is too large", fname);
+
 	cp = malloc((u_int)buf.st_size + 1);
 	if (cp == NULL)
 		error("malloc(%d) for %s: %s", (u_int)buf.st_size + 1,
