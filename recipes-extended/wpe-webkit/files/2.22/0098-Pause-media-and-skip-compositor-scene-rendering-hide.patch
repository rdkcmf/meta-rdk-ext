From b8de74c38296741df9758a41246069ab4284eb69 Mon Sep 17 00:00:00 2001
From: Ievgen Mutavchi <Ievgen_Mutavchi@comcast.com>
Date: Sun, 26 Apr 2020 12:33:51 -0400
Subject: [PATCH 87/93] Pause media and skip compositor scene rendering hide
 when web page is hidden
Source: COMCAST
License: GPLV2
Upstream-Status: None
Signed-off-by: Eugene Mutavchi <Ievgen_Mutavchi@comcast.com>

---
 Source/WebCore/html/HTMLMediaElement.cpp             |  2 +-
 .../gstreamer/MediaPlayerPrivateGStreamerBase.cpp    | 11 +++++++++++
 .../gstreamer/MediaPlayerPrivateGStreamerBase.h      |  4 +++-
 .../threadedcompositor/ThreadedCompositor.cpp        | 12 +++++++++++-
 .../threadedcompositor/ThreadedCompositor.h          |  3 +++
 .../WebProcess/WebPage/AcceleratedDrawingArea.cpp    |  4 ++++
 .../ThreadedCoordinatedLayerTreeHost.cpp             |  7 +++++++
 .../ThreadedCoordinatedLayerTreeHost.h               |  2 ++
 Source/WebKit/WebProcess/WebPage/LayerTreeHost.cpp   |  6 ++++++
 Source/WebKit/WebProcess/WebPage/LayerTreeHost.h     |  1 +
 Source/WebKit/WebProcess/WebPage/WebPage.cpp         | 10 +++++++++-
 11 files changed, 58 insertions(+), 4 deletions(-)

Index: git/Source/WebCore/html/HTMLMediaElement.cpp
===================================================================
--- git.orig/Source/WebCore/html/HTMLMediaElement.cpp
+++ git/Source/WebCore/html/HTMLMediaElement.cpp
@@ -5747,7 +5747,7 @@ void HTMLMediaElement::visibilityStateCh
         m_player->setVisible(!m_elementIsHidden);
 
     bool isPlayingAudio = isPlaying() && hasAudio() && !muted() && volume();
-    if (!isPlayingAudio) {
+    if (true || !isPlayingAudio) {
         if (m_elementIsHidden) {
             ALWAYS_LOG(LOGIDENTIFIER, "Suspending playback after going to the background");
             m_mediaSession->beginInterruption(PlatformMediaSession::EnteringBackground);
Index: git/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
===================================================================
--- git.orig/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
+++ git/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
@@ -1602,6 +1602,17 @@ void MediaPlayerPrivateGStreamerBase::pl
 #endif
 }
 
+void MediaPlayerPrivateGStreamerBase::setVisible(bool visible)
+{
+    if (m_visible == visible)
+        return;
+    m_visible = visible;
+
+#if USE(HOLE_PUNCH_GSTREAMER)
+    updateVideoRectangle(!m_visible);
+#endif
+}
+
 }
 
 #endif // USE(GSTREAMER)
Index: git/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
===================================================================
--- git.orig/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
+++ git/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.h
@@ -96,7 +96,7 @@ public:
 
     bool ended() const override { return m_isEndReached; }
 
-    void setVisible(bool) override { }
+    void setVisible(bool) override;
     void setSize(const IntSize&) override;
     void setPosition(const IntPoint&) override;
     void sizeChanged();
@@ -294,6 +294,8 @@ protected:
     RefPtr<const CDMInstance> m_cdmInstance;
     String m_lastInitData;
 #endif
+
+    bool m_visible { true };
 };
 
 }
Index: git/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.cpp
===================================================================
--- git.orig/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.cpp
+++ git/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.cpp
@@ -172,6 +172,13 @@ void ThreadedCompositor::setDrawsBackgro
     m_compositingRunLoop->scheduleUpdate();
 }
 
+void ThreadedCompositor::setIsVisible(bool v)
+{
+    LockHolder locker(m_attributes.lock);
+    m_attributes.isVisbile = v;
+    m_compositingRunLoop->scheduleUpdate();
+}
+
 void ThreadedCompositor::updateViewport()
 {
     m_compositingRunLoop->scheduleUpdate();
@@ -241,6 +248,7 @@ void ThreadedCompositor::renderLayerTree
     float scaleFactor;
     bool drawsBackground;
     bool needsResize;
+    bool isVisbile;
     Vector<WebCore::CoordinatedGraphicsState> states;
 
     {
@@ -250,6 +258,7 @@ void ThreadedCompositor::renderLayerTree
         scaleFactor = m_attributes.scaleFactor;
         drawsBackground = m_attributes.drawsBackground;
         needsResize = m_attributes.needsResize;
+        isVisbile = m_attributes.isVisbile;
 
         states = WTFMove(m_attributes.states);
 
@@ -280,12 +289,13 @@ void ThreadedCompositor::renderLayerTree
     viewportTransform.scale(scaleFactor);
     viewportTransform.translate(-scrollPosition.x(), -scrollPosition.y());
 
-    if (!drawsBackground) {
+    if (!drawsBackground || !isVisbile) {
         glClearColor(0, 0, 0, 0);
         glClear(GL_COLOR_BUFFER_BIT);
     }
 
     m_scene->applyStateChanges(states);
+    if (isVisbile)
     m_scene->paintToCurrentGLContext(viewportTransform, 1, FloatRect { FloatPoint { }, viewportSize },
         Color::transparent, !drawsBackground, m_paintFlags);
 
Index: git/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.h
===================================================================
--- git.orig/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.h
+++ git/Source/WebKit/Shared/CoordinatedGraphics/threadedcompositor/ThreadedCompositor.h
@@ -85,6 +85,8 @@ public:
 
     void frameComplete();
 
+    void setIsVisible(bool v);
+
 private:
     ThreadedCompositor(Client&, ThreadedDisplayRefreshMonitor::Client&, WebCore::PlatformDisplayID, WebPage&, const WebCore::IntSize&, float scaleFactor, ShouldDoFrameSync, WebCore::TextureMapper::PaintFlags);
 
@@ -123,6 +125,7 @@ private:
 
         bool clientRendersNextFrame { false };
         bool coordinateUpdateCompletionWithClient { false };
+        bool isVisbile { true };
     } m_attributes;
 
 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
Index: git/Source/WebKit/WebProcess/WebPage/AcceleratedDrawingArea.cpp
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/AcceleratedDrawingArea.cpp
+++ git/Source/WebKit/WebProcess/WebPage/AcceleratedDrawingArea.cpp
@@ -502,6 +502,10 @@ void AcceleratedDrawingArea::activitySta
 {
     if (changed & ActivityState::IsInWindow)
         handleIsInWindowChanged();
+
+    if (changed & ActivityState::IsVisible && m_layerTreeHost) {
+        m_layerTreeHost->pageVisibilityChanged(m_webPage.isVisible());
+    }
 }
 
 void AcceleratedDrawingArea::attachViewOverlayGraphicsLayer(Frame* frame, GraphicsLayer* viewOverlayRootLayer)
Index: git/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.cpp
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.cpp
+++ git/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.cpp
@@ -321,6 +321,13 @@ RefPtr<WebCore::DisplayRefreshMonitor> T
 }
 #endif
 
+void ThreadedCoordinatedLayerTreeHost::pageVisibilityChanged(bool v)
+{
+    CoordinatedLayerTreeHost::pageVisibilityChanged(v);
+    if (m_compositor)
+        m_compositor->setIsVisible(v);
+}
+
 } // namespace WebKit
 
 #endif // USE(COORDINATED_GRAPHICS)
Index: git/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.h
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.h
+++ git/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/ThreadedCoordinatedLayerTreeHost.h
@@ -71,6 +71,8 @@ private:
 
     void setIsDiscardable(bool) override;
 
+    void pageVisibilityChanged(bool) override;
+
 #if PLATFORM(GTK) && PLATFORM(X11) &&  !USE(REDIRECTED_XCOMPOSITE_WINDOW)
     void setNativeSurfaceHandleForCompositing(uint64_t) override;
 #endif
Index: git/Source/WebKit/WebProcess/WebPage/LayerTreeHost.cpp
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/LayerTreeHost.cpp
+++ git/Source/WebKit/WebProcess/WebPage/LayerTreeHost.cpp
@@ -83,6 +83,12 @@ void LayerTreeHost::resumeRendering()
     scheduleLayerFlush();
 }
 
+void LayerTreeHost::pageVisibilityChanged(bool isVisible)
+{
+    if (isVisible)
+        scheduleLayerFlush();
+}
+
 void LayerTreeHost::invalidate()
 {
     ASSERT(m_isValid);
Index: git/Source/WebKit/WebProcess/WebPage/LayerTreeHost.h
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/LayerTreeHost.h
+++ git/Source/WebKit/WebProcess/WebPage/LayerTreeHost.h
@@ -80,6 +80,7 @@ public:
 
     virtual void pauseRendering();
     virtual void resumeRendering();
+    virtual void pageVisibilityChanged(bool);
 
     virtual WebCore::GraphicsLayerFactory* graphicsLayerFactory() { return nullptr; }
 
Index: git/Source/WebKit/WebProcess/WebPage/WebPage.cpp
===================================================================
--- git.orig/Source/WebKit/WebProcess/WebPage/WebPage.cpp
+++ git/Source/WebKit/WebProcess/WebPage/WebPage.cpp
@@ -2766,7 +2766,7 @@ void WebPage::updateIsInWindow(bool isIn
         // Defer the call to Page::setCanStartMedia() since it ends up sending a synchronous message to the UI process
         // in order to get plug-in connections, and the UI process will be waiting for the Web process to update the backing
         // store after moving the view into a window, until it times out and paints white. See <rdar://problem/9242771>.
-        if (m_mayStartMediaWhenInWindow)
+        if (m_mayStartMediaWhenInWindow && !m_setCanStartMediaTimer.isActive())
             m_setCanStartMediaTimer.startOneShot(0_s);
 
         WebProcess::singleton().pageDidEnterWindow(m_pageID);
@@ -2785,6 +2785,14 @@ void WebPage::visibilityDidChange()
         if (auto* frame = m_mainFrame->coreFrame())
             frame->loader().history().saveDocumentAndScrollState();
     }
+
+    if (!isVisible) {
+        m_setCanStartMediaTimer.stop();
+        m_page->setCanStartMedia(false);
+    } else if (m_activityState & WebCore::ActivityState::IsInWindow) {
+        if (m_mayStartMediaWhenInWindow && !m_setCanStartMediaTimer.isActive())
+            m_setCanStartMediaTimer.startOneShot(0_s);
+    }
 }
 
 void WebPage::setActivityState(OptionSet<ActivityState::Flag> activityState, ActivityStateChangeID activityStateChangeID, const Vector<CallbackID>& callbackIDs)
