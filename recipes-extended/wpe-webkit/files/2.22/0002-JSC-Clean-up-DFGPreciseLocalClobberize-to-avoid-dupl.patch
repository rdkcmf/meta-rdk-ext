From 104d3a67ada040b461d6ebeaaae9cb24468d9519 Mon Sep 17 00:00:00 2001
From: "ysuzuki@apple.com"
 <ysuzuki@apple.com@268f45cc-cd09-0410-ab3c-d52691b4dbfc>
Date: Sat, 16 Jan 2021 00:02:24 +0000
Subject: [PATCH 2/5] [JSC] Clean up DFGPreciseLocalClobberize to avoid
 duplicate code https://bugs.webkit.org/show_bug.cgi?id=220670

Reviewed by Filip Pizlo.

This patch cleans up DFGPreciseLocalClobberize by extracting code to lambda to remove duplicate code.

* dfg/DFGPreciseLocalClobberize.h:
(JSC::DFG::PreciseLocalClobberizeAdaptor::readTop):

git-svn-id: http://svn.webkit.org/repository/webkit/trunk@271544 268f45cc-cd09-0410-ab3c-d52691b4dbfc
---
 .../dfg/DFGPreciseLocalClobberize.h           | 50 +++++++++++--------
 1 file changed, 28 insertions(+), 22 deletions(-)

diff --git a/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h b/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
index 0d8bffe069cd..f95b6705dd8e 100644
--- a/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
+++ b/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
@@ -105,6 +105,30 @@ private:
     
     void readTop()
     {
+        auto readWorld = [&] (Node* node) {
+            // All of the outermost arguments, except this, are read in sloppy mode.
+            if (!m_graph.m_codeBlock->isStrictMode()) {
+                for (unsigned i = m_graph.m_codeBlock->numParameters(); i--;)
+                    m_read(virtualRegisterForArgument(i));
+            }
+
+            // The stack header is read.
+            for (unsigned i = 0; i < CallFrameSlot::thisArgument; ++i)
+                m_read(VirtualRegister(i));
+
+            // Read all of the inline arguments and call frame headers that we didn't already capture.
+            for (InlineCallFrame* inlineCallFrame = m_node->origin.semantic.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame->getCallerInlineFrameSkippingTailCalls()) {
+                if (!inlineCallFrame->isStrictMode()) {
+                    for (unsigned i = inlineCallFrame->argumentsWithFixup.size(); i--;)
+                        m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgument(i).offset()));
+                }
+                if (inlineCallFrame->isClosureCall)
+                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee));
+                if (inlineCallFrame->isVarargs())
+                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
+            }
+        };
+
         auto readFrame = [&] (InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip) {
             if (!inlineCallFrame) {
                 // Read the outermost arguments and argument count.
@@ -122,8 +146,10 @@ private:
 
         auto readSpread = [&] (Node* spread) {
             ASSERT(spread->op() == Spread || spread->op() == PhantomSpread);
-            if (!spread->child1()->isPhantomAllocation())
+            if (!spread->child1()->isPhantomAllocation()) {
+                readWorld(spread);
                 return;
+            }
 
             ASSERT(spread->child1()->op() == PhantomCreateRest || spread->child1()->op() == PhantomNewArrayBuffer);
             if (spread->child1()->op() == PhantomNewArrayBuffer) {
@@ -237,27 +263,7 @@ private:
         }
             
         default: {
-            // All of the outermost arguments, except this, are read in sloppy mode.
-            if (!m_graph.m_codeBlock->isStrictMode()) {
-                for (unsigned i = m_graph.m_codeBlock->numParameters(); i--;)
-                    m_read(virtualRegisterForArgument(i));
-            }
-        
-            // The stack header is read.
-            for (unsigned i = 0; i < CallFrameSlot::thisArgument; ++i)
-                m_read(VirtualRegister(i));
-        
-            // Read all of the inline arguments and call frame headers that we didn't already capture.
-            for (InlineCallFrame* inlineCallFrame = m_node->origin.semantic.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame->getCallerInlineFrameSkippingTailCalls()) {
-                if (!inlineCallFrame->isStrictMode()) {
-                    for (unsigned i = inlineCallFrame->argumentsWithFixup.size(); i--;)
-                        m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgument(i).offset()));
-                }
-                if (inlineCallFrame->isClosureCall)
-                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee));
-                if (inlineCallFrame->isVarargs())
-                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
-            }
+            readWorld(m_node);
             break;
         } }
     }
-- 
2.25.1

