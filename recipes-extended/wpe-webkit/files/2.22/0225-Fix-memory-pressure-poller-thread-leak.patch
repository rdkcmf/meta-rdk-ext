From 308358ef079453c15c398cece4b7fa5da3328c27 Mon Sep 17 00:00:00 2001
From: Eugene Mutavchi <Ievgen_Mutavchi@comcast.com>
Date: Thu, 4 Feb 2021 17:25:17 +0000
Subject: [PATCH 1/4] Fix memory pressure poller thread leak

---
 Source/WTF/wtf/MemoryPressureHandler.h        |  3 ++
 .../wtf/linux/MemoryPressureHandlerLinux.cpp  | 34 +++++++++++++++----
 2 files changed, 31 insertions(+), 6 deletions(-)

diff --git a/Source/WTF/wtf/MemoryPressureHandler.h b/Source/WTF/wtf/MemoryPressureHandler.h
index 0c7388c1179a..01ad7a718220 100644
--- a/Source/WTF/wtf/MemoryPressureHandler.h
+++ b/Source/WTF/wtf/MemoryPressureHandler.h
@@ -197,6 +197,8 @@ private:
     RunLoop::Timer<MemoryPressureHandler> m_holdOffTimer;
     void holdOffTimerFired();
 
+    struct MemoryUsagePollerThreadContext;
+
     class MemoryUsagePoller {
         WTF_MAKE_NONCOPYABLE(MemoryUsagePoller); WTF_MAKE_FAST_ALLOCATED;
     public:
@@ -205,6 +207,7 @@ private:
 
     private:
         RefPtr<Thread> m_thread;
+        RefPtr<MemoryUsagePollerThreadContext> m_context;
     };
 
     std::unique_ptr<MemoryUsagePoller> m_memoryUsagePoller;
diff --git a/Source/WTF/wtf/linux/MemoryPressureHandlerLinux.cpp b/Source/WTF/wtf/linux/MemoryPressureHandlerLinux.cpp
index 62cf66771317..72befd272497 100644
--- a/Source/WTF/wtf/linux/MemoryPressureHandlerLinux.cpp
+++ b/Source/WTF/wtf/linux/MemoryPressureHandlerLinux.cpp
@@ -162,16 +162,36 @@ static bool initializeProcessMemoryLimits(size_t &criticalLimit, size_t &nonCrit
     return false;
 }
 
+struct MemoryPressureHandler::MemoryUsagePollerThreadContext
+    : public ThreadSafeRefCounted<MemoryPressureHandler::MemoryUsagePollerThreadContext>
+{
+    void stop()
+    {
+        LockHolder locker(m_lock);
+        m_shouldStop = true;
+        m_condition.notifyAll();
+    }
+
+    // returns false when should stop polling
+    bool sleep(const Seconds timeout)
+    {
+	LockHolder locker(m_lock);
+	return !m_condition.waitFor(m_lock, timeout, [this]() { return m_shouldStop; });
+    }
+
+    Lock m_lock;
+    bool m_shouldStop { false };
+    Condition m_condition;
+};
+
 MemoryPressureHandler::MemoryUsagePoller::MemoryUsagePoller()
 {
-    m_thread = Thread::create("WTF: MemoryPressureHandler", [this] {
+    m_context = adoptRef(new MemoryPressureHandler::MemoryUsagePollerThreadContext());
+    m_thread = Thread::create("WTF: MemoryPressureHandler", [this, context = m_context] {
         do {
             size_t vmRSS = readToken(s_processStatus, "VmRSS:", KB);
 
-            if (!vmRSS)
-                return;
-
-            if (vmRSS > s_pollMaximumProcessMemoryNonCriticalLimit) {
+            if (vmRSS != static_cast<size_t>(-1) && vmRSS > s_pollMaximumProcessMemoryNonCriticalLimit) {
                 bool isCritical = vmRSS > s_pollMaximumProcessMemoryCriticalLimit;
                 callOnMainThread([isCritical] {
                     MemoryPressureHandler::singleton().triggerMemoryPressureEvent(isCritical);
@@ -179,13 +199,15 @@ MemoryPressureHandler::MemoryUsagePoller::MemoryUsagePoller()
                 return;
             }
 
-            sleep(s_memoryUsagePollerInterval);
+            if (!context->sleep(s_memoryUsagePollerInterval))
+                return;
         } while (true);
     });
 }
 
 MemoryPressureHandler::MemoryUsagePoller::~MemoryUsagePoller()
 {
+    m_context->stop();
     if (m_thread)
         m_thread->detach();
 }
-- 
2.17.1

