From 9c150725ba6ff37413c12f69be368c19ef5bbff6 Mon Sep 17 00:00:00 2001
From: "dino@apple.com" <dino@apple.com@268f45cc-cd09-0410-ab3c-d52691b4dbfc>
Date: Tue, 12 Feb 2019 21:57:48 +0000
Subject: [PATCH 07/15] Source/WebCore: Remove setDefersLoading infrastructure
 from WebKit2 https://bugs.webkit.org/show_bug.cgi?id=194506

Patch by Alex Christensen <achristensen@webkit.org> on 2019-02-12
Reviewed by Brady Eidson.

setDefersLoading is inherently racy from WebCore to the NetworkProcess,
it adds unwanted complexity to the initialization and use of network objects,
and it has led to many unrecoverable hang bugs over the years.
We needed to force it into WebKit2 to transition some existing clients who relied on it,
but we have recently finished transitioning those clients to other solutions, mostly
completion handlers.

* inspector/PageScriptDebugServer.cpp:
(WebCore::PageScriptDebugServer::setJavaScriptPaused):

LayoutTests:
BitmapRenderer should handle existing ImageBuffers
https://bugs.webkit.org/show_bug.cgi?id=194555
<rdar://problem/47857150>

Reviewed by Tim Horton.

Test that creates a canvas, triggers an ImageBuffer to be created, then
creates the bitmaprenderer context.

* fast/canvas/bitmaprenderer-created-after-toBlob-expected.txt: Added.
* fast/canvas/bitmaprenderer-created-after-toBlob.html: Added.

git-svn-id: http://svn.webkit.org/repository/webkit/trunk@241319 268f45cc-cd09-0410-ab3c-d52691b4dbfc
---
 LayoutTests/ChangeLog                         | 14 ++++++++
 ...renderer-created-after-toBlob-expected.txt |  1 +
 .../bitmaprenderer-created-after-toBlob.html  | 22 ++++++++++++
 Source/WebCore/ChangeLog                      | 20 +++++++++++
 Source/WebCore/html/HTMLCanvasElement.cpp     | 34 ++++++++++---------
 5 files changed, 75 insertions(+), 16 deletions(-)
 create mode 100644 LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob-expected.txt
 create mode 100644 LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob.html

Index: git/LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob-expected.txt
===================================================================
--- /dev/null
+++ git/LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob-expected.txt
@@ -0,0 +1 @@
+Should not crash.
Index: git/LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob.html
===================================================================
--- /dev/null
+++ git/LayoutTests/fast/canvas/bitmaprenderer-created-after-toBlob.html
@@ -0,0 +1,22 @@
+<script>
+if (window.testRunner)
+    testRunner.dumpAsText();
+
+function callback() {
+    if (window.GCController)
+        return GCController.collect();
+
+    // Force garbage collection
+    for (let i=0; i < 100; i++)
+        var a = new Uint8Array(1024*1024);
+}
+
+function run() {
+   var c = document.createElement("canvas");
+   c.toBlob(callback);
+   var ctx = c.getContext("bitmaprenderer");
+}
+
+window.addEventListener("load", run, false);
+</script>
+Should not crash.
Index: git/Source/WebCore/ChangeLog
===================================================================
--- git.orig/Source/WebCore/ChangeLog
+++ git/Source/WebCore/ChangeLog
@@ -1396,6 +1396,26 @@
         (WebCore::IDBCursor::request):
         * Modules/indexeddb/IDBRequest.h:
 
+2019-02-12  Dean Jackson  <dino@apple.com>
+
+        BitmapRenderer should handle existing ImageBuffers
+        https://bugs.webkit.org/show_bug.cgi?id=194555
+        <rdar://problem/47857150>
+
+        Reviewed by Tim Horton.
+
+        Our logic in ImageBitmapRenderingContext assumed that
+        it had always created the ImageBuffer being used. However, it's
+        valid to call something like toBlob() or toDataURL() before creating
+        a context, so we need to handle the case where an ImageBuffer
+        already exists.
+
+        Test: fast/canvas/bitmaprenderer-created-after-toBlob.html
+
+        * html/HTMLCanvasElement.cpp:
+        (WebCore::HTMLCanvasElement::createImageBuffer const): Move some logic into setImageBuffer.
+        (WebCore::HTMLCanvasElement::setImageBuffer const): Make sure to clear the state saver.
+
 2018-08-26  Youenn Fablet  <youenn@apple.com>
 
         IDBCursor does not need to be an ActiveDOMObject
Index: git/Source/WebCore/html/HTMLCanvasElement.cpp
===================================================================
--- git.orig/Source/WebCore/html/HTMLCanvasElement.cpp
+++ git/Source/WebCore/html/HTMLCanvasElement.cpp
@@ -925,22 +925,6 @@ void HTMLCanvasElement::createImageBuffe
 
     auto hostWindow = (document().view() && document().view()->root()) ? document().view()->root()->hostWindow() : nullptr;
     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpaceSRGB, hostWindow));
-    if (!m_imageBuffer)
-        return;
-    m_imageBuffer->context().setShadowsIgnoreTransforms(true);
-    m_imageBuffer->context().setImageInterpolationQuality(defaultInterpolationQuality);
-    m_imageBuffer->context().setStrokeThickness(1);
-    m_contextStateSaver = std::make_unique<GraphicsContextStateSaver>(m_imageBuffer->context());
-
-    JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()->vm());
-    HTMLElement::scriptExecutionContext()->vm().heap.reportExtraMemoryAllocated(memoryCost());
-
-#if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
-    if (m_context && m_context->is2d()) {
-        // Recalculate compositing requirements if acceleration state changed.
-        const_cast<HTMLCanvasElement*>(this)->invalidateStyleAndLayerComposition();
-    }
-#endif
 }
 
 void HTMLCanvasElement::setImageBuffer(std::unique_ptr<ImageBuffer>&& buffer) const
@@ -950,6 +934,7 @@ void HTMLCanvasElement::setImageBuffer(s
 
     {
         auto locker = holdLock(m_imageBufferAssignmentLock);
+        m_contextStateSaver = nullptr;
         m_imageBuffer = WTFMove(buffer);
     }
 
@@ -961,6 +946,23 @@ void HTMLCanvasElement::setImageBuffer(s
 
     if (m_context && m_imageBuffer && previousMemoryCost != currentMemoryCost)
         InspectorInstrumentation::didChangeCanvasMemory(*m_context);
+
+    if (!m_imageBuffer)
+        return;
+    m_imageBuffer->context().setShadowsIgnoreTransforms(true);
+    m_imageBuffer->context().setImageInterpolationQuality(defaultInterpolationQuality);
+    m_imageBuffer->context().setStrokeThickness(1);
+    m_contextStateSaver = std::make_unique<GraphicsContextStateSaver>(m_imageBuffer->context());
+
+    JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()->vm());
+    HTMLElement::scriptExecutionContext()->vm().heap.reportExtraMemoryAllocated(memoryCost());
+
+#if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
+    if (m_context && m_context->is2d()) {
+        // Recalculate compositing requirements if acceleration state changed.
+        const_cast<HTMLCanvasElement*>(this)->invalidateStyleAndLayerComposition();
+    }
+#endif
 }
 
 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr<ImageBuffer>&& buffer)
