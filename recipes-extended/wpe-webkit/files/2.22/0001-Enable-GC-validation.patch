From a828010d0ec570646274aa4d650fd542fdefc626 Mon Sep 17 00:00:00 2001
From: Eugene Mutavchi <Ievgen_Mutavchi@comcast.com>
Date: Tue, 27 Jul 2021 19:21:36 +0000
Subject: [PATCH 1/6] Enable GC validation

---
 Source/JavaScriptCore/heap/SlotVisitor.cpp    | 21 ++++++++++++++++---
 .../interpreter/Interpreter.cpp               |  4 ++++
 Source/JavaScriptCore/runtime/JSCellInlines.h |  4 ++--
 Source/JavaScriptCore/runtime/Options.h       |  2 +-
 Source/JavaScriptCore/runtime/Structure.cpp   |  2 +-
 Source/JavaScriptCore/runtime/VM.cpp          |  2 ++
 6 files changed, 28 insertions(+), 7 deletions(-)

diff --git a/Source/JavaScriptCore/heap/SlotVisitor.cpp b/Source/JavaScriptCore/heap/SlotVisitor.cpp
index e737f39450e9..fe3f485ff88e 100644
--- a/Source/JavaScriptCore/heap/SlotVisitor.cpp
+++ b/Source/JavaScriptCore/heap/SlotVisitor.cpp
@@ -47,7 +47,7 @@
 
 namespace JSC {
 
-#if ENABLE(GC_VALIDATION)
+#if 1 || ENABLE(GC_VALIDATION)
 static void validate(JSCell* cell)
 {
     RELEASE_ASSERT(cell);
@@ -60,7 +60,7 @@ static void validate(JSCell* cell)
     // Both the cell's structure, and the cell's structure's structure should be the Structure Structure.
     // I hate this sentence.
     VM& vm = *cell->vm();
-    if (cell->structure()->structure()->JSCell::classInfo(vm) != cell->structure()->JSCell::classInfo(vm)) {
+    if (!cell->structure()->structure() || cell->structure()->structure()->JSCell::classInfo(vm) != cell->structure()->JSCell::classInfo(vm)) {
         const char* parentClassName = 0;
         const char* ourClassName = 0;
         if (cell->structure()->structure() && cell->structure()->structure()->JSCell::classInfo(vm))
@@ -75,6 +75,15 @@ static void validate(JSCell* cell)
     // Make sure we can walk the ClassInfo chain
     const ClassInfo* info = cell->classInfo(vm);
     do { } while ((info = info->parentClass));
+
+    if (!cell->structure(vm)) {
+        dataLogF("validate(): Cell %p has null structure, type %d. \n", cell, cell->type());
+        CRASH();
+    }
+    if (!cell->methodTable(vm)) {
+        dataLogF("validate(): Cell %p has null methodTable, type %d. \n", cell, cell->type());
+        CRASH();
+    }
 }
 #endif
 
@@ -239,7 +248,7 @@ ALWAYS_INLINE void SlotVisitor::appendHiddenSlowImpl(JSCell* cell, Dependency de
 {
     ASSERT(!m_isCheckingForDefaultMarkViolation);
 
-#if ENABLE(GC_VALIDATION)
+#if 1 || ENABLE(GC_VALIDATION)
     validate(cell);
 #endif
     
@@ -379,6 +388,12 @@ ALWAYS_INLINE void SlotVisitor::visitChildren(const JSCell* cell)
         break;
         
     default:
+        if (!cell->structure(vm())) {
+            dataLogF("SlotVisitor::visitChildren(): Cell %p has null structure, type %d. \n", cell, cell->type());
+        }
+        if (!cell->methodTable(vm())) {
+            dataLogF("SlotVisitor::visitChildren(): Cell %p has null methodTable, type %d. \n", cell, cell->type());
+        }
         // FIXME: This could be so much better.
         // https://bugs.webkit.org/show_bug.cgi?id=162462
         cell->methodTable(vm())->visitChildren(const_cast<JSCell*>(cell), *this);
diff --git a/Source/JavaScriptCore/interpreter/Interpreter.cpp b/Source/JavaScriptCore/interpreter/Interpreter.cpp
index 8ffb2c551d7b..e008dc34ead6 100644
--- a/Source/JavaScriptCore/interpreter/Interpreter.cpp
+++ b/Source/JavaScriptCore/interpreter/Interpreter.cpp
@@ -551,6 +551,10 @@ private:
 
 void Interpreter::getStackTrace(JSCell* owner, Vector<StackFrame>& results, size_t framesToSkip, size_t maxStackSize)
 {
+#if CPU(MIPS)
+    return;
+#endif
+
     if (Options::disableStackTrace())
        return;
 
diff --git a/Source/JavaScriptCore/runtime/JSCellInlines.h b/Source/JavaScriptCore/runtime/JSCellInlines.h
index f69b3803d6a2..66edb0fee000 100644
--- a/Source/JavaScriptCore/runtime/JSCellInlines.h
+++ b/Source/JavaScriptCore/runtime/JSCellInlines.h
@@ -156,8 +156,8 @@ template<typename T>
 ALWAYS_INLINE void* tryAllocateCellHelper(Heap& heap, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
 {
     VM& vm = *heap.vm();
-    ASSERT(deferralContext || !DisallowGC::isInEffectOnCurrentThread());
-    ASSERT(size >= sizeof(T));
+    RELEASE_ASSERT(deferralContext || !DisallowGC::isInEffectOnCurrentThread());
+    RELEASE_ASSERT(size >= sizeof(T));
     JSCell* result = static_cast<JSCell*>(subspaceFor<T>(vm)->allocateNonVirtual(vm, size, deferralContext, failureMode));
     if (failureMode == AllocationFailureMode::ReturnNull && !result)
         return nullptr;
diff --git a/Source/JavaScriptCore/runtime/Options.h b/Source/JavaScriptCore/runtime/Options.h
index 7eda20f5a5d7..26246097e4a6 100644
--- a/Source/JavaScriptCore/runtime/Options.h
+++ b/Source/JavaScriptCore/runtime/Options.h
@@ -393,7 +393,7 @@ constexpr bool enableWebAssemblyStreamingApi = false;
     v(bool, sweepSynchronously, false, Normal, "debugging option to sweep all dead objects synchronously at GC end before resuming mutator") \
     v(unsigned, maxSingleAllocationSize, 0, Configurable, "debugging option to limit individual allocations to a max size (0 = limit not set, N = limit size in bytes)") \
     \
-    v(gcLogLevel, logGC, GCLogging::None, Normal, "debugging option to log GC activity (0 = None, 1 = Basic, 2 = Verbose)") \
+    v(gcLogLevel, logGC, GCLogging::Verbose, Normal, "debugging option to log GC activity (0 = None, 1 = Basic, 2 = Verbose)") \
     v(bool, useGC, true, Normal, nullptr) \
     v(bool, gcAtEnd, false, Normal, "If true, the jsc CLI will do a GC before exiting") \
     v(bool, forceGCSlowPaths, false, Normal, "If true, we will force all JIT fast allocations down their slow paths.") \
diff --git a/Source/JavaScriptCore/runtime/Structure.cpp b/Source/JavaScriptCore/runtime/Structure.cpp
index 58d83bce4afd..4216ef71cf1c 100644
--- a/Source/JavaScriptCore/runtime/Structure.cpp
+++ b/Source/JavaScriptCore/runtime/Structure.cpp
@@ -374,7 +374,7 @@ PropertyTable* Structure::materializePropertyTable(VM& vm, bool setPropertyTable
     InferredTypeTable* typeTable = m_inferredTypeTable.get();
 
     for (size_t i = structures.size(); i--;) {
-        structure = structures[i];
+        Structure* structure = structures[i];
         if (!structure->m_nameInPrevious)
             continue;
         PropertyMapEntry entry(structure->m_nameInPrevious.get(), structure->m_offset, structure->attributesInPrevious());
diff --git a/Source/JavaScriptCore/runtime/VM.cpp b/Source/JavaScriptCore/runtime/VM.cpp
index f8e7e7fc34f1..74207da39c4a 100644
--- a/Source/JavaScriptCore/runtime/VM.cpp
+++ b/Source/JavaScriptCore/runtime/VM.cpp
@@ -1121,6 +1121,8 @@ void VM::dumpTypeProfilerData()
 
 void VM::queueMicrotask(JSGlobalObject& globalObject, Ref<Microtask>&& task)
 {
+    dataLog("VM::queueMicrotas should not happen!!!! \n");
+    RELEASE_ASSERT(false);
     m_microtaskQueue.append(std::make_unique<QueuedTask>(*this, &globalObject, WTFMove(task)));
 }
 
-- 
2.25.1

