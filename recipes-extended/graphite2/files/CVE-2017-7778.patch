##################################################################
Date: Tue, 1 Jun 2021 19:50:00 +0200
From: vgnana429 <Vijayan_Gnanamoorthy@comcast.com>
Subject: graphite2 changes performed
Source: Comcast
Upstream-Status: NA
Signed-off-by: vgnana429 <Vijayan_Gnanamoorthy@comcast.com>
###################################################################

Index: graphite2-1.3.6/src/CMakeLists.txt
===================================================================
--- graphite2-1.3.6.orig/src/CMakeLists.txt
+++ graphite2-1.3.6/src/CMakeLists.txt
@@ -111,6 +111,9 @@ if  (${CMAKE_SYSTEM_NAME} STREQUAL "Linu
         COMPILE_FLAGS   "-Wall -Wextra -Wno-unknown-pragmas -Wendif-labels -Wshadow -Wctor-dtor-privacy -Wnon-virtual-dtor -fno-rtti -fno-exceptions -fvisibility=hidden -fvisibility-inlines-hidden -fno-stack-protector"
         LINK_FLAGS      "-nodefaultlibs ${GRAPHITE_LINK_FLAGS}" 
         LINKER_LANGUAGE C)
+    if (${CMAKE_SYSTEM_PROCESSOR} MATCHES "x86|i.86")
+        add_definitions(-mfpmath=sse -msse2)
+    endif (${CMAKE_SYSTEM_PROCESSOR} MATCHES "x86|i.86")
     if (CMAKE_COMPILER_IS_GNUCXX)
         add_definitions(-Wdouble-promotion)
     endif (CMAKE_COMPILER_IS_GNUCXX)
@@ -134,8 +137,8 @@ if  (${CMAKE_SYSTEM_NAME} STREQUAL "Linu
 endif (${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
 
 if  (${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
-    set_target_properties(graphite2 PROPERTIES 
-        COMPILE_FLAGS   "-Wall -Wextra -Wno-unknown-pragmas -Wimplicit-fallthrough -Wendif-labels -Wshadow -Wno-ctor-dtor-privacy -Wno-non-virtual-dtor -fno-rtti -fno-exceptions -fvisibility=hidden -fvisibility-inlines-hidden -fno-stack-protector"
+    set_target_properties(graphite2 PROPERTIES
+        COMPILE_FLAGS   "-Wall -Wextra -Wno-unknown-pragmas -Wimplicit-fallthrough -Wendif-labels -Wshadow -Wno-ctor-dtor-privacy -Wno-non-virtual-dtor -fno-rtti -fno-exceptions -fvisibility=hidden -fvisibility-inlines-hidden -fno-stack-protector -mfpmath=sse -msse2"
         LINK_FLAGS      "-nodefaultlibs" 
         LINKER_LANGUAGE C)
     target_link_libraries(graphite2 c)
Index: graphite2-1.3.6/src/Collider.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Collider.cpp
+++ graphite2-1.3.6/src/Collider.cpp
@@ -262,7 +262,7 @@ inline void ShiftCollider::removeBox(con
 // Adjust the movement limits for the target to avoid having it collide
 // with the given neighbor slot. Also determine if there is in fact a collision
 // between the target and the given slot.
-bool ShiftCollider::mergeSlot(Segment *seg, Slot *slot, const Position &currShift,
+bool ShiftCollider::mergeSlot(Segment *seg, Slot *slot, const SlotCollision *cslot, const Position &currShift,
 		bool isAfter,  // slot is logically after _target
 		bool sameCluster, bool &hasCol, bool isExclusion,
         GR_MAYBE_UNUSED json * const dbgout )
@@ -282,7 +282,7 @@ bool ShiftCollider::mergeSlot(Segment *s
         return false;
     const BBox &bb = gc.getBoundingBBox(gid);
 
-    SlotCollision * cslot = seg->collisionInfo(slot);
+    //SlotCollision * cslot = seg->collisionInfo(slot);
     int orderFlags = 0;
     bool sameClass = _seqProxClass == 0 && cslot->seqClass() == _seqClass;
     if (sameCluster && _seqClass 
@@ -306,6 +306,7 @@ bool ShiftCollider::mergeSlot(Segment *s
         float seq_above_wt = cslot->seqAboveWt();
         float seq_below_wt = cslot->seqBelowWt();
         float seq_valign_wt = cslot->seqValignWt();
+	float lmargin = _margin;
         // if isAfter, invert orderFlags for diagonal orders.
         if (isAfter)
         {
@@ -334,6 +335,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                     torg = _currOffset.x;
                     cmin = _limit.bl.x + torg;
                     cmax = _limit.tr.x - tbb.xi + tbb.xa + torg;
+		    lmargin = _margin;
                     break;
                 case 1 :	// y direction
                     vmin = max(max(bb.yi - tbb.ya + sy, tsb.di - sb.da + tx - sd), sb.si - tsb.sa - tx + ss);
@@ -345,6 +347,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                     torg = _currOffset.y;
                     cmin = _limit.bl.y + torg;
                     cmax = _limit.tr.y - tbb.yi + tbb.ya + torg;
+		    lmargin = _margin;
                     break;
                 case 2 :    // sum - moving along the positively-sloped vector, so the boundaries are the
                             // negatively-sloped boundaries.
@@ -357,6 +360,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                     torg = _currOffset.x + _currOffset.y;
                     cmin = _limit.bl.x + _limit.bl.y + torg;
                     cmax = _limit.tr.x + _limit.tr.y - tsb.si + tsb.sa + torg;
+		    lmargin = _margin / ISQRT2;
                     break;
                 case 3 :    // diff - moving along the negatively-sloped vector, so the boundaries are the
                             // positively-sloped boundaries.
@@ -369,6 +373,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                     torg = _currOffset.x - _currOffset.y;
                     cmin = _limit.bl.x - _limit.tr.y + torg;
                     cmax = _limit.tr.x - _limit.bl.y - tsb.di + tsb.da + torg;
+		    lmargin = _margin / ISQRT2;
                     break;
                 default :
                     continue;
@@ -470,7 +475,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                 }
             }
 
-            if (vmax < cmin - _margin || vmin > cmax + _margin || omax < otmin - _margin || omin > otmax + _margin)
+            if (vmax < cmin - lmargin || vmin > cmax + lmargin || omax < otmin - lmargin || omin > otmax + lmargin)
                 continue;
 
             // Process sub-boxes that are defined for this glyph.
@@ -509,7 +514,7 @@ bool ShiftCollider::mergeSlot(Segment *s
                             omax = ssb.sa + ss;
                             break;
                     }
-                    if (vmax < cmin - _margin || vmin > cmax + _margin || omax < otmin - _margin || omin > otmax + _margin)
+                    if (vmax < cmin - lmargin || vmin > cmax + lmargin || omax < otmin - lmargin || omin > otmax + lmargin)
                         continue;
 
 #if !defined GRAPHITE2_NTRACING
@@ -517,11 +522,11 @@ bool ShiftCollider::mergeSlot(Segment *s
                         dbgout->setenv(1, reinterpret_cast<void *>(j));
 #endif
                     if (omin > otmax)
-                        _ranges[i].weightedAxis(i, vmin - _margin, vmax + _margin, 0, 0, 0, 0, 0,
-                                                sqr(_margin - omin + otmax) * _marginWt, false);
+                        _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,
+                                                sqr(lmargin - omin + otmax) * _marginWt, false);
                     else if (omax < otmin)
-                        _ranges[i].weightedAxis(i, vmin - _margin, vmax + _margin, 0, 0, 0, 0, 0,
-                                                sqr(_margin - otmin + omax) * _marginWt, false);
+                        _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,
+                                                sqr(lmargin - otmin + omax) * _marginWt, false);
                     else
                         _ranges[i].exclude_with_margins(vmin, vmax, i);
                     anyhits = true;
@@ -537,11 +542,11 @@ bool ShiftCollider::mergeSlot(Segment *s
 #endif
                 isCol = true;
                 if (omin > otmax)
-                    _ranges[i].weightedAxis(i, vmin - _margin, vmax + _margin, 0, 0, 0, 0, 0,
-                                            sqr(_margin - omin + otmax) * _marginWt, false);
+                    _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,
+                                            sqr(lmargin - omin + otmax) * _marginWt, false);
                 else if (omax < otmin)
-                    _ranges[i].weightedAxis(i, vmin - _margin, vmax + _margin, 0, 0, 0, 0, 0,
-                                            sqr(_margin - otmin + omax) * _marginWt, false);
+                    _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,
+                                            sqr(lmargin - otmin + omax) * _marginWt, false);
                 else
                     _ranges[i].exclude_with_margins(vmin, vmax, i);
 
@@ -556,7 +561,8 @@ bool ShiftCollider::mergeSlot(Segment *s
         exclSlot->setGlyph(seg, cslot->exclGlyph());
         Position exclOrigin(slot->origin() + cslot->exclOffset());
         exclSlot->origin(exclOrigin);
-        res &= mergeSlot(seg, exclSlot, currShift, isAfter, sameCluster, isCol, true, dbgout );
+        SlotCollision exclInfo(seg, exclSlot);
+	res &= mergeSlot(seg, exclSlot, &exclInfo, currShift, isAfter, sameCluster, isCol, true, dbgout );
         seg->freeSlot(exclSlot);
     }
     hasCol |= isCol;
@@ -752,7 +758,7 @@ static float localmin(float al, float au
 }
 
 // Return the given edge of the glyph at height y, taking any slant box into account.
-static float get_edge(Segment *seg, const Slot *s, const Position &shift, float y, float width, bool isRight)
+static float get_edge(Segment *seg, const Slot *s, const Position &shift, float y, float width, float margin, bool isRight)
 {
     const GlyphCache &gc = seg->getFace()->glyphs();
     unsigned short gid = s->gid();
@@ -767,15 +773,15 @@ static float get_edge(Segment *seg, cons
         {
             const BBox &sbb = gc.getSubBoundingBBox(gid, i);
             const SlantBox &ssb = gc.getSubBoundingSlantBox(gid, i);
-            if (sy + sbb.yi > y + width / 2 || sy + sbb.ya < y - width / 2)
+            if (sy + sbb.yi - margin > y + width / 2 || sy + sbb.ya + margin < y - width / 2)
                 continue;
             if (isRight)
             {
-                float x = sx + sbb.xa;
+                float x = sx + sbb.xa + margin;
                 if (x > res)
                 {
-                    float td = sx - sy + ssb.da + y;
-                    float ts = sx + sy + ssb.sa - y;
+                    float td = sx - sy + ssb.da + margin + y;
+                    float ts = sx + sy + ssb.sa + margin - y;
                     x = localmax(td - width / 2, td + width / 2,  ts - width / 2, ts + width / 2, x);
                     if (x > res)
                         res = x;
@@ -783,11 +789,11 @@ static float get_edge(Segment *seg, cons
             }
             else
             {
-                float x = sx + sbb.xi;
+                float x = sx + sbb.xi - margin;
                 if (x < res)
                 {
-                    float td = sx - sy + ssb.di + y;
-                    float ts = sx + sy + ssb.si - y;
+                    float td = sx - sy + ssb.di - margin + y;
+                    float ts = sx + sy + ssb.si - margin - y;
                     x = localmin(td - width / 2, td + width / 2, ts - width / 2, ts + width / 2, x);
                     if (x < res)
                         res = x;
@@ -802,9 +808,9 @@ static float get_edge(Segment *seg, cons
         float td = sx - sy + y;
         float ts = sx + sy - y;
         if (isRight)
-            res = localmax(td + sb.da - width / 2, td + sb.da + width / 2, ts + sb.sa - width / 2, ts + sb.sa + width / 2, sx + bb.xa);
+            res = localmax(td + sb.da - width / 2, td + sb.da + width / 2, ts + sb.sa - width / 2, ts + sb.sa + width / 2, sx + bb.xa) + margin;
         else
-            res = localmin(td + sb.di - width / 2, td + sb.di + width / 2, ts + sb.si - width / 2, ts + sb.si + width / 2, sx + bb.xi);
+            res = localmin(td + sb.di - width / 2, td + sb.di + width / 2, ts + sb.si - width / 2, ts + sb.si + width / 2, sx + bb.xi) - margin;
     }
     return res;
 }
@@ -865,6 +871,7 @@ bool KernCollider::initSlot(Segment *seg
                     _edges.pop_back();
             }
         }
+	goto done;
     }
     numSlices = _edges.size();
 
@@ -896,7 +903,7 @@ bool KernCollider::initSlot(Segment *seg
             float y = _miny - 1 + (i + .5f) * _sliceWidth; // vertical center of slice
             if ((dir & 1) && x < _edges[i])
             {
-                t = get_edge(seg, s, c->shift(), y, _sliceWidth, false);
+                t = get_edge(seg, s, c->shift(), y, _sliceWidth, margin, false);
                 if (t < _edges[i])
                 {
                     _edges[i] = t;
@@ -906,7 +913,7 @@ bool KernCollider::initSlot(Segment *seg
             }
             else if (!(dir & 1) && x > _edges[i])
             {
-                t = get_edge(seg, s, c->shift(), y, _sliceWidth, true);
+                t = get_edge(seg, s, c->shift(), y, _sliceWidth, margin, true);
                 if (t > _edges[i])
                 {
                     _edges[i] = t;
@@ -916,6 +923,7 @@ bool KernCollider::initSlot(Segment *seg
             }
         }
     }
+done:
     _mingap = (float)1e38;
     _target = aSlot;
     _margin = margin;
@@ -948,12 +956,13 @@ bool KernCollider::mergeSlot(Segment *se
     for (int i = smin; i <= smax; ++i)
     {
         float t;
+	float here = _edges[i] * rtl;
         float y = (float)(_miny - 1 + (i + .5f) * _sliceWidth);  // vertical center of slice
         if (x * rtl > _edges[i] * rtl - _mingap - currSpace)
         {
             // 2 * currSpace to account for the space that is already separating them and the space we want to add
-            float m = get_edge(seg, slot, currShift, y, _sliceWidth, rtl > 0) + 2 * rtl * currSpace;
-            t = rtl * (_edges[i] - m);
+            float m = get_edge(seg, slot, currShift, y, _sliceWidth, 0., rtl > 0) * rtl + 2 * currSpace;
+            t = here - m;
             // Check slices above and below (if any).
             if (i < (int)_edges.size() - 1) t = min(t, rtl * (_edges[i+1] - m));
             if (i > 0) t = min(t, rtl * (_edges[i-1] - m));
@@ -980,9 +989,10 @@ bool KernCollider::mergeSlot(Segment *se
 
 // Return the amount to kern by.
 Position KernCollider::resolve(GR_MAYBE_UNUSED Segment *seg, GR_MAYBE_UNUSED Slot *slot,
-        int dir, float margin, GR_MAYBE_UNUSED json * const dbgout)
+        int dir, GR_MAYBE_UNUSED json * const dbgout)
 {
-    float resultNeeded = (1 - 2 * (dir & 1)) * (_mingap - margin);
+    float resultNeeded = (1 - 2 * (dir & 1)) * _mingap;
+    //float resultNeeded = (1 - 2 * (dir & 1)) * (_mingap - margin);
     float result = min(_limit.tr.x - _offsetPrev.x, max(resultNeeded, _limit.bl.x - _offsetPrev.x));
 
 #if !defined GRAPHITE2_NTRACING
@@ -991,7 +1001,6 @@ Position KernCollider::resolve(GR_MAYBE_
         *dbgout << json::object // slot
                 << "slot" << objectid(dslot(seg, _target))
 				<< "gid" << _target->gid()
-                << "margin" << _margin
                 << "limit" << _limit
                 << "miny" << _miny
                 << "maxy" << _maxy
@@ -1086,3 +1095,7 @@ float SlotCollision::getKern(int dir) co
     	return 0;
 }
 
+bool SlotCollision::ignore() const
+{
+	return ((flags() & SlotCollision::COLL_IGNORE) || (flags() & SlotCollision::COLL_ISSPACE));
+}
Index: graphite2-1.3.6/src/Decompressor.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Decompressor.cpp
+++ graphite2-1.3.6/src/Decompressor.cpp
@@ -51,7 +51,7 @@ bool read_sequence(u8 const * &src, u8 c
     literal = src;
     src += literal_len;
     
-    if (src > end - 2)
+    if (src > end - 2 || src < literal)
         return false;
     
     match_dist  = *src++;
@@ -85,7 +85,7 @@ int lz4::decompress(void const *in, size
         {
             // Copy in literal. At this point the last full sequence must be at
             // least MINMATCH + 5 from the end of the output buffer.
-            if (dst + align(literal_len) > dst_end - (MINMATCH+5))
+            if (align(literal_len) > unsigned(dst_end - dst - (MINMATCH+5)) || dst_end - dst < MINMATCH + 5)
                 return -1;
             dst = overrun_copy(dst, literal, literal_len);
         }
@@ -94,7 +94,9 @@ int lz4::decompress(void const *in, size
         //  decoded output.
         u8 const * const pcpy = dst - match_dist;
         if (pcpy < static_cast<u8*>(out)
-                  || dst + match_len + MINMATCH > dst_end - 5)
+                  || pcpy >= dst
+		  || match_len > unsigned(dst_end - dst - (MINMATCH+5))
+		  || dst_end - dst < MINMATCH + 5)
             return -1;
         if (dst > pcpy+sizeof(unsigned long) 
             && dst + align(match_len + MINMATCH) <= dst_end)
@@ -103,8 +105,8 @@ int lz4::decompress(void const *in, size
             dst = safe_copy(dst, pcpy, match_len + MINMATCH);
     }
     
-    if (literal + literal_len > src_end
-              || dst + literal_len > dst_end)
+    if (literal_len > src_end - literal
+              || literal_len > dst_end - dst)
         return -1;
     dst = fast_copy(dst, literal, literal_len);
     
Index: graphite2-1.3.6/src/Face.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Face.cpp
+++ graphite2-1.3.6/src/Face.cpp
@@ -189,9 +189,10 @@ bool Face::runGraphite(Segment *seg, con
 #if !defined GRAPHITE2_NTRACING
     if (dbgout)
 {
-        seg->positionSlots(0, 0, 0, aSilf->dir());
+        seg->positionSlots(0, 0, 0, seg->currdir());
         *dbgout             << json::item
                             << json::close // Close up the passes array
+                << "outputdir" << (seg->currdir() ? "rtl" : "ltr")
                 << "output" << json::array;
         for(Slot * s = seg->first(); s; s = s->next())
             *dbgout     << dslot(seg, s);
Index: graphite2-1.3.6/src/FeatureMap.cpp
===================================================================
--- graphite2-1.3.6.orig/src/FeatureMap.cpp
+++ graphite2-1.3.6/src/FeatureMap.cpp
@@ -275,7 +275,8 @@ bool FeatureRef::applyValToFeature(uint3
     else
       if (pDest.m_pMap!=&m_pFace->theSill().theFeatureMap())
         return false;       //incompatible
-    pDest.reserve(m_index);
+    if (m_index >= pDest.size())
+        pDest.resize(m_index+1);
     pDest[m_index] &= ~m_mask;
     pDest[m_index] |= (uint32(val) << m_bits);
     return true;
Index: graphite2-1.3.6/src/GlyphCache.cpp
===================================================================
--- graphite2-1.3.6.orig/src/GlyphCache.cpp
+++ graphite2-1.3.6/src/GlyphCache.cpp
@@ -375,12 +375,16 @@ const GlyphFace * GlyphCache::Loader::re
         be::skip<uint16>(gloc,2);
         if (_long_fmt)
         {
+            if (8 + glyphid * sizeof(uint32) > m_pGloc.size())
+                return 0;
             be::skip<uint32>(gloc, glyphid);
             glocs = be::read<uint32>(gloc);
             gloce = be::peek<uint32>(gloc);
         }
         else
         {
+            if (8 + glyphid * sizeof(uint16) > m_pGloc.size())
+                return 0;
             be::skip<uint16>(gloc, glyphid);
             glocs = be::read<uint16>(gloc);
             gloce = be::peek<uint16>(gloc);
Index: graphite2-1.3.6/src/Intervals.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Intervals.cpp
+++ graphite2-1.3.6/src/Intervals.cpp
@@ -59,7 +59,9 @@ Zones::Exclusion & Zones::Exclusion::ope
 inline
 uint8 Zones::Exclusion::outcode(float val) const {
     float p = val;
-    return ((p >= xm) << 1) | (p < x);
+    //float d = std::numeric_limits<float>::epsilon();
+    float d = 0.;
+    return ((p - xm >= d) << 1) | (x - p > d);
 }
 
 void Zones::exclude_with_margins(float xmin, float xmax, int axis) {
@@ -74,6 +76,9 @@ namespace
 inline
 bool separated(float a, float b) {
     return a != b;
+    //int exp;
+    //float res = frexpf(fabs(a - b), &exp);
+    //return (*(unsigned int *)(&res) > 4);
     //return std::fabs(a-b) > std::numeric_limits<float>::epsilon(); // std::epsilon may not work. but 0.5 fails exising 64 bit tests
     //return std::fabs(a-b) > 0.5f;
 }
Index: graphite2-1.3.6/src/Pass.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Pass.cpp
+++ graphite2-1.3.6/src/Pass.cpp
@@ -171,7 +171,7 @@ bool Pass::readPass(const byte * const p
     const uint16 * const o_actions = reinterpret_cast<const uint16 *>(p);
     be::skip<uint16>(p, m_numRules + 1);
     const byte * const states = p;
-    if (e.test(p + 2u*m_numTransition*m_numColumns >= pass_end, E_BADPASSLENGTH)) return face.error(e);
+    if (e.test(2u*m_numTransition*m_numColumns >= (unsigned)(pass_end - p), E_BADPASSLENGTH)) return face.error(e);
     be::skip<int16>(p, m_numTransition*m_numColumns);
     be::skip<uint8>(p);
     if (e.test(p != pcCode, E_BADPASSCCODEPTR)) return face.error(e);
@@ -192,7 +192,7 @@ bool Pass::readPass(const byte * const p
         m_cPConstraint = vm::Machine::Code(true, pcCode, pcCode + pass_constraint_len, 
                                   precontext[0], be::peek<uint16>(sort_keys), *m_silf, face, PASS_TYPE_UNKNOWN);
         if (e.test(!m_cPConstraint, E_OUTOFMEM)
-                || e.test(!m_cPConstraint, m_cPConstraint.status() + E_CODEFAILURE))
+                || e.test(m_cPConstraint.status() != Code::loaded, m_cPConstraint.status() + E_CODEFAILURE))
             return face.error(e);
         face.error_context(face.error_context() - 1);
     }
@@ -518,7 +518,7 @@ void Pass::findNDoRule(Slot * & slot, Ma
                 if (r != re)
                 {
                     const int adv = doAction(r->rule->action, slot, m);
-                    dumpRuleEventOutput(fsm, m, *r->rule, slot);
+                    dumpRuleEventOutput(fsm, *r->rule, slot);
                     if (r->rule->action->deletes()) fsm.slots.collectGarbage(slot);
                     adjustSlot(adv, slot, fsm.slots);
                     *fsm.dbgout << "cursor" << objectid(dslot(&fsm.slots.segment, slot))
@@ -574,7 +574,7 @@ void Pass::dumpRuleEventConsidered(const
 }
 
 
-void Pass::dumpRuleEventOutput(const FiniteStateMachine & fsm, Machine & m, const Rule & r, Slot * const last_slot) const
+void Pass::dumpRuleEventOutput(const FiniteStateMachine & fsm, const Rule & r, Slot * const last_slot) const
 {
     *fsm.dbgout     << json::item << json::flat << json::object
                         << "id"     << &r - m_rules
@@ -592,7 +592,7 @@ void Pass::dumpRuleEventOutput(const Fin
                     << json::close // close "input"
                     << "slots"  << json::array;
     const Position rsb_prepos = last_slot ? last_slot->origin() : fsm.slots.segment.advance();
-    fsm.slots.segment.positionSlots(0, 0, 0, m.slotMap().dir());
+    fsm.slots.segment.positionSlots(0, 0, 0, fsm.slots.segment.currdir());
 
     for(Slot * slot = output_slot(fsm.slots, 0); slot != last_slot; slot = slot->next())
         *fsm.dbgout     << dslot(&fsm.slots.segment, slot);
@@ -872,8 +872,11 @@ bool Pass::collisionKern(Segment *seg, i
         const SlotCollision * c = seg->collisionInfo(s);
         const Rect &bbox = seg->theGlyphBBoxTemporary(s->gid());
         float y = s->origin().y + c->shift().y;
-        ymax = max(y + bbox.tr.y, ymax);
-        ymin = min(y + bbox.bl.y, ymin);
+        if (!(c->flags() & SlotCollision::COLL_ISSPACE))
+        {
+            ymax = max(y + bbox.tr.y, ymax);
+            ymin = min(y + bbox.bl.y, ymin);
+        }
         if (start && (c->flags() & (SlotCollision::COLL_KERN | SlotCollision::COLL_FIX))
                         == (SlotCollision::COLL_KERN | SlotCollision::COLL_FIX))
             resolveKern(seg, s, start, kerncoll, dir, ymin, ymax, dbgout);
@@ -955,8 +958,8 @@ bool Pass::resolveCollisions(Segment *se
     {
         SlotCollision *cNbor = seg->collisionInfo(nbor);
         bool sameCluster = nbor->isChildOf(base);
-        if (nbor != slotFix         // don't process if this is the slot of interest
-                      && !(cNbor->flags() & SlotCollision::COLL_IGNORE)    // don't process if ignoring
+        if (nbor != slotFix         						// don't process if this is the slot of interest
+                      && !(cNbor->ignore())    				// don't process if ignoring
                       && (nbor == base || sameCluster       // process if in the same cluster as slotFix
                             || !inKernCluster(seg, nbor)    // or this cluster is not to be kerned
                             || (rtl ^ ignoreForKern))       // or it comes before(ltr) or after(rtl)
@@ -964,7 +967,7 @@ bool Pass::resolveCollisions(Segment *se
                             || !(cNbor->flags() & SlotCollision::COLL_FIX)     // merge in immovable stuff
                             || ((cNbor->flags() & SlotCollision::COLL_KERN) && !sameCluster)     // ignore other kernable clusters
                             || (cNbor->flags() & SlotCollision::COLL_ISCOL))   // test against other collided glyphs
-                      && !coll.mergeSlot(seg, nbor, cNbor->shift(), !ignoreForKern, sameCluster, collides, false, dbgout))
+                      && !coll.mergeSlot(seg, nbor, cNbor, cNbor->shift(), !ignoreForKern, sameCluster, collides, false, dbgout))
             return false;
         else if (nbor == slotFix)
             // Switching sides of this glyph - if we were ignoring kernable stuff before, don't anymore.
@@ -1044,7 +1047,7 @@ float Pass::resolveKern(Segment *seg, Sl
             return 0.;
         const Rect &bb = seg->theGlyphBBoxTemporary(nbor->gid());
         SlotCollision *cNbor = seg->collisionInfo(nbor);
-        if (bb.bl.y == 0.f && bb.tr.y == 0.f)
+        if ((bb.bl.y == 0.f && bb.tr.y == 0.f) || (cNbor->flags() & SlotCollision::COLL_ISSPACE))
         {
             if (m_kernColls == InWord)
                 break;
@@ -1058,7 +1061,7 @@ float Pass::resolveKern(Segment *seg, Sl
             float y = nbor->origin().y + cNbor->shift().y;
             ymax = max(y + bb.tr.y, ymax);
             ymin = min(y + bb.bl.y, ymin);
-            if (nbor != slotFix && !(cNbor->flags() & SlotCollision::COLL_IGNORE))
+            if (nbor != slotFix && !cNbor->ignore())
             {
                 seenEnd = true;
                 if (!isInit)
@@ -1081,7 +1084,7 @@ float Pass::resolveKern(Segment *seg, Sl
     }
     if (collides)
     {
-        Position mv = coll.resolve(seg, slotFix, dir, cFix->margin(), dbgout);
+        Position mv = coll.resolve(seg, slotFix, dir, dbgout);
         coll.shift(mv, dir);
         Position delta = slotFix->advancePos() + mv - cFix->shift();
         slotFix->advance(delta);
Index: graphite2-1.3.6/src/Segment.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Segment.cpp
+++ graphite2-1.3.6/src/Segment.cpp
@@ -412,8 +412,9 @@ Position Segment::positionSlots(const Fo
     Position currpos(0., 0.);
     float clusterMin = 0.;
     Rect bbox;
+    bool reorder = (currdir() != isRtl);
 
-    if (currdir() != isRtl)
+    if (reorder)
     {
         Slot *temp;
         reverseSlots();
@@ -440,6 +441,8 @@ Position Segment::positionSlots(const Fo
                 currpos = s->finalise(this, font, currpos, bbox, 0, clusterMin = currpos.x, isRtl, isFinal);
         }
     }
+    if (reorder)
+        reverseSlots();
     return currpos;
 }
 
Index: graphite2-1.3.6/src/inc/Collider.h
===================================================================
--- graphite2-1.3.6.orig/src/inc/Collider.h
+++ graphite2-1.3.6/src/inc/Collider.h
@@ -54,7 +54,8 @@ public:
         COLL_KERN = 16,     // collisions with this glyph are fixed by adding kerning space after it
         COLL_ISCOL = 32,    // this glyph has a collision
         COLL_KNOWN = 64,    // we've figured out what's happening with this glyph
-        COLL_TEMPLOCK = 128,    // Lock glyphs that have been given priority positioning
+        COLL_ISSPACE = 128,		// treat this glyph as a space with regard to kerning
+	COLL_TEMPLOCK = 256,    // Lock glyphs that have been given priority positioning
         ////COLL_JUMPABLE = 128,    // moving glyphs may jump this stationary glyph in any direction - DELETE
         ////COLL_OVERLAP = 256,    // use maxoverlap to restrict - DELETE
     };
@@ -93,6 +94,7 @@ public:
     SLOTCOLSETUINTPROP(seqValignWt, setSeqValignWt)
 
     float getKern(int dir) const;
+    bool ignore() const;
     
 private:
     Rect        _limit;
@@ -131,8 +133,8 @@ public:
     bool initSlot(Segment *seg, Slot *aSlot, const Rect &constraint,
                 float margin, float marginMin, const Position &currShift,
                 const Position &currOffset, int dir, GR_MAYBE_UNUSED json * const dbgout);
-    bool mergeSlot(Segment *seg, Slot *slot, const Position &currShift, bool isAfter, 
-                bool sameCluster, bool &hasCol, bool isExclusion, GR_MAYBE_UNUSED json * const dbgout);
+    bool mergeSlot(Segment *seg, Slot *slot, const SlotCollision *cinfo, const Position &currShift, bool isAfter,
+		bool sameCluster, bool &hasCol, bool isExclusion, GR_MAYBE_UNUSED json * const dbgout);
     Position resolve(Segment *seg, bool &isCol, GR_MAYBE_UNUSED json * const dbgout);
     void addBox_slope(bool isx, const Rect &box, const BBox &bb, const SlantBox &sb, const Position &org, float weight, float m, bool minright, int mode);
     void removeBox(const Rect &box, const BBox &bb, const SlantBox &sb, const Position &org, int mode);
@@ -191,7 +193,7 @@ public:
             const Position &currShift, const Position &offsetPrev, int dir,
             float ymin, float ymax, json * const dbgout);
     bool mergeSlot(Segment *seg, Slot *slot, const Position &currShift, float currSpace, int dir, json * const dbgout);
-    Position resolve(Segment *seg, Slot *slot, int dir, float margin, json * const dbgout);
+    Position resolve(Segment *seg, Slot *slot, int dir, json * const dbgout);
     void shift(const Position &mv, int dir);
 
     CLASS_NEW_DELETE;
Index: graphite2-1.3.6/src/inc/locale2lcid.h
===================================================================
--- graphite2-1.3.6.orig/src/inc/locale2lcid.h
+++ graphite2-1.3.6/src/inc/locale2lcid.h
@@ -36,8 +36,8 @@ namespace graphite2 {
 struct IsoLangEntry
 {
     unsigned short mnLang;
-    const char maLangStr[4];
-    const char maCountry[3];
+    char maLangStr[4];
+    char maCountry[3];
 };
 
 // Windows Language ID, Locale ISO-639 language, country code as used in
Index: graphite2-1.3.6/src/inc/Pass.h
===================================================================
--- graphite2-1.3.6.orig/src/inc/Pass.h
+++ graphite2-1.3.6/src/inc/Pass.h
@@ -74,7 +74,7 @@ private:
     uint16  glyphToCol(const uint16 gid) const;
     bool    runFSM(FiniteStateMachine & fsm, Slot * slot) const;
     void    dumpRuleEventConsidered(const FiniteStateMachine & fsm, const RuleEntry & re) const;
-    void    dumpRuleEventOutput(const FiniteStateMachine & fsm, vm::Machine & m, const Rule & r, Slot * os) const;
+    void    dumpRuleEventOutput(const FiniteStateMachine & fsm, const Rule & r, Slot * os) const;
     void    adjustSlot(int delta, Slot * & slot_out, SlotMap &) const;
     bool    collisionShift(Segment *seg, int dir, json * const dbgout) const;
     bool    collisionKern(Segment *seg, int dir, json * const dbgout) const;
Index: graphite2-1.3.6/src/inc/UtfCodec.h
===================================================================
--- graphite2-1.3.6.orig/src/inc/UtfCodec.h
+++ graphite2-1.3.6/src/inc/UtfCodec.h
@@ -109,6 +109,7 @@ private:
     static const int8 sz_lut[16];
     static const byte mask_lut[5];
 
+    static const uchar_t    limit = 0x110000;
 
 public:
     typedef uint8   codeunit_t;
@@ -141,7 +142,7 @@ public:
             case 0:     l = -1; return 0xFFFD;
         }
 
-        if (l != seq_sz || toolong)
+        if (l != seq_sz || toolong  || u >= limit)
         {
             l = -l;
             return 0xFFFD;
Index: graphite2-1.3.6/src/Silf.cpp
===================================================================
--- graphite2-1.3.6.orig/src/Silf.cpp
+++ graphite2-1.3.6/src/Silf.cpp
@@ -155,8 +155,8 @@ bool Silf::readGraphite(const byte * con
     be::skip<uint32>(p, be::read<uint8>(p));    // don't use scriptTag array.
     if (e.test(p + sizeof(uint16) + sizeof(uint32) >= silf_end, E_BADSCRIPTTAGS)) { releaseBuffers(); return face.error(e); }
     m_gEndLine  = be::read<uint16>(p);          // lbGID
-    const byte * o_passes = p,
-               * const passes_start = silf_start + be::read<uint32>(p);
+    const byte * o_passes = p;
+    uint32 passes_start = be::read<uint32>(p);
 
     const size_t num_attrs = face.glyphs().numAttrs();
     if (e.test(m_aPseudo   >= num_attrs, E_BADAPSEUDO)
@@ -164,7 +164,7 @@ bool Silf::readGraphite(const byte * con
         || e.test(m_aBidi  >= num_attrs, E_BADABIDI)
         || e.test(m_aMirror>= num_attrs, E_BADAMIRROR)
         || e.test(m_aCollision && m_aCollision >= num_attrs - 5, E_BADACOLLISION)
-        || e.test(m_numPasses > 128, E_BADNUMPASSES) || e.test(passes_start >= silf_end, E_BADPASSESSTART)
+        || e.test(m_numPasses > 128, E_BADNUMPASSES) || e.test(passes_start >= lSilf, E_BADPASSESSTART)
         || e.test(m_pPass < m_sPass, E_BADPASSBOUND) || e.test(m_pPass > m_numPasses, E_BADPPASS) || e.test(m_sPass > m_numPasses, E_BADSPASS)
         || e.test(m_jPass < m_pPass, E_BADJPASSBOUND) || e.test(m_jPass > m_numPasses, E_BADJPASS)
         || e.test((m_bPass != 0xFF && (m_bPass < m_jPass || m_bPass > m_numPasses)), E_BADBPASS)
@@ -174,11 +174,11 @@ bool Silf::readGraphite(const byte * con
         return face.error(e);
     }
     be::skip<uint32>(p, m_numPasses);
-    if (e.test(p + sizeof(uint16) >= passes_start, E_BADPASSESSTART)) { releaseBuffers(); return face.error(e); }
+    if (e.test(unsigned(p - silf_start) + sizeof(uint16) >= passes_start, E_BADPASSESSTART)) { releaseBuffers(); return face.error(e); }
     m_numPseudo = be::read<uint16>(p);
     be::skip<uint16>(p, 3); // searchPseudo, pseudoSelector, pseudoShift
     m_pseudos = new Pseudo[m_numPseudo];
-    if (e.test(p + m_numPseudo*(sizeof(uint32) + sizeof(uint16)) >= passes_start, E_BADNUMPSEUDO)
+    if (e.test(unsigned(p - silf_start) + m_numPseudo*(sizeof(uint32) + sizeof(uint16)) >= passes_start, E_BADNUMPSEUDO)
         || e.test(!m_pseudos, E_OUTOFMEM))
     {
         releaseBuffers(); return face.error(e);
@@ -189,20 +189,20 @@ bool Silf::readGraphite(const byte * con
         m_pseudos[i].gid = be::read<uint16>(p);
     }
 
-    const size_t clen = readClassMap(p, passes_start - p, version, e);
+    const size_t clen = readClassMap(p, passes_start + silf_start - p, version, e);
     m_passes = new Pass[m_numPasses];
-    if (e || e.test(p + clen > passes_start, E_BADPASSESSTART)
+    if (e || e.test(clen > unsigned(passes_start + silf_start - p), E_BADPASSESSTART)
           || e.test(!m_passes, E_OUTOFMEM))
     { releaseBuffers(); return face.error(e); }
 
     for (size_t i = 0; i < m_numPasses; ++i)
     {
-        const byte * const pass_start = silf_start + be::read<uint32>(o_passes),
-                   * const pass_end = silf_start + be::peek<uint32>(o_passes);
+        uint32 pass_start = be::read<uint32>(o_passes);
+        uint32 pass_end = be::peek<uint32>(o_passes);
         face.error_context((face.error_context() & 0xFF00) + EC_ASILF + (i << 16));
         if (e.test(pass_start > pass_end, E_BADPASSSTART) 
                 || e.test(pass_start < passes_start, E_BADPASSSTART)
-                || e.test(pass_end > silf_end, E_BADPASSEND)) {
+                || e.test(pass_end > lSilf, E_BADPASSEND)) {
             releaseBuffers(); return face.error(e);
         }
 
@@ -213,7 +213,7 @@ bool Silf::readGraphite(const byte * con
         else pt = PASS_TYPE_LINEBREAK;
 
         m_passes[i].init(this);
-        if (!m_passes[i].readPass(pass_start, pass_end - pass_start, pass_start - silf_start, face, pt,
+        if (!m_passes[i].readPass(silf_start + pass_start, pass_end - pass_start, pass_start, face, pt,
             version, e))
         {
             releaseBuffers();
@@ -293,7 +293,8 @@ size_t Silf::readClassMap(const byte *p,
         if (e.test(*o + 4 > max_off, E_HIGHCLASSOFFSET)                        // LookupClass doesn't stretch over max_off
          || e.test(lookup[0] == 0                                                   // A LookupClass with no looks is a suspicious thing ...
                     || lookup[0] * 2 + *o + 4 > max_off                             // numIDs lookup pairs fits within (start of LookupClass' lookups array, max_off]
-                    || lookup[3] + lookup[1] != lookup[0], E_BADCLASSLOOKUPINFO))   // rangeShift:   numIDs  - searchRange
+                    || lookup[3] + lookup[1] != lookup[0], E_BADCLASSLOOKUPINFO)    // rangeShift:   numIDs  - searchRange
+         || e.test(((o[1] - *o) & 1) != 0, ERROROFFSET))                         // glyphs are in pairs so difference must be even.
             return ERROROFFSET;
     }
 
@@ -384,9 +385,12 @@ bool Silf::runGraphite(Segment *seg, uin
             if (dbgout)
             {
                 *dbgout << json::item << json::object
+//							<< "pindex" << i   // for debugging
                             << "id"     << -1
-                            << "slots"  << json::array;
-                seg->positionSlots(0, 0, 0, m_dir);
+                            << "slotsdir" << (seg->currdir() ? "rtl" : "ltr")
+                            << "passdir" << (m_dir & 1 ? "rtl" : "ltr")
+  			    << "slots"  << json::array;
+                seg->positionSlots(0, 0, 0, seg->currdir());
                 for(Slot * s = seg->first(); s; s = s->next())
                     *dbgout     << dslot(seg, s);
                 *dbgout         << json::close
@@ -408,9 +412,12 @@ bool Silf::runGraphite(Segment *seg, uin
         if (dbgout)
         {
             *dbgout << json::item << json::object
+//						<< "pindex" << i   // for debugging
                         << "id"     << i+1
+                        << "slotsdir" << (seg->currdir() ? "rtl" : "ltr")
+                        << "passdir" << ((m_dir & 1) ^ m_passes[i].reverseDir() ? "rtl" : "ltr")
                         << "slots"  << json::array;
-            seg->positionSlots(0, 0, 0, m_dir);
+	    seg->positionSlots(0, 0, 0, seg->currdir());
             for(Slot * s = seg->first(); s; s = s->next())
                 *dbgout     << dslot(seg, s);
             *dbgout         << json::close;
