Date: Nov 19 08:40:26 2015

From: 9267950d03026cf174010f115c5a9722124c82cb Nov 20 19:34:58 2015

Subject: [PATCH] WKIT-388 : Upgrade gstreamer isomp4 plugin to version 1.6.1

	Update just the isomp4 plugin (used mainly for mse demuxing)
	This brings in bug fixes and better seeking support and also
	lines us up with the current webkit-wayland master.

	Metro's patches can also be applied cleanly now and are added
	in this commit.

	Biggest risk is the removal/changes to the isomp4 plugin so it
	works in a 1.4.4 install.  Applied with the
	0002-isomp4-1_6_1-compile-fixes.patch.

	This gets seeking working really well on the ubuntu desktop.
	Seeking both in and out of the currently buffered data seems
	to work well, with some rare stuck in spinner cases.
	Xi3 still has issues most likely related to soc plugins
	that still need to be investigated.

Source: COMCAST


Upstream-Status: Pending

Signed-off-by: mzuber <Mark_Zuber@cable.comcast.com>
---

diff --git a/gst/isomp4/Makefile.am b/gst/isomp4/Makefile.am
index 84dbbfc..8cfdd15 100644
--- a/gst/isomp4/Makefile.am
+++ b/gst/isomp4/Makefile.am
@@ -10,12 +10,12 @@ libgstisomp4_la_LIBADD = \
     -lgstrtp-@GST_API_VERSION@ \
     -lgsttag-@GST_API_VERSION@ \
     -lgstpbutils-@GST_API_VERSION@ \
-    $(GST_BASE_LIBS) $(GST_LIBS) $(ZLIB_LIBS) $(LIBM)
+    $(GST_BASE_LIBS) $(GST_LIBS) $(ZLIB_LIBS)
 libgstisomp4_la_LDFLAGS = ${GST_PLUGIN_LDFLAGS}
 libgstisomp4_la_SOURCES = isomp4-plugin.c gstrtpxqtdepay.c \
 	qtdemux.c qtdemux_types.c qtdemux_dump.c qtdemux_lang.c \
 	gstqtmux.c gstqtmoovrecover.c atoms.c atomsrecovery.c descriptors.c \
-	properties.c gstqtmuxmap.c
+	properties.c gstqtmuxmap.c gstisoff.c
 libgstisomp4_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
 
 noinst_HEADERS = \
@@ -33,22 +33,9 @@ noinst_HEADERS = \
 	descriptors.h    \
 	properties.h     \
 	fourcc.h         \
+	gstisoff.h       \
 	gstqtmuxmap.h
 
 EXTRA_DIST = \
 	gstqtmux-doc.c \
 	gstqtmux-doc.h
-
-Android.mk: Makefile.am $(BUILT_SOURCES)
-	androgenizer \
-	-:PROJECT libgstisomp4 -:SHARED libgstisomp4 \
-	 -:TAGS eng debug \
-         -:REL_TOP $(top_srcdir) -:ABS_TOP $(abs_top_srcdir) \
-	 -:SOURCES $(libgstisomp4_la_SOURCES) \
-	 -:CFLAGS $(DEFS) $(DEFAULT_INCLUDES) $(CPPFLAGS) $(libgstisomp4_la_CFLAGS) \
-	 -:LDFLAGS $(libgstisomp4_la_LDFLAGS) \
-	           $(libgstisomp4_la_LIBADD) \
-	           -ldl \
-	 -:PASSTHROUGH LOCAL_ARM_MODE:=arm \
-		       LOCAL_MODULE_PATH:='$$(TARGET_OUT)/lib/gstreamer-0.10' \
-	> $@
diff --git a/gst/isomp4/atoms.c b/gst/isomp4/atoms.c
index 3f1051c..267c4f0 100644
--- a/gst/isomp4/atoms.c
+++ b/gst/isomp4/atoms.c
@@ -48,8 +48,9 @@
 #include <gst/gst.h>
 #include <gst/base/gstbytewriter.h>
 #include <gst/tag/tag.h>
+#include <gst/video/video.h>
 
-/**
+/*
  * Creates a new AtomsContext for the given flavor.
  */
 AtomsContext *
@@ -60,7 +61,7 @@ atoms_context_new (AtomsTreeFlavor flavor)
   return context;
 }
 
-/**
+/*
  * Frees an AtomsContext and all memory associated with it
  */
 void
@@ -195,14 +196,22 @@ atom_data_new (guint32 fourcc)
 static void
 atom_data_alloc_mem (AtomData * data, guint32 size)
 {
-  if (data->data) {
-    g_free (data->data);
-  }
+  g_free (data->data);
   data->data = g_new0 (guint8, size);
   data->datalen = size;
 }
 
 static AtomData *
+atom_data_new_from_data (guint32 fourcc, const guint8 * mem, gsize size)
+{
+  AtomData *data = atom_data_new (fourcc);
+
+  atom_data_alloc_mem (data, size);
+  memcpy (data->data, mem, size);
+  return data;
+}
+
+static AtomData *
 atom_data_new_from_gst_buffer (guint32 fourcc, const GstBuffer * buf)
 {
   AtomData *data = atom_data_new (fourcc);
@@ -1040,42 +1049,6 @@ atom_tkhd_clear (AtomTKHD * tkhd)
 }
 
 static void
-atom_trak_init (AtomTRAK * trak, AtomsContext * context)
-{
-  atom_header_set (&trak->header, FOURCC_trak, 0, 0);
-
-  atom_tkhd_init (&trak->tkhd, context);
-  trak->edts = NULL;
-  atom_mdia_init (&trak->mdia, context);
-}
-
-AtomTRAK *
-atom_trak_new (AtomsContext * context)
-{
-  AtomTRAK *trak = g_new0 (AtomTRAK, 1);
-
-  atom_trak_init (trak, context);
-  return trak;
-}
-
-static void
-atom_trak_clear (AtomTRAK * trak)
-{
-  atom_clear (&trak->header);
-  atom_tkhd_clear (&trak->tkhd);
-  if (trak->edts)
-    atom_edts_free (trak->edts);
-  atom_mdia_clear (&trak->mdia);
-}
-
-static void
-atom_trak_free (AtomTRAK * trak)
-{
-  atom_trak_clear (trak);
-  g_free (trak);
-}
-
-static void
 atom_ilst_init (AtomILST * ilst)
 {
   atom_header_set (&ilst->header, FOURCC_ilst, 0, 0);
@@ -1134,23 +1107,30 @@ atom_meta_free (AtomMETA * meta)
 }
 
 static void
-atom_udta_init (AtomUDTA * udta)
+atom_udta_init_metatags (AtomUDTA * udta, AtomsContext * context)
 {
-  atom_header_set (&udta->header, FOURCC_udta, 0, 0);
-  udta->meta = NULL;
+  if (context->flavor != ATOMS_TREE_FLAVOR_3GP) {
+    if (!udta->meta) {
+      udta->meta = atom_meta_new (context);
+    }
+    if (!udta->meta->ilst) {
+      udta->meta->ilst = atom_ilst_new ();
+    }
+  }
 }
 
-static AtomUDTA *
-atom_udta_new (void)
+static void
+atom_udta_init (AtomUDTA * udta, AtomsContext * context)
 {
-  AtomUDTA *udta = g_new0 (AtomUDTA, 1);
+  atom_header_set (&udta->header, FOURCC_udta, 0, 0);
+  udta->meta = NULL;
+  udta->context = context;
 
-  atom_udta_init (udta);
-  return udta;
+  atom_udta_init_metatags (udta, context);
 }
 
 static void
-atom_udta_free (AtomUDTA * udta)
+atom_udta_clear (AtomUDTA * udta)
 {
   atom_clear (&udta->header);
   if (udta->meta)
@@ -1158,7 +1138,20 @@ atom_udta_free (AtomUDTA * udta)
   udta->meta = NULL;
   if (udta->entries)
     atom_info_list_free (udta->entries);
-  g_free (udta);
+}
+
+/* Clear added tags, but keep the context/flavor the same */
+void
+atom_udta_clear_tags (AtomUDTA * udta)
+{
+  if (udta->entries) {
+    atom_info_list_free (udta->entries);
+    udta->entries = NULL;
+  }
+  if (udta->meta && udta->meta->ilst->entries) {
+    atom_info_list_free (udta->meta->ilst->entries);
+    udta->meta->ilst->entries = NULL;
+  }
 }
 
 static void
@@ -1253,12 +1246,52 @@ atom_mvex_init (AtomMVEX * mvex)
 }
 
 static void
+atom_trak_init (AtomTRAK * trak, AtomsContext * context)
+{
+  atom_header_set (&trak->header, FOURCC_trak, 0, 0);
+
+  atom_tkhd_init (&trak->tkhd, context);
+  trak->context = context;
+  atom_udta_init (&trak->udta, context);
+  trak->edts = NULL;
+  atom_mdia_init (&trak->mdia, context);
+}
+
+AtomTRAK *
+atom_trak_new (AtomsContext * context)
+{
+  AtomTRAK *trak = g_new0 (AtomTRAK, 1);
+
+  atom_trak_init (trak, context);
+  return trak;
+}
+
+static void
+atom_trak_clear (AtomTRAK * trak)
+{
+  atom_clear (&trak->header);
+  atom_tkhd_clear (&trak->tkhd);
+  if (trak->edts)
+    atom_edts_free (trak->edts);
+  atom_udta_clear (&trak->udta);
+  atom_mdia_clear (&trak->mdia);
+}
+
+static void
+atom_trak_free (AtomTRAK * trak)
+{
+  atom_trak_clear (trak);
+  g_free (trak);
+}
+
+
+static void
 atom_moov_init (AtomMOOV * moov, AtomsContext * context)
 {
   atom_header_set (&(moov->header), FOURCC_moov, 0, 0);
   atom_mvhd_init (&(moov->mvhd));
   atom_mvex_init (&(moov->mvex));
-  moov->udta = NULL;
+  atom_udta_init (&moov->udta, context);
   moov->traks = NULL;
   moov->context = *context;
 }
@@ -1310,11 +1343,7 @@ atom_moov_free (AtomMOOV * moov)
   g_list_free (moov->traks);
   moov->traks = NULL;
 
-  if (moov->udta) {
-    atom_udta_free (moov->udta);
-    moov->udta = NULL;
-  }
-
+  atom_udta_clear (&moov->udta);
   atom_mvex_clear (&moov->mvex);
 
   g_free (moov);
@@ -1721,23 +1750,6 @@ atom_frma_copy_data (AtomFRMA * frma, guint8 ** buffer,
 }
 
 static guint64
-atom_mp4s_copy_data (SampleTableEntryMP4S * mp4s, guint8 ** buffer,
-    guint64 * size, guint64 * offset)
-{
-  guint64 original_offset = *offset;
-
-  if (!atom_sample_entry_copy_data (&mp4s->se, buffer, size, offset)) {
-    return 0;
-  }
-  if (!atom_esds_copy_data (&mp4s->es, buffer, size, offset)) {
-    return 0;
-  }
-
-  atom_write_size (buffer, size, offset, original_offset);
-  return *offset - original_offset;
-}
-
-static guint64
 atom_hint_sample_entry_copy_data (AtomHintSampleEntry * hse, guint8 ** buffer,
     guint64 * size, guint64 * offset)
 {
@@ -1973,12 +1985,13 @@ atom_stco64_copy_data (AtomSTCO64 * stco64, guint8 ** buffer, guint64 * size,
   prop_copy_ensure_buffer (buffer, size, offset,
       8 * atom_array_get_len (&stco64->entries));
   for (i = 0; i < atom_array_get_len (&stco64->entries); i++) {
-    guint64 *value = &atom_array_index (&stco64->entries, i);
+    guint64 value =
+        atom_array_index (&stco64->entries, i) + stco64->chunk_offset;
 
     if (trunc_to_32) {
-      prop_copy_uint32 ((guint32) * value, buffer, size, offset);
+      prop_copy_uint32 ((guint32) value, buffer, size, offset);
     } else {
-      prop_copy_uint64 (*value, buffer, size, offset);
+      prop_copy_uint64 (value, buffer, size, offset);
     }
   }
 
@@ -2039,12 +2052,6 @@ atom_stsd_copy_data (AtomSTSD * stsd, guint8 ** buffer, guint64 * size,
           return 0;
         }
         break;
-      case FOURCC_mp4s:
-        if (!atom_mp4s_copy_data ((SampleTableEntryMP4S *) walker->data,
-                buffer, size, offset)) {
-          return 0;
-        }
-        break;
       case FOURCC_mp4v:
         if (!sample_entry_mp4v_copy_data ((SampleTableEntryMP4V *) walker->data,
                 buffer, size, offset)) {
@@ -2302,32 +2309,6 @@ atom_edts_copy_data (AtomEDTS * edts, guint8 ** buffer, guint64 * size,
   return *offset - original_offset;
 }
 
-guint64
-atom_trak_copy_data (AtomTRAK * trak, guint8 ** buffer, guint64 * size,
-    guint64 * offset)
-{
-  guint64 original_offset = *offset;
-
-  if (!atom_copy_data (&trak->header, buffer, size, offset)) {
-    return 0;
-  }
-  if (!atom_tkhd_copy_data (&trak->tkhd, buffer, size, offset)) {
-    return 0;
-  }
-  if (trak->edts) {
-    if (!atom_edts_copy_data (trak->edts, buffer, size, offset)) {
-      return 0;
-    }
-  }
-
-  if (!atom_mdia_copy_data (&trak->mdia, buffer, size, offset)) {
-    return 0;
-  }
-
-  atom_write_size (buffer, size, offset, original_offset);
-  return *offset - original_offset;
-}
-
 static guint64
 atom_tag_data_copy_data (AtomTagData * data, guint8 ** buffer, guint64 * size,
     guint64 * offset)
@@ -2492,6 +2473,37 @@ atom_mvex_copy_data (AtomMVEX * mvex, guint8 ** buffer, guint64 * size,
 }
 
 guint64
+atom_trak_copy_data (AtomTRAK * trak, guint8 ** buffer, guint64 * size,
+    guint64 * offset)
+{
+  guint64 original_offset = *offset;
+
+  if (!atom_copy_data (&trak->header, buffer, size, offset)) {
+    return 0;
+  }
+  if (!atom_tkhd_copy_data (&trak->tkhd, buffer, size, offset)) {
+    return 0;
+  }
+  if (trak->edts) {
+    if (!atom_edts_copy_data (trak->edts, buffer, size, offset)) {
+      return 0;
+    }
+  }
+
+  if (!atom_mdia_copy_data (&trak->mdia, buffer, size, offset)) {
+    return 0;
+  }
+
+  if (!atom_udta_copy_data (&trak->udta, buffer, size, offset)) {
+    return 0;
+  }
+
+  atom_write_size (buffer, size, offset, original_offset);
+  return *offset - original_offset;
+}
+
+
+guint64
 atom_moov_copy_data (AtomMOOV * atom, guint8 ** buffer, guint64 * size,
     guint64 * offset)
 {
@@ -2512,10 +2524,8 @@ atom_moov_copy_data (AtomMOOV * atom, guint8 ** buffer, guint64 * size,
     walker = g_list_next (walker);
   }
 
-  if (atom->udta) {
-    if (!atom_udta_copy_data (atom->udta, buffer, size, offset)) {
-      return 0;
-    }
+  if (!atom_udta_copy_data (&atom->udta, buffer, size, offset)) {
+    return 0;
   }
 
   if (atom->fragmented) {
@@ -2739,6 +2749,12 @@ atom_moov_add_trak (AtomMOOV * moov, AtomTRAK * trak)
   atom_moov_add_trex (moov, atom_trex_new (trak));
 }
 
+guint
+atom_moov_get_trak_count (AtomMOOV * moov)
+{
+  return g_list_length (moov->traks);
+}
+
 static guint64
 atom_trak_get_duration (AtomTRAK * trak)
 {
@@ -2811,28 +2827,27 @@ atom_moov_set_fragmented (AtomMOOV * moov, gboolean fragmented)
 }
 
 void
-atom_stco64_chunks_add_offset (AtomSTCO64 * stco64, guint32 offset)
+atom_stco64_chunks_set_offset (AtomSTCO64 * stco64, guint32 offset)
 {
-  guint i;
-
-  for (i = 0; i < atom_array_get_len (&stco64->entries); i++) {
-    guint64 *value = &atom_array_index (&stco64->entries, i);
-
-    *value += offset;
-  }
+  stco64->chunk_offset = offset;
 }
 
 void
-atom_moov_chunks_add_offset (AtomMOOV * moov, guint32 offset)
+atom_moov_chunks_set_offset (AtomMOOV * moov, guint32 offset)
 {
   GList *traks = moov->traks;
 
+  if (offset == moov->chunks_offset)
+    return;                     /* Nothing to do */
+
   while (traks) {
     AtomTRAK *trak = (AtomTRAK *) traks->data;
 
-    atom_stco64_chunks_add_offset (&trak->mdia.minf.stbl.stco64, offset);
+    atom_stco64_chunks_set_offset (&trak->mdia.minf.stbl.stco64, offset);
     traks = g_list_next (traks);
   }
+
+  moov->chunks_offset = offset;
 }
 
 void
@@ -2948,22 +2963,6 @@ atom_trak_tx3g_update_dimension (AtomTRAK * trak, guint32 width, guint32 height)
  * Meta tags functions
  */
 static void
-atom_moov_init_metatags (AtomMOOV * moov, AtomsContext * context)
-{
-  if (!moov->udta) {
-    moov->udta = atom_udta_new ();
-  }
-  if (context->flavor != ATOMS_TREE_FLAVOR_3GP) {
-    if (!moov->udta->meta) {
-      moov->udta->meta = atom_meta_new (context);
-    }
-    if (!moov->udta->meta->ilst) {
-      moov->udta->meta->ilst = atom_ilst_new ();
-    }
-  }
-}
-
-static void
 atom_tag_data_alloc_data (AtomTagData * data, guint size)
 {
   if (data->data != NULL) {
@@ -2974,20 +2973,19 @@ atom_tag_data_alloc_data (AtomTagData * data, guint size)
 }
 
 static void
-atom_moov_append_tag (AtomMOOV * moov, AtomInfo * tag)
+atom_udta_append_tag (AtomUDTA * udta, AtomInfo * tag)
 {
   GList **entries;
 
-  atom_moov_init_metatags (moov, &moov->context);
-  if (moov->udta->meta)
-    entries = &moov->udta->meta->ilst->entries;
+  if (udta->meta)
+    entries = &udta->meta->ilst->entries;
   else
-    entries = &moov->udta->entries;
+    entries = &udta->entries;
   *entries = g_list_append (*entries, tag);
 }
 
 void
-atom_moov_add_tag (AtomMOOV * moov, guint32 fourcc, guint32 flags,
+atom_udta_add_tag (AtomUDTA * udta, guint32 fourcc, guint32 flags,
     const guint8 * data, guint size)
 {
   AtomTag *tag;
@@ -2998,53 +2996,43 @@ atom_moov_add_tag (AtomMOOV * moov, guint32 fourcc, guint32 flags,
   atom_tag_data_alloc_data (tdata, size);
   memmove (tdata->data, data, size);
 
-  atom_moov_append_tag (moov,
+  atom_udta_append_tag (udta,
       build_atom_info_wrapper ((Atom *) tag, atom_tag_copy_data,
           atom_tag_free));
 }
 
 void
-atom_moov_add_str_tag (AtomMOOV * moov, guint32 fourcc, const gchar * value)
+atom_udta_add_str_tag (AtomUDTA * udta, guint32 fourcc, const gchar * value)
 {
   gint len = strlen (value);
 
   if (len > 0)
-    atom_moov_add_tag (moov, fourcc, METADATA_TEXT_FLAG, (guint8 *) value, len);
+    atom_udta_add_tag (udta, fourcc, METADATA_TEXT_FLAG, (guint8 *) value, len);
 }
 
 void
-atom_moov_add_uint_tag (AtomMOOV * moov, guint32 fourcc, guint32 flags,
+atom_udta_add_uint_tag (AtomUDTA * udta, guint32 fourcc, guint32 flags,
     guint32 value)
 {
   guint8 data[8] = { 0, };
 
   if (flags) {
     GST_WRITE_UINT16_BE (data, value);
-    atom_moov_add_tag (moov, fourcc, flags, data, 2);
+    atom_udta_add_tag (udta, fourcc, flags, data, 2);
   } else {
     GST_WRITE_UINT32_BE (data + 2, value);
-    atom_moov_add_tag (moov, fourcc, flags, data, 8);
+    atom_udta_add_tag (udta, fourcc, flags, data, 8);
   }
 }
 
-static GstBuffer *
-_gst_buffer_new_wrapped (gpointer mem, gsize size, GFreeFunc free_func)
-{
-  GstBuffer *buf;
-
-  buf = gst_buffer_new ();
-  gst_buffer_append_memory (buf,
-      gst_memory_new_wrapped (free_func ? 0 : GST_MEMORY_FLAG_READONLY,
-          mem, size, 0, size, mem, free_func));
-
-  return buf;
-}
+#define GST_BUFFER_NEW_READONLY(mem, size) \
+    gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, mem, size, \
+    0, size, mem, NULL)
 
 void
-atom_moov_add_blob_tag (AtomMOOV * moov, guint8 * data, guint size)
+atom_udta_add_blob_tag (AtomUDTA * udta, guint8 * data, guint size)
 {
   AtomData *data_atom;
-  GstBuffer *buf;
   guint len;
   guint32 fourcc;
 
@@ -3058,34 +3046,29 @@ atom_moov_add_blob_tag (AtomMOOV * moov, guint8 * data, guint size)
   if (len > size)
     return;
 
-  buf = _gst_buffer_new_wrapped (data + 8, len - 8, NULL);
-  data_atom = atom_data_new_from_gst_buffer (fourcc, buf);
-  gst_buffer_unref (buf);
+  data_atom = atom_data_new_from_data (fourcc, data + 8, len - 8);
 
-  atom_moov_append_tag (moov,
+  atom_udta_append_tag (udta,
       build_atom_info_wrapper ((Atom *) data_atom, atom_data_copy_data,
           atom_data_free));
 }
 
 void
-atom_moov_add_3gp_tag (AtomMOOV * moov, guint32 fourcc, guint8 * data,
+atom_udta_add_3gp_tag (AtomUDTA * udta, guint32 fourcc, guint8 * data,
     guint size)
 {
   AtomData *data_atom;
-  GstBuffer *buf;
-  guint8 *bdata;
+
+  data_atom = atom_data_new (fourcc);
 
   /* need full atom */
-  bdata = g_malloc (size + 4);
-  /* full atom: version and flags */
-  GST_WRITE_UINT32_BE (bdata, 0);
-  memcpy (bdata + 4, data, size);
+  atom_data_alloc_mem (data_atom, size + 4);
 
-  buf = _gst_buffer_new_wrapped (bdata, size + 4, g_free);
-  data_atom = atom_data_new_from_gst_buffer (fourcc, buf);
-  gst_buffer_unref (buf);
+  /* full atom: version and flags */
+  GST_WRITE_UINT32_BE (data_atom->data, 0);
+  memcpy (data_atom->data + 4, data, size);
 
-  atom_moov_append_tag (moov,
+  atom_udta_append_tag (udta,
       build_atom_info_wrapper ((Atom *) data_atom, atom_data_copy_data,
           atom_data_free));
 }
@@ -3101,7 +3084,7 @@ language_code (const char *lang)
 }
 
 void
-atom_moov_add_3gp_str_int_tag (AtomMOOV * moov, guint32 fourcc,
+atom_udta_add_3gp_str_int_tag (AtomUDTA * udta, guint32 fourcc,
     const gchar * value, gint16 ivalue)
 {
   gint len = 0, size = 0;
@@ -3132,39 +3115,37 @@ atom_moov_add_3gp_str_int_tag (AtomMOOV * moov, guint32 fourcc,
     }
   }
 
-  atom_moov_add_3gp_tag (moov, fourcc, data, size);
+  atom_udta_add_3gp_tag (udta, fourcc, data, size);
   g_free (data);
 }
 
 void
-atom_moov_add_3gp_str_tag (AtomMOOV * moov, guint32 fourcc, const gchar * value)
+atom_udta_add_3gp_str_tag (AtomUDTA * udta, guint32 fourcc, const gchar * value)
 {
-  atom_moov_add_3gp_str_int_tag (moov, fourcc, value, -1);
+  atom_udta_add_3gp_str_int_tag (udta, fourcc, value, -1);
 }
 
 void
-atom_moov_add_3gp_uint_tag (AtomMOOV * moov, guint32 fourcc, guint16 value)
+atom_udta_add_3gp_uint_tag (AtomUDTA * udta, guint32 fourcc, guint16 value)
 {
-  atom_moov_add_3gp_str_int_tag (moov, fourcc, NULL, value);
+  atom_udta_add_3gp_str_int_tag (udta, fourcc, NULL, value);
 }
 
 void
-atom_moov_add_xmp_tags (AtomMOOV * moov, GstBuffer * xmpbuffer)
+atom_udta_add_xmp_tags (AtomUDTA * udta, GstBuffer * xmpbuffer)
 {
   AtomData *data_atom = NULL;
 
-  if (moov->context.flavor == ATOMS_TREE_FLAVOR_MOV) {
+  if (udta->context->flavor == ATOMS_TREE_FLAVOR_MOV) {
     if (xmpbuffer) {
       data_atom = atom_data_new_from_gst_buffer (FOURCC_XMP_, xmpbuffer);
-      atom_moov_init_metatags (moov, &moov->context);
-      moov->udta->entries = g_list_append (moov->udta->entries,
+      udta->entries = g_list_append (udta->entries,
           build_atom_info_wrapper ((Atom *) data_atom, atom_data_copy_data,
               atom_data_free));
     }
   } else {
     GST_DEBUG ("Not adding xmp to moov atom, it is only used in 'mov' format");
   }
-
 }
 
 /*
@@ -3288,31 +3269,41 @@ atom_tkhd_set_subtitle (AtomTKHD * tkhd, AtomsContext * context, guint32 width,
 
 
 static void
-atom_edts_add_entry (AtomEDTS * edts, EditListEntry * entry)
+atom_edts_add_entry (AtomEDTS * edts, gint index, EditListEntry * entry)
 {
-  edts->elst.entries = g_slist_append (edts->elst.entries, entry);
+  EditListEntry *e =
+      (EditListEntry *) g_slist_nth_data (edts->elst.entries, index);
+  /* Create a new entry if missing (appends to the list if index is larger) */
+  if (e == NULL) {
+    e = g_new (EditListEntry, 1);
+    edts->elst.entries = g_slist_insert (edts->elst.entries, e, index);
+  }
+
+  /* Update the entry */
+  *e = *entry;
 }
 
-/* 
- * Adds a new entry to this trak edits list
+/*
+ * Update an entry in this trak edits list, creating it if needed.
+ * index is the index of the entry to update, or create if it's past the end.
  * duration is in the moov's timescale
  * media_time is the offset in the media time to start from (media's timescale)
  * rate is a 32 bits fixed-point
  */
 void
-atom_trak_add_elst_entry (AtomTRAK * trak, guint32 duration, guint32 media_time,
-    guint32 rate)
+atom_trak_set_elst_entry (AtomTRAK * trak, gint index,
+    guint32 duration, guint32 media_time, guint32 rate)
 {
-  EditListEntry *entry = g_new (EditListEntry, 1);
+  EditListEntry entry;
 
-  entry->duration = duration;
-  entry->media_time = media_time;
-  entry->media_rate = rate;
+  entry.duration = duration;
+  entry.media_time = media_time;
+  entry.media_rate = rate;
 
-  if (trak->edts == NULL) {
+  if (trak->edts == NULL)
     trak->edts = atom_edts_new ();
-  }
-  atom_edts_add_entry (trak->edts, entry);
+
+  atom_edts_add_entry (trak->edts, index, &entry);
 }
 
 /* re-negotiation is prevented at top-level, so only 1 entry expected.
@@ -3425,9 +3416,28 @@ atom_trak_set_subtitle_commons (AtomTRAK * trak, AtomsContext * context)
 {
   atom_trak_set_subtitle (trak, context);
   trak->mdia.mdhd.time_info.timescale = 1000;
+
+  trak->tkhd.alternate_group = 2;       /* same for all subtitles */
+  trak->tkhd.layer = -1;        /* above video (layer 0) */
 }
 
 void
+sample_table_entry_add_ext_atom (SampleTableEntry * ste, AtomInfo * ext)
+{
+  GList **list = NULL;
+  if (ste->kind == AUDIO) {
+    list = &(((SampleTableEntryMP4A *) ste)->extension_atoms);
+  } else if (ste->kind == VIDEO) {
+    list = &(((SampleTableEntryMP4V *) ste)->extension_atoms);
+  } else {
+    g_assert_not_reached ();
+    return;
+  }
+
+  *list = g_list_prepend (*list, ext);
+}
+
+SampleTableEntryMP4A *
 atom_trak_set_audio_type (AtomTRAK * trak, AtomsContext * context,
     AudioSampleEntry * entry, guint32 scale, AtomInfo * ext, gint sample_size)
 {
@@ -3456,34 +3466,33 @@ atom_trak_set_audio_type (AtomTRAK * trak, AtomsContext * context,
 
   /* 0 size means variable size */
   atom_trak_set_constant_size_samples (trak, sample_size);
+
+  return ste;
 }
 
 static AtomInfo *
 build_pasp_extension (AtomTRAK * trak, gint par_width, gint par_height)
 {
-  AtomData *atom_data;
-  GstBuffer *buf;
+  AtomData *atom_data = atom_data_new (FOURCC_pasp);
   guint8 *data;
 
-  data = g_malloc (8);
+  atom_data_alloc_mem (atom_data, 8);
+  data = atom_data->data;
+
   /* ihdr = image header box */
   GST_WRITE_UINT32_BE (data, par_width);
   GST_WRITE_UINT32_BE (data + 4, par_height);
 
-  buf = _gst_buffer_new_wrapped (data, 8, g_free);
-  atom_data = atom_data_new_from_gst_buffer (FOURCC_pasp, buf);
-  gst_buffer_unref (buf);
-
   return build_atom_info_wrapper ((Atom *) atom_data, atom_data_copy_data,
       atom_data_free);
 }
 
-void
+SampleTableEntryMP4V *
 atom_trak_set_video_type (AtomTRAK * trak, AtomsContext * context,
     VisualSampleEntry * entry, guint32 scale, GList * ext_atoms_list)
 {
   SampleTableEntryMP4V *ste;
-  gint dwidth, dheight;
+  guint dwidth, dheight;
   gint par_n = 0, par_d = 0;
 
   if ((entry->par_n != 1 || entry->par_d != 1) &&
@@ -3497,12 +3506,10 @@ atom_trak_set_video_type (AtomTRAK * trak, AtomsContext * context,
   /* ISO file spec says track header w/h indicates track's visual presentation
    * (so this together with pixels w/h implicitly defines PAR) */
   if (par_n && (context->flavor != ATOMS_TREE_FLAVOR_MOV)) {
-    if (par_n > par_d) {
-      dwidth = entry->width * par_n / par_d;
-      dheight = entry->height;
-    } else {
-      dwidth = entry->width * par_n / par_d;
-      dheight = entry->height;
+    /* Assumes square pixels display */
+    if (!gst_video_calculate_display_ratio (&dwidth, &dheight, entry->width,
+            entry->height, par_n, par_d, 1, 1)) {
+      GST_WARNING ("Could not calculate display ratio");
     }
   }
 
@@ -3529,6 +3536,8 @@ atom_trak_set_video_type (AtomTRAK * trak, AtomsContext * context,
     ste->extension_atoms = g_list_append (ste->extension_atoms,
         build_pasp_extension (trak, par_n, par_d));
   }
+
+  return ste;
 }
 
 void
@@ -3539,7 +3548,7 @@ subtitle_sample_entry_init (SubtitleSampleEntry * entry)
   entry->foreground_color_rgba = 0xFFFFFFFF;    /* all white, opaque */
 }
 
-void
+SampleTableEntryTX3G *
 atom_trak_set_subtitle_type (AtomTRAK * trak, AtomsContext * context,
     SubtitleSampleEntry * entry)
 {
@@ -3555,6 +3564,8 @@ atom_trak_set_subtitle_type (AtomTRAK * trak, AtomsContext * context,
 
   trak->is_video = FALSE;
   trak->is_h264 = FALSE;
+
+  return tx3g;
 }
 
 static void
@@ -4262,19 +4273,16 @@ AtomInfo *
 build_btrt_extension (guint32 buffer_size_db, guint32 avg_bitrate,
     guint32 max_bitrate)
 {
-  AtomData *atom_data;
-  GstBuffer *buf;
+  AtomData *atom_data = atom_data_new (FOURCC_btrt);
   guint8 *data;
 
-  data = g_malloc (12);
+  atom_data_alloc_mem (atom_data, 12);
+  data = atom_data->data;
+
   GST_WRITE_UINT32_BE (data, buffer_size_db);
   GST_WRITE_UINT32_BE (data + 4, max_bitrate);
   GST_WRITE_UINT32_BE (data + 8, avg_bitrate);
 
-  buf = _gst_buffer_new_wrapped (data, 12, g_free);
-  atom_data = atom_data_new_from_gst_buffer (FOURCC_btrt, buf);
-  gst_buffer_unref (buf);
-
   return build_atom_info_wrapper ((Atom *) atom_data, atom_data_copy_data,
       atom_data_free);
 }
@@ -4330,7 +4338,7 @@ build_mov_aac_extension (AtomTRAK * trak, const GstBuffer * codec_data,
 
   /* Add MP4A atom to the WAVE:
    * not really in spec, but makes offset based players happy */
-  buf = _gst_buffer_new_wrapped (&tmp, 4, NULL);
+  buf = GST_BUFFER_NEW_READONLY (&tmp, 4);
   mp4a = build_codec_data_extension (FOURCC_mp4a, buf);
   gst_buffer_unref (buf);
 
@@ -4351,17 +4359,14 @@ AtomInfo *
 build_fiel_extension (gint fields)
 {
   AtomData *atom_data;
-  GstBuffer *buf;
   guint8 f = fields;
 
   if (fields == 1) {
     return NULL;
   }
 
-  buf = _gst_buffer_new_wrapped (&f, 1, NULL);
   atom_data =
-      atom_data_new_from_gst_buffer (GST_MAKE_FOURCC ('f', 'i', 'e', 'l'), buf);
-  gst_buffer_unref (buf);
+      atom_data_new_from_data (GST_MAKE_FOURCC ('f', 'i', 'e', 'l'), &f, 1);
 
   return build_atom_info_wrapper ((Atom *) atom_data, atom_data_copy_data,
       atom_data_free);
@@ -4558,7 +4563,7 @@ build_amr_extension (void)
   /* frames per sample */
   GST_WRITE_UINT8 (ext + 8, 1);
 
-  buf = _gst_buffer_new_wrapped (ext, sizeof (ext), NULL);
+  buf = GST_BUFFER_NEW_READONLY (ext, sizeof (ext));
   res = build_codec_data_extension (GST_MAKE_FOURCC ('d', 'a', 'm', 'r'), buf);
   gst_buffer_unref (buf);
   return res;
@@ -4580,7 +4585,7 @@ build_h263_extension (void)
   GST_WRITE_UINT8 (ext + 5, 10);
   GST_WRITE_UINT8 (ext + 6, 0);
 
-  buf = _gst_buffer_new_wrapped (ext, sizeof (ext), NULL);
+  buf = GST_BUFFER_NEW_READONLY (ext, sizeof (ext));
   res = build_codec_data_extension (GST_MAKE_FOURCC ('d', '2', '6', '3'), buf);
   gst_buffer_unref (buf);
   return res;
@@ -4597,7 +4602,7 @@ build_gama_atom (gdouble gamma)
   gamma_fp = (guint32) 65536 *gamma;
 
   gamma_fp = GUINT32_TO_BE (gamma_fp);
-  buf = _gst_buffer_new_wrapped (&gamma_fp, 4, NULL);
+  buf = GST_BUFFER_NEW_READONLY (&gamma_fp, 4);
   res = build_codec_data_extension (FOURCC_gama, buf);
   gst_buffer_unref (buf);
   return res;
@@ -4618,7 +4623,7 @@ build_SMI_atom (const GstBuffer * seqh)
   GST_WRITE_UINT32_LE (data, FOURCC_SEQH);
   GST_WRITE_UINT32_BE (data + 4, size + 8);
   gst_buffer_extract ((GstBuffer *) seqh, 0, data + 8, size);
-  buf = _gst_buffer_new_wrapped (data, size + 8, g_free);
+  buf = gst_buffer_new_wrapped (data, size + 8);
   res = build_codec_data_extension (FOURCC_SMI_, buf);
   gst_buffer_unref (buf);
   return res;
@@ -4627,10 +4632,9 @@ build_SMI_atom (const GstBuffer * seqh)
 static AtomInfo *
 build_ima_adpcm_atom (gint channels, gint rate, gint blocksize)
 {
+#define IMA_ADPCM_ATOM_SIZE 20
   AtomData *atom_data;
-  GstBuffer *buf;
   guint8 *data;
-  const gint ima_adpcm_atom_size = 20;
   guint32 fourcc;
   gint samplesperblock;
   gint bytespersec;
@@ -4640,7 +4644,9 @@ build_ima_adpcm_atom (gint channels, gint rate, gint blocksize)
      within the WAVE header (below), it's little endian. */
   fourcc = MS_WAVE_FOURCC (0x11);
 
-  data = g_malloc (ima_adpcm_atom_size);
+  atom_data = atom_data_new (fourcc);
+  atom_data_alloc_mem (atom_data, IMA_ADPCM_ATOM_SIZE);
+  data = atom_data->data;
 
   /* This atom's content is a WAVE header, including 2 bytes of extra data.
      Note that all of this is little-endian, unlike most stuff in qt. */
@@ -4657,10 +4663,6 @@ build_ima_adpcm_atom (gint channels, gint rate, gint blocksize)
   GST_WRITE_UINT16_LE (data + 16, 2);   /* Two extra bytes */
   GST_WRITE_UINT16_LE (data + 18, samplesperblock);
 
-  buf = _gst_buffer_new_wrapped (data, ima_adpcm_atom_size, g_free);
-  atom_data = atom_data_new_from_gst_buffer (fourcc, buf);
-  gst_buffer_unref (buf);
-
   return build_atom_info_wrapper ((Atom *) atom_data, atom_data_copy_data,
       atom_data_free);
 }
@@ -4698,11 +4700,42 @@ build_ima_adpcm_extension (gint channels, gint rate, gint blocksize)
 }
 
 AtomInfo *
+build_ac3_extension (guint8 fscod, guint8 bsid, guint8 bsmod, guint8 acmod,
+    guint8 lfe_on, guint8 bitrate_code)
+{
+  AtomData *atom_data = atom_data_new (FOURCC_dac3);
+  guint8 *data;
+
+  atom_data_alloc_mem (atom_data, 3);
+  data = atom_data->data;
+
+  /* Bits from the spec
+   * fscod 2
+   * bsid  5
+   * bsmod 3
+   * acmod 3
+   * lfeon 1
+   * bit_rate_code 5
+   * reserved 5
+   */
+
+  /* Some bit manipulation magic. Need bitwriter */
+  data[0] = (fscod << 6) | (bsid << 1) | ((bsmod >> 2) & 1);
+  data[1] =
+      ((bsmod & 0x3) << 6) | (acmod << 3) | ((lfe_on & 1) << 2) | ((bitrate_code
+          >> 3) & 0x3);
+  data[2] = ((bitrate_code & 0x7) << 5);
+
+  return build_atom_info_wrapper ((Atom *) atom_data, atom_data_copy_data,
+      atom_data_free);
+}
+
+AtomInfo *
 build_uuid_xmp_atom (GstBuffer * xmp_data)
 {
   AtomUUID *uuid;
   gsize size;
-  static guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
+  static const guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
     0x97, 0xA9, 0x42, 0xE8,
     0x9C, 0x71, 0x99, 0x94,
     0x91, 0xE3, 0xAF, 0xAC
diff --git a/gst/isomp4/atoms.h b/gst/isomp4/atoms.h
index b497074..f8789e4 100644
--- a/gst/isomp4/atoms.h
+++ b/gst/isomp4/atoms.h
@@ -112,7 +112,7 @@ void          atoms_context_free (AtomsContext *context);
 
 /* atom defs and functions */
 
-/**
+/*
  * Used for storing time related values for some atoms.
  */
 typedef struct _TimeInfo
@@ -415,13 +415,6 @@ typedef struct _SampleTableEntryMP4A
   GList *extension_atoms;
 } SampleTableEntryMP4A;
 
-typedef struct _SampleTableEntryMP4S
-{
-  SampleTableEntry se;
-
-  AtomESDS es;
-} SampleTableEntryMP4S;
-
 typedef struct _SampleTableEntryTX3G
 {
   SampleTableEntry se;
@@ -478,7 +471,8 @@ typedef struct _AtomSTSC
 typedef struct _AtomSTCO64
 {
   AtomFull header;
-
+  /* Global offset to add to entries when serialising */
+  guint32 chunk_offset;
   ATOM_ARRAY (guint64) entries;
 } AtomSTCO64;
 
@@ -597,6 +591,8 @@ typedef struct _AtomUDTA
   GList* entries;
   /* or list is further down */
   AtomMETA *meta;
+
+  AtomsContext *context;
 } AtomUDTA;
 
 enum TrFlags
@@ -616,7 +612,8 @@ enum TfFlags
   TF_DEFAULT_SAMPLE_DURATION  = 0x08,     /* default-sample-duration-present */
   TF_DEFAULT_SAMPLE_SIZE      = 0x010,    /* default-sample-size-present */
   TF_DEFAULT_SAMPLE_FLAGS     = 0x020,    /* default-sample-flags-present */
-  TF_DURATION_IS_EMPTY        = 0x010000  /* sample-composition-time-offsets-presents */
+  TF_DURATION_IS_EMPTY        = 0x010000, /* sample-composition-time-offsets-presents */
+  TF_DEFAULT_BASE_IS_MOOF     = 0x020000  /* default-base-is-moof */
 };
 
 typedef struct _AtomTRAK
@@ -626,10 +623,13 @@ typedef struct _AtomTRAK
   AtomTKHD tkhd;
   AtomEDTS *edts;
   AtomMDIA mdia;
+  AtomUDTA udta;
 
   /* some helper info for structural conformity checks */
   gboolean is_video;
   gboolean is_h264;
+
+  AtomsContext *context;
 } AtomTRAK;
 
 typedef struct _AtomTREX
@@ -746,9 +746,10 @@ typedef struct _AtomMOOV
 
   /* list of AtomTRAK */
   GList *traks;
-  AtomUDTA *udta;
+  AtomUDTA udta;
 
   gboolean fragmented;
+  guint32 chunks_offset;
 } AtomMOOV;
 
 typedef struct _AtomWAVE
@@ -823,7 +824,7 @@ AtomTRAK*  atom_trak_new               (AtomsContext *context);
 void       atom_trak_add_samples       (AtomTRAK * trak, guint32 nsamples, guint32 delta,
                                         guint32 size, guint64 chunk_offset, gboolean sync,
                                         gint64 pts_offset);
-void       atom_trak_add_elst_entry    (AtomTRAK * trak, guint32 duration,
+void       atom_trak_set_elst_entry    (AtomTRAK * trak, gint index, guint32 duration,
                                         guint32 media_time, guint32 rate);
 guint32    atom_trak_get_timescale     (AtomTRAK *trak);
 guint32    atom_trak_get_id            (AtomTRAK * trak);
@@ -838,12 +839,13 @@ guint64    atom_moov_copy_data         (AtomMOOV *atom, guint8 **buffer, guint64
 void       atom_moov_update_timescale  (AtomMOOV *moov, guint32 timescale);
 void       atom_moov_update_duration   (AtomMOOV *moov);
 void       atom_moov_set_fragmented    (AtomMOOV *moov, gboolean fragmented);
-void       atom_moov_chunks_add_offset (AtomMOOV *moov, guint32 offset);
+void       atom_moov_chunks_set_offset (AtomMOOV *moov, guint32 offset);
 void       atom_moov_add_trak          (AtomMOOV *moov, AtomTRAK *trak);
+guint      atom_moov_get_trak_count    (AtomMOOV *moov);
 
 guint64    atom_mvhd_copy_data         (AtomMVHD * atom, guint8 ** buffer,
                                         guint64 * size, guint64 * offset);
-void       atom_stco64_chunks_add_offset (AtomSTCO64 * stco64, guint32 offset);
+void       atom_stco64_chunks_set_offset (AtomSTCO64 * stco64, guint32 offset);
 guint64    atom_trak_copy_data         (AtomTRAK * atom, guint8 ** buffer,
                                         guint64 * size, guint64 * offset);
 void       atom_stbl_clear             (AtomSTBL * stbl);
@@ -924,15 +926,15 @@ typedef struct
 
 void subtitle_sample_entry_init (SubtitleSampleEntry * entry);
 
-void atom_trak_set_audio_type (AtomTRAK * trak, AtomsContext * context,
+SampleTableEntryMP4A * atom_trak_set_audio_type (AtomTRAK * trak, AtomsContext * context,
                                AudioSampleEntry * entry, guint32 scale,
                                AtomInfo * ext, gint sample_size);
 
-void atom_trak_set_video_type (AtomTRAK * trak, AtomsContext * context,
+SampleTableEntryMP4V * atom_trak_set_video_type (AtomTRAK * trak, AtomsContext * context,
                                VisualSampleEntry * entry, guint32 rate,
                                GList * ext_atoms_list);
 
-void atom_trak_set_subtitle_type (AtomTRAK * trak, AtomsContext * context,
+SampleTableEntryTX3G * atom_trak_set_subtitle_type (AtomTRAK * trak, AtomsContext * context,
                                SubtitleSampleEntry * entry);
 
 void atom_trak_update_bitrates (AtomTRAK * trak, guint32 avg_bitrate,
@@ -941,6 +943,8 @@ void atom_trak_update_bitrates (AtomTRAK * trak, guint32 avg_bitrate,
 void atom_trak_tx3g_update_dimension (AtomTRAK * trak, guint32 width,
                                       guint32 height);
 
+void sample_table_entry_add_ext_atom (SampleTableEntry * ste, AtomInfo * ext);
+
 AtomInfo *   build_codec_data_extension  (guint32 fourcc, const GstBuffer * codec_data);
 AtomInfo *   build_mov_aac_extension     (AtomTRAK * trak, const GstBuffer * codec_data,
                                           guint32 avg_bitrate, guint32 max_bitrate);
@@ -957,6 +961,9 @@ AtomInfo *   build_jp2h_extension        (AtomTRAK * trak, gint width, gint heig
 
 AtomInfo *   build_jp2x_extension        (const GstBuffer * prefix);
 AtomInfo *   build_fiel_extension        (gint fields);
+AtomInfo *   build_ac3_extension         (guint8 fscod, guint8 bsid,
+                                          guint8 bsmod, guint8 acmod,
+                                          guint8 lfe_on, guint8 bitrate_code);
 AtomInfo *   build_amr_extension         (void);
 AtomInfo *   build_h263_extension        (void);
 AtomInfo *   build_gama_atom             (gdouble gamma);
@@ -969,21 +976,22 @@ AtomInfo *   build_uuid_xmp_atom         (GstBuffer * xmp);
 /*
  * Meta tags functions
  */
-void atom_moov_add_str_tag    (AtomMOOV *moov, guint32 fourcc, const gchar *value);
-void atom_moov_add_uint_tag   (AtomMOOV *moov, guint32 fourcc, guint32 flags,
+void atom_udta_clear_tags (AtomUDTA *udta);
+void atom_udta_add_str_tag    (AtomUDTA *udta, guint32 fourcc, const gchar *value);
+void atom_udta_add_uint_tag   (AtomUDTA *udta, guint32 fourcc, guint32 flags,
                                guint32 value);
-void atom_moov_add_tag        (AtomMOOV *moov, guint32 fourcc, guint32 flags,
+void atom_udta_add_tag        (AtomUDTA *udta, guint32 fourcc, guint32 flags,
                                const guint8 * data, guint size);
-void atom_moov_add_blob_tag   (AtomMOOV *moov, guint8 *data, guint size);
+void atom_udta_add_blob_tag   (AtomUDTA *udta, guint8 *data, guint size);
 
-void atom_moov_add_3gp_str_tag       (AtomMOOV * moov, guint32 fourcc, const gchar * value);
-void atom_moov_add_3gp_uint_tag      (AtomMOOV * moov, guint32 fourcc, guint16 value);
-void atom_moov_add_3gp_str_int_tag   (AtomMOOV * moov, guint32 fourcc, const gchar * value,
+void atom_udta_add_3gp_str_tag       (AtomUDTA *udta, guint32 fourcc, const gchar * value);
+void atom_udta_add_3gp_uint_tag      (AtomUDTA *udta, guint32 fourcc, guint16 value);
+void atom_udta_add_3gp_str_int_tag   (AtomUDTA *udta, guint32 fourcc, const gchar * value,
                                       gint16 ivalue);
-void atom_moov_add_3gp_tag           (AtomMOOV * moov, guint32 fourcc, guint8 * data,
+void atom_udta_add_3gp_tag           (AtomUDTA *udta, guint32 fourcc, guint8 * data,
                                       guint size);
 
-void atom_moov_add_xmp_tags          (AtomMOOV * moov, GstBuffer * xmp);
+void atom_udta_add_xmp_tags          (AtomUDTA *udta, GstBuffer * xmp);
 
 #define GST_QT_MUX_DEFAULT_TAG_LANGUAGE   "und" /* undefined/unknown */
 guint16  language_code               (const char * lang);
diff --git a/gst/isomp4/atomsrecovery.c b/gst/isomp4/atomsrecovery.c
index fec76a3..b21ee9c 100644
--- a/gst/isomp4/atomsrecovery.c
+++ b/gst/isomp4/atomsrecovery.c
@@ -40,7 +40,7 @@
  * SOFTWARE.
  */
 
-/**
+/*
  * This module contains functions for serializing partial information from
  * a mux in progress (by qtmux elements). This enables reconstruction of the
  * moov box if a crash happens and thus recovering the movie file.
@@ -128,7 +128,7 @@ atoms_recov_write_ftyp_info (FILE * f, AtomFTYP * ftyp, GstBuffer * prefix)
   return TRUE;
 }
 
-/**
+/*
  * Writes important info on the 'moov' atom (non-trak related)
  * to be able to recover the moov structure after a crash.
  *
@@ -153,7 +153,7 @@ atoms_recov_write_moov_info (FILE * f, AtomMOOV * moov)
   return atom_size > 0 && writen == atom_size;
 }
 
-/**
+/*
  * Writes the number of traks to the file.
  * This simply writes a guint32 in BE.
  */
@@ -165,7 +165,7 @@ atoms_recov_write_traks_number (FILE * f, guint32 traks)
   return fwrite (data, 4, 1, f) == 1;
 }
 
-/**
+/*
  * Writes the moov's timescale to the file
  * This simply writes a guint32 in BE.
  */
@@ -177,7 +177,7 @@ atoms_recov_write_moov_timescale (FILE * f, guint32 timescale)
   return fwrite (data, 4, 1, f) == 1;
 }
 
-/**
+/*
  * Writes the trak atom to the file.
  */
 gboolean
@@ -778,7 +778,7 @@ trak_recov_data_add_sample (TrakRecovData * trak, TrakBufferEntryInfo * b)
       b->chunk_offset, b->sync, b->pts_offset);
 }
 
-/**
+/*
  * Parses the buffer entries in the MoovRecovFile and matches the inputs
  * with the data in the MdatRecovFile. Whenever a buffer entry of that
  * represents 'x' bytes of data, the same amount of data is 'validated' in
@@ -972,7 +972,7 @@ moov_recov_write_file (MoovRecovFile * moovrf, MdatRecovFile * mdatrf,
     TrakRecovData *trak = &(moovrf->traks_rd[i]);
     /* 16 for the mdat header */
     gint64 offset = moov_size + ftell (outf) + 16;
-    atom_stco64_chunks_add_offset (&trak->stbl.stco64, offset);
+    atom_stco64_chunks_set_offset (&trak->stbl.stco64, offset);
   }
 
   /* write the moov */
diff --git a/gst/isomp4/fourcc.h b/gst/isomp4/fourcc.h
index 4edf900..4bff1e0 100644
--- a/gst/isomp4/fourcc.h
+++ b/gst/isomp4/fourcc.h
@@ -83,6 +83,7 @@ G_BEGIN_DECLS
 #define FOURCC__too     GST_MAKE_FOURCC(0xa9,'t','o','o')
 #define FOURCC__wrt     GST_MAKE_FOURCC(0xa9,'w','r','t')
 #define FOURCC_aART     GST_MAKE_FOURCC('a','A','R','T')
+#define FOURCC_ac_3     GST_MAKE_FOURCC('a','c','-','3')
 #define FOURCC_agsm     GST_MAKE_FOURCC('a','g','s','m')
 #define FOURCC_alac     GST_MAKE_FOURCC('a','l','a','c')
 #define FOURCC_alaw     GST_MAKE_FOURCC('a','l','a','w')
@@ -101,6 +102,8 @@ G_BEGIN_DECLS
 #define FOURCC_crgn     GST_MAKE_FOURCC('c','r','g','n')
 #define FOURCC_ctab     GST_MAKE_FOURCC('c','t','a','b')
 #define FOURCC_ctts     GST_MAKE_FOURCC('c','t','t','s')
+#define FOURCC_cslg     GST_MAKE_FOURCC('c','s','l','g')
+#define FOURCC_dac3     GST_MAKE_FOURCC('d','a','c','3')
 #define FOURCC_data     GST_MAKE_FOURCC('d','a','t','a')
 #define FOURCC_dcom     GST_MAKE_FOURCC('d','c','o','m')
 #define FOURCC_desc     GST_MAKE_FOURCC('d','e','s','c')
@@ -180,6 +183,7 @@ G_BEGIN_DECLS
 #define FOURCC_sawb     GST_MAKE_FOURCC('s','a','w','b')
 #define FOURCC_sbtl     GST_MAKE_FOURCC('s','b','t','l')
 #define FOURCC_sdp_     GST_MAKE_FOURCC('s','d','p',' ')
+#define FOURCC_sidx     GST_MAKE_FOURCC('s','i','d','x')
 #define FOURCC_smhd     GST_MAKE_FOURCC('s','m','h','d')
 #define FOURCC_soaa     GST_MAKE_FOURCC('s','o','a','a')
 #define FOURCC_soal     GST_MAKE_FOURCC('s','o','a','l')
@@ -200,6 +204,7 @@ G_BEGIN_DECLS
 #define FOURCC_stsz     GST_MAKE_FOURCC('s','t','s','z')
 #define FOURCC_stts     GST_MAKE_FOURCC('s','t','t','s')
 #define FOURCC_subp     GST_MAKE_FOURCC('s','u','b','p')
+#define FOURCC_subt     GST_MAKE_FOURCC('s','u','b','t')
 #define FOURCC_text     GST_MAKE_FOURCC('t','e','x','t')
 #define FOURCC_tkhd     GST_MAKE_FOURCC('t','k','h','d')
 #define FOURCC_tmpo     GST_MAKE_FOURCC('t','m','p','o')
@@ -216,6 +221,7 @@ G_BEGIN_DECLS
 #define FOURCC_ulaw     GST_MAKE_FOURCC('u','l','a','w')
 #define FOURCC_url_     GST_MAKE_FOURCC('u','r','l',' ')
 #define FOURCC_uuid     GST_MAKE_FOURCC('u','u','i','d')
+#define FOURCC_v210     GST_MAKE_FOURCC('v','2','1','0')
 #define FOURCC_vide     GST_MAKE_FOURCC('v','i','d','e')
 #define FOURCC_vmhd     GST_MAKE_FOURCC('v','m','h','d')
 #define FOURCC_wave     GST_MAKE_FOURCC('w','a','v','e')
@@ -229,6 +235,8 @@ G_BEGIN_DECLS
 #define FOURCC_apcs     GST_MAKE_FOURCC('a','p','c','s')
 #define FOURCC_m1v      GST_MAKE_FOURCC('m','1','v',' ')
 #define FOURCC_vivo     GST_MAKE_FOURCC('v','i','v','o')
+#define FOURCC_saiz     GST_MAKE_FOURCC('s','a','i','z')
+#define FOURCC_saio     GST_MAKE_FOURCC('s','a','i','o')
 
 #define FOURCC_3gg6     GST_MAKE_FOURCC('3','g','g','6')
 #define FOURCC_3gg7     GST_MAKE_FOURCC('3','g','g','7')
@@ -317,6 +325,27 @@ G_BEGIN_DECLS
 #define MS_WAVE_FOURCC(codecid)  GST_MAKE_FOURCC( \
         'm', 's', ((codecid)>>8)&0xff, ((codecid)&0xff))
 
+/* MPEG Application Format , Stereo Video */
+#define FOURCC_ss01     GST_MAKE_FOURCC('s','s','0','1')
+#define FOURCC_ss02     GST_MAKE_FOURCC('s','s','0','2')
+#define FOURCC_svmi     GST_MAKE_FOURCC('s','v','m','i')
+#define FOURCC_scdi     GST_MAKE_FOURCC('s','c','d','i')
+
+/* Protected streams */
+#define FOURCC_encv     GST_MAKE_FOURCC('e','n','c','v')
+#define FOURCC_enca     GST_MAKE_FOURCC('e','n','c','a')
+#define FOURCC_enct     GST_MAKE_FOURCC('e','n','c','t')
+#define FOURCC_encs     GST_MAKE_FOURCC('e','n','c','s')
+#define FOURCC_sinf     GST_MAKE_FOURCC('s','i','n','f')
+#define FOURCC_frma     GST_MAKE_FOURCC('f','r','m','a')
+#define FOURCC_schm     GST_MAKE_FOURCC('s','c','h','m')
+#define FOURCC_schi     GST_MAKE_FOURCC('s','c','h','i')
+
+/* Common Encryption */
+#define FOURCC_pssh     GST_MAKE_FOURCC('p','s','s','h')
+#define FOURCC_tenc     GST_MAKE_FOURCC('t','e','n','c')
+#define FOURCC_cenc     GST_MAKE_FOURCC('c','e','n','c')
+
 G_END_DECLS
 
 #endif /* __FOURCC_H__ */
diff --git a/gst/isomp4/gstisoff.c b/gst/isomp4/gstisoff.c
new file mode 100644
index 0000000..5c9f1ed
--- /dev/null
+++ b/gst/isomp4/gstisoff.c
@@ -0,0 +1,200 @@
+/*
+ * ISO File Format parsing library
+ *
+ * gstisoff.h
+ *
+ * Copyright (C) 2015 Samsung Electronics. All rights reserved.
+ *   Author: Thiago Santos <thiagoss@osg.samsung.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library (COPYING); if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gstisoff.h"
+#include <gst/base/gstbytereader.h>
+
+void
+gst_isoff_qt_sidx_parser_init (GstSidxParser * parser)
+{
+  parser->status = GST_ISOFF_QT_SIDX_PARSER_INIT;
+  parser->cumulative_entry_size = 0;
+  parser->sidx.entries = NULL;
+  parser->sidx.entries_count = 0;
+}
+
+void
+gst_isoff_qt_sidx_parser_clear (GstSidxParser * parser)
+{
+  g_free (parser->sidx.entries);
+  parser->sidx.entries = NULL;
+}
+
+static void
+gst_isoff_qt_parse_sidx_entry (GstSidxBoxEntry * entry, GstByteReader * reader)
+{
+  guint32 aux;
+
+  aux = gst_byte_reader_get_uint32_be_unchecked (reader);
+  entry->ref_type = aux >> 31;
+  entry->size = aux & 0x7FFFFFFF;
+  entry->duration = gst_byte_reader_get_uint32_be_unchecked (reader);
+  aux = gst_byte_reader_get_uint32_be_unchecked (reader);
+  entry->starts_with_sap = aux >> 31;
+  entry->sap_type = ((aux >> 28) & 0x7);
+  entry->sap_delta_time = aux & 0xFFFFFFF;
+}
+
+GstIsoffParserResult
+gst_isoff_qt_sidx_parser_add_data (GstSidxParser * parser,
+    const guint8 * buffer, gint length, guint * consumed)
+{
+  GstIsoffParserResult res = GST_ISOFF_QT_PARSER_OK;
+  GstByteReader reader;
+  gsize remaining;
+  guint32 fourcc;
+
+  gst_byte_reader_init (&reader, buffer, length);
+
+  switch (parser->status) {
+    case GST_ISOFF_QT_SIDX_PARSER_INIT:
+      if (gst_byte_reader_get_remaining (&reader) < GST_ISOFF_QT_FULL_BOX_SIZE) {
+        break;
+      }
+
+      parser->size = gst_byte_reader_get_uint32_be_unchecked (&reader);
+      fourcc = gst_byte_reader_get_uint32_le_unchecked (&reader);
+      if (fourcc != GST_ISOFF_QT_FOURCC_SIDX) {
+        res = GST_ISOFF_QT_PARSER_UNEXPECTED;
+        gst_byte_reader_set_pos (&reader, 0);
+        break;
+      }
+      if (parser->size == 1) {
+        if (gst_byte_reader_get_remaining (&reader) < 12) {
+          gst_byte_reader_set_pos (&reader, 0);
+          break;
+        }
+
+        parser->size = gst_byte_reader_get_uint64_be_unchecked (&reader);
+      }
+      if (parser->size == 0) {
+        res = GST_ISOFF_QT_PARSER_ERROR;
+        gst_byte_reader_set_pos (&reader, 0);
+        break;
+      }
+      parser->sidx.version = gst_byte_reader_get_uint8_unchecked (&reader);
+      parser->sidx.flags = gst_byte_reader_get_uint24_le_unchecked (&reader);
+
+      parser->status = GST_ISOFF_QT_SIDX_PARSER_HEADER;
+
+    case GST_ISOFF_QT_SIDX_PARSER_HEADER:
+      remaining = gst_byte_reader_get_remaining (&reader);
+      if (remaining < 12 + (parser->sidx.version == 0 ? 8 : 16)) {
+        break;
+      }
+
+      parser->sidx.ref_id = gst_byte_reader_get_uint32_be_unchecked (&reader);
+      parser->sidx.timescale =
+          gst_byte_reader_get_uint32_be_unchecked (&reader);
+      if (parser->sidx.version == 0) {
+        parser->sidx.earliest_pts =
+            gst_byte_reader_get_uint32_be_unchecked (&reader);
+        parser->sidx.first_offset = parser->sidx.earliest_pts =
+            gst_byte_reader_get_uint32_be_unchecked (&reader);
+      } else {
+        parser->sidx.earliest_pts =
+            gst_byte_reader_get_uint64_be_unchecked (&reader);
+        parser->sidx.first_offset =
+            gst_byte_reader_get_uint64_be_unchecked (&reader);
+      }
+      /* skip 2 reserved bytes */
+      gst_byte_reader_skip_unchecked (&reader, 2);
+      parser->sidx.entries_count =
+          gst_byte_reader_get_uint16_be_unchecked (&reader);
+
+      GST_LOG ("Timescale: %" G_GUINT32_FORMAT, parser->sidx.timescale);
+      GST_LOG ("Earliest pts: %" G_GUINT64_FORMAT, parser->sidx.earliest_pts);
+      GST_LOG ("First offset: %" G_GUINT64_FORMAT, parser->sidx.first_offset);
+
+      parser->cumulative_pts =
+          gst_util_uint64_scale_int_round (parser->sidx.earliest_pts,
+          GST_SECOND, parser->sidx.timescale);
+
+      if (parser->sidx.entries_count) {
+        parser->sidx.entries =
+            g_malloc (sizeof (GstSidxBoxEntry) * parser->sidx.entries_count);
+      }
+      parser->sidx.entry_index = 0;
+
+      parser->status = GST_ISOFF_QT_SIDX_PARSER_DATA;
+
+    case GST_ISOFF_QT_SIDX_PARSER_DATA:
+      while (parser->sidx.entry_index < parser->sidx.entries_count) {
+        GstSidxBoxEntry *entry =
+            &parser->sidx.entries[parser->sidx.entry_index];
+
+        remaining = gst_byte_reader_get_remaining (&reader);
+        if (remaining < 12)
+          break;
+
+        entry->offset = parser->cumulative_entry_size;
+        entry->pts = parser->cumulative_pts;
+        gst_isoff_qt_parse_sidx_entry (entry, &reader);
+        entry->duration = gst_util_uint64_scale_int_round (entry->duration,
+            GST_SECOND, parser->sidx.timescale);
+        parser->cumulative_entry_size += entry->size;
+        parser->cumulative_pts += entry->duration;
+
+        GST_LOG ("Sidx entry %d) offset: %" G_GUINT64_FORMAT ", pts: %"
+            GST_TIME_FORMAT ", duration %" GST_TIME_FORMAT " - size %"
+            G_GUINT32_FORMAT, parser->sidx.entry_index, entry->offset,
+            GST_TIME_ARGS (entry->pts), GST_TIME_ARGS (entry->duration),
+            entry->size);
+
+        parser->sidx.entry_index++;
+      }
+
+      if (parser->sidx.entry_index == parser->sidx.entries_count)
+        parser->status = GST_ISOFF_QT_SIDX_PARSER_FINISHED;
+      else
+        break;
+    case GST_ISOFF_QT_SIDX_PARSER_FINISHED:
+      parser->sidx.entry_index = 0;
+      res = GST_ISOFF_QT_PARSER_DONE;
+      break;
+  }
+
+  *consumed = gst_byte_reader_get_pos (&reader);
+  return res;
+}
+
+GstIsoffParserResult
+gst_isoff_qt_sidx_parser_add_buffer (GstSidxParser * parser, GstBuffer * buffer,
+    guint * consumed)
+{
+  GstIsoffParserResult res = GST_ISOFF_QT_PARSER_OK;
+  GstMapInfo info;
+
+  if (!gst_buffer_map (buffer, &info, GST_MAP_READ)) {
+    *consumed = 0;
+    return GST_ISOFF_QT_PARSER_ERROR;
+  }
+
+  res =
+      gst_isoff_qt_sidx_parser_add_data (parser, info.data, info.size,
+      consumed);
+
+  gst_buffer_unmap (buffer, &info);
+  return res;
+}
diff --git a/gst/isomp4/gstisoff.h b/gst/isomp4/gstisoff.h
new file mode 100644
index 0000000..c6fbf33
--- /dev/null
+++ b/gst/isomp4/gstisoff.h
@@ -0,0 +1,100 @@
+/*
+ * ISO File Format parsing library
+ *
+ * gstisoff.h
+ *
+ * Copyright (C) 2015 Samsung Electronics. All rights reserved.
+ *   Author: Thiago Santos <thiagoss@osg.samsung.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library (COPYING); if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_ISOFF_QT_H__
+#define __GST_ISOFF_QT_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+typedef enum {
+  GST_ISOFF_QT_PARSER_OK,
+  GST_ISOFF_QT_PARSER_DONE,
+  GST_ISOFF_QT_PARSER_UNEXPECTED,
+  GST_ISOFF_QT_PARSER_ERROR
+} GstIsoffParserResult;
+
+/* this is the minimum size, it can be larger if it
+ * uses extended size or type */
+#define GST_ISOFF_QT_FULL_BOX_SIZE 12
+
+#define GST_ISOFF_QT_FOURCC_SIDX GST_MAKE_FOURCC('s','i','d','x')
+typedef struct _GstSidxBoxEntry
+{
+  gboolean ref_type;
+  guint32 size;
+  GstClockTime duration;
+  gboolean starts_with_sap;
+  guint8 sap_type;
+  guint32 sap_delta_time;
+
+  guint64 offset;
+  GstClockTime pts;
+} GstSidxBoxEntry;
+
+typedef struct _GstSidxBox
+{
+  guint8 version;
+  guint32 flags;
+
+  guint32 ref_id;
+  guint32 timescale;
+  guint64 earliest_pts;
+  guint64 first_offset;
+
+  gint entry_index;
+  gint entries_count;
+
+  GstSidxBoxEntry *entries;
+} GstSidxBox;
+
+typedef enum _GstSidxParserStatus
+{
+  GST_ISOFF_QT_SIDX_PARSER_INIT,
+  GST_ISOFF_QT_SIDX_PARSER_HEADER,
+  GST_ISOFF_QT_SIDX_PARSER_DATA,
+  GST_ISOFF_QT_SIDX_PARSER_FINISHED
+} GstSidxParserStatus;
+
+typedef struct _GstSidxParser
+{
+  GstSidxParserStatus status;
+
+  guint64 size;
+  guint64 cumulative_entry_size;
+  guint64 cumulative_pts;
+
+  GstSidxBox sidx;
+} GstSidxParser;
+
+void gst_isoff_qt_sidx_parser_init (GstSidxParser * parser);
+void gst_isoff_qt_sidx_parser_clear (GstSidxParser * parser);
+GstIsoffParserResult gst_isoff_qt_sidx_parser_add_data (GstSidxParser * parser, const guint8 * buffer, gint length, guint * consumed);
+GstIsoffParserResult gst_isoff_qt_sidx_parser_add_buffer (GstSidxParser * parser, GstBuffer * buf, guint * consumed);
+
+G_END_DECLS
+
+#endif /* __GST_ISOFF_QT_H__ */
+
diff --git a/gst/isomp4/gstqtmux.c b/gst/isomp4/gstqtmux.c
index 08aa05c..7f72443 100644
--- a/gst/isomp4/gstqtmux.c
+++ b/gst/isomp4/gstqtmux.c
@@ -2,6 +2,7 @@
  * Copyright (C) 2008-2010 Thiago Santos <thiagoss@embedded.ufcg.edu.br>
  * Copyright (C) 2008 Mark Nauwelaerts <mnauw@users.sf.net>
  * Copyright (C) 2010 Nokia Corporation. All rights reserved.
+ * Copyright (C) 2014 Jan Schmidt <jan@centricular.com>
  * Contact: Stefan Kost <stefan.kost@nokia.com>
 
  * This library is free software; you can redistribute it and/or
@@ -80,6 +81,21 @@
  * #GstQTMux:streamable allows foregoing to add index metadata (at the end of
  * file).
  *
+ * When the maximum duration to be recorded can be known in advance, #GstQTMux
+ * also supports a 'Robust Muxing' mode. In robust muxing mode,  space for the
+ * headers are reserved at the start of muxing, and rewritten at a configurable
+ * interval, so that the output file is always playable, even if the recording
+ * is interrupted uncleanly by a crash. Robust muxing mode requires a seekable
+ * output, such as filesink, because it needs to rewrite the start of the file.
+ *
+ * To enable robust muxing mode, set the #GstQTMux::reserved-moov-update-period
+ * and #GstQTMux::reserved-max-duration property. Also present is the
+ * #GstQTMux::reserved-bytes-per-sec property, which can be increased if
+ * for some reason the default is not large enough and the initial reserved
+ * space for headers is too small. Applications can monitor the
+ * #GstQTMux::reserved-duration-remaining property to see how close to full
+ * the reserved space is becoming.
+ *
  * <refsect2>
  * <title>Example pipelines</title>
  * |[
@@ -101,6 +117,8 @@
 
 #include <gst/gst.h>
 #include <gst/base/gstcollectpads.h>
+#include <gst/base/gstbytereader.h>
+#include <gst/base/gstbitreader.h>
 #include <gst/audio/audio.h>
 #include <gst/video/video.h>
 #include <gst/tag/tag.h>
@@ -127,6 +145,71 @@
 GST_DEBUG_CATEGORY_STATIC (gst_qt_mux_debug);
 #define GST_CAT_DEFAULT gst_qt_mux_debug
 
+/* Hacker notes.
+ *
+ * The basic building blocks of MP4 files are:
+ *  - an 'ftyp' box at the very start
+ *  - an 'mdat' box which contains the raw audio/video/subtitle data;
+ *    this is just a bunch of bytes, completely unframed and possibly
+ *    unordered with no additional meta-information
+ *  - a 'moov' box that contains information about the different streams
+ *    and what they contain, as well as sample tables for each stream
+ *    that tell the demuxer where in the mdat box each buffer/sample is
+ *    and what its duration/timestamp etc. is, and whether it's a
+ *    keyframe etc.
+ * Additionally, fragmented MP4 works by writing chunks of data in
+ * pairs of 'moof' and 'mdat' boxes:
+ *  - 'moof' boxes, header preceding each mdat fragment describing the
+ *    contents, like a moov but only for that fragment.
+ *  - a 'mfra' box for Fragmented MP4, which is written at the end and
+ *    contains a summary of all fragments and seek tables.
+ *
+ * Currently mp4mux can work in 4 different modes / generate 4 types
+ * of output files/streams:
+ *
+ * - Normal mp4: mp4mux will write a little ftyp identifier at the
+ *   beginning, then start an mdat box into which it will write all the
+ *   sample data. At EOS it will then write the moov header with track
+ *   headers and sample tables at the end of the file, and rewrite the
+ *   start of the file to fix up the mdat box size at the beginning.
+ *   It has to wait for EOS to write the moov (which includes the
+ *   sample tables) because it doesn't know how much space those
+ *   tables will be. The output downstream must be seekable to rewrite
+ *   the mdat box at EOS.
+ *
+ * - Fragmented mp4: moov header with track headers at start
+ *   but no sample table, followed by N fragments, each containing
+ *   track headers with sample tables followed by some data. Downstream
+ *   does not need to be seekable if the 'streamable' flag is TRUE,
+ *   as the final mfra and total duration will be omitted.
+ *
+ * - Fast-start mp4: the goal here is to create a file where the moov
+ *   headers are at the beginning; what mp4mux will do is write all
+ *   sample data into a temp file and build moov header plus sample
+ *   tables in memory and then when EOS comes, it will push out the
+ *   moov header plus sample tables at the beginning, followed by the
+ *   mdat sample data at the end which is read in from the temp file
+ *   Files created in this mode are better for streaming over the
+ *   network, since the client doesn't have to seek to the end of the
+ *   file to get the headers, but it requires copying all sample data
+ *   out of the temp file at EOS, which can be expensive. Downstream does
+ *   not need to be seekable, because of the use of the temp file.
+ *
+ * - Robust Muxing mode: In this mode, qtmux uses the reserved-max-duration
+ *   and reserved-moov-update-period properties to reserve free space
+ *   at the start of the file and periodically write the MOOV atom out
+ *   to it. That means that killing the muxing at any point still
+ *   results in a playable file, at the cost of wasting some amount of
+ *   free space at the start of file. The approximate recording duration
+ *   has to be known in advance to estimate how much free space to reserve
+ *   for the moov, and the downstream must be seekable.
+ *   If the moov header grows larger than the reserved space, an error
+ *   is generated - so it's better to over-estimate the amount of space
+ *   to reserve. To ensure the file is playable at any point, the moov
+ *   is updated using a 'ping-pong' strategy, so the output is never in
+ *   an invalid state.
+ */
+
 #ifndef GST_REMOVE_DEPRECATED
 enum
 {
@@ -176,6 +259,10 @@ enum
   PROP_MOOV_RECOV_FILE,
   PROP_FRAGMENT_DURATION,
   PROP_STREAMABLE,
+  PROP_RESERVED_MAX_DURATION,
+  PROP_RESERVED_DURATION_REMAINING,
+  PROP_RESERVED_MOOV_UPDATE_PERIOD,
+  PROP_RESERVED_BYTES_PER_SEC,
 #ifndef GST_REMOVE_DEPRECATED
   PROP_DTS_METHOD,
 #endif
@@ -185,7 +272,7 @@ enum
 /* some spare for header size as well */
 #define MDAT_LARGE_FILE_LIMIT           ((guint64) 1024 * 1024 * 1024 * 2)
 
-#define DEFAULT_MOVIE_TIMESCALE         1000
+#define DEFAULT_MOVIE_TIMESCALE         1800
 #define DEFAULT_TRAK_TIMESCALE          0
 #define DEFAULT_DO_CTTS                 TRUE
 #define DEFAULT_FAST_START              FALSE
@@ -196,7 +283,9 @@ enum
 #ifndef GST_REMOVE_DEPRECATED
 #define DEFAULT_DTS_METHOD              DTS_METHOD_REORDER
 #endif
-
+#define DEFAULT_RESERVED_MAX_DURATION   GST_CLOCK_TIME_NONE
+#define DEFAULT_RESERVED_MOOV_UPDATE_PERIOD   GST_CLOCK_TIME_NONE
+#define DEFAULT_RESERVED_BYTES_PER_SEC_PER_TRAK 550
 
 static void gst_qt_mux_finalize (GObject * object);
 
@@ -223,6 +312,9 @@ static GstFlowReturn gst_qt_mux_handle_buffer (GstCollectPads * pads,
 static GstFlowReturn gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad,
     GstBuffer * buf);
 
+static GstFlowReturn
+gst_qt_mux_robust_recording_rewrite_moov (GstQTMux * qtmux);
+
 static GstElementClass *parent_class = NULL;
 
 static void
@@ -281,6 +373,7 @@ gst_qt_mux_class_init (GstQTMuxClass * klass)
 {
   GObjectClass *gobject_class;
   GstElementClass *gstelement_class;
+  GParamFlags streamable_flags;
   const gchar *streamable_desc;
   gboolean streamable;
 #define STREAMABLE_DESC "If set to true, the output should be as if it is to "\
@@ -295,12 +388,14 @@ gst_qt_mux_class_init (GstQTMuxClass * klass)
   gobject_class->get_property = gst_qt_mux_get_property;
   gobject_class->set_property = gst_qt_mux_set_property;
 
+  streamable_flags = G_PARAM_READWRITE | G_PARAM_CONSTRUCT;
   if (klass->format == GST_QT_MUX_FORMAT_ISML) {
     streamable_desc = STREAMABLE_DESC;
     streamable = DEFAULT_STREAMABLE;
   } else {
     streamable_desc =
         STREAMABLE_DESC " (DEPRECATED, only valid for fragmented MP4)";
+    streamable_flags |= G_PARAM_DEPRECATED;
     streamable = FALSE;
   }
 
@@ -323,7 +418,7 @@ gst_qt_mux_class_init (GstQTMuxClass * klass)
 #ifndef GST_REMOVE_DEPRECATED
   g_object_class_install_property (gobject_class, PROP_DTS_METHOD,
       g_param_spec_enum ("dts-method", "dts-method",
-          "(DEPRECATED) Method to determine DTS time",
+          "Method to determine DTS time (DEPRECATED)",
           GST_TYPE_QT_MUX_DTS_METHOD, DEFAULT_DTS_METHOD,
           G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
           G_PARAM_STATIC_STRINGS));
@@ -354,7 +449,34 @@ gst_qt_mux_class_init (GstQTMuxClass * klass)
           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
   g_object_class_install_property (gobject_class, PROP_STREAMABLE,
       g_param_spec_boolean ("streamable", "Streamable", streamable_desc,
-          streamable,
+          streamable, streamable_flags | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RESERVED_MAX_DURATION,
+      g_param_spec_uint64 ("reserved-max-duration",
+          "Reserved maximum file duration (ns)",
+          "When set to a value > 0, reserves space for index tables at the "
+          "beginning of the file.",
+          0, G_MAXUINT64, DEFAULT_RESERVED_MAX_DURATION,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_RESERVED_DURATION_REMAINING,
+      g_param_spec_uint64 ("reserved-duration-remaining",
+          "Report the approximate amount of remaining recording space (ns)",
+          "Reports the approximate amount of remaining moov header space "
+          "reserved using reserved-max-duration", 0, G_MAXUINT64, 0,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_RESERVED_MOOV_UPDATE_PERIOD,
+      g_param_spec_uint64 ("reserved-moov-update-period",
+          "Interval at which to update index tables (ns)",
+          "When used with reserved-max-duration, periodically updates the "
+          "index tables with information muxed so far.", 0, G_MAXUINT64,
+          DEFAULT_RESERVED_MOOV_UPDATE_PERIOD,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RESERVED_BYTES_PER_SEC,
+      g_param_spec_uint ("reserved-bytes-per-sec",
+          "Reserved MOOV bytes per second, per track",
+          "Multiplier for converting reserved-max-duration into bytes of header to reserve, per second, per track",
+          0, 10000, DEFAULT_RESERVED_BYTES_PER_SEC_PER_TRAK,
           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 
   gstelement_class->request_new_pad =
@@ -371,7 +493,9 @@ gst_qt_mux_pad_reset (GstQTPad * qtpad)
   qtpad->sample_size = 0;
   qtpad->sync = FALSE;
   qtpad->last_dts = 0;
+  qtpad->dts_adjustment = GST_CLOCK_TIME_NONE;
   qtpad->first_ts = GST_CLOCK_TIME_NONE;
+  qtpad->first_dts = GST_CLOCK_TIME_NONE;
   qtpad->prepare_buf_func = NULL;
   qtpad->create_empty_buffer = NULL;
   qtpad->avg_bitrate = 0;
@@ -383,8 +507,12 @@ gst_qt_mux_pad_reset (GstQTPad * qtpad)
   qtpad->buf_head = 0;
   qtpad->buf_tail = 0;
 
-  if (qtpad->last_buf)
-    gst_buffer_replace (&qtpad->last_buf, NULL);
+  gst_buffer_replace (&qtpad->last_buf, NULL);
+
+  if (qtpad->tags) {
+    gst_tag_list_unref (qtpad->tags);
+    qtpad->tags = NULL;
+  }
 
   /* reference owned elsewhere */
   qtpad->trak = NULL;
@@ -410,6 +538,7 @@ gst_qt_mux_reset (GstQTMux * qtmux, gboolean alloc)
   qtmux->state = GST_QT_MUX_STATE_NONE;
   qtmux->header_size = 0;
   qtmux->mdat_size = 0;
+  qtmux->moov_pos = 0;
   qtmux->mdat_pos = 0;
   qtmux->longest_chunk = GST_CLOCK_TIME_NONE;
   qtmux->video_pads = 0;
@@ -469,6 +598,11 @@ gst_qt_mux_reset (GstQTMux * qtmux, gboolean alloc)
       atom_moov_add_trak (qtmux->moov, qtpad->trak);
     }
   }
+
+  qtmux->reserved_moov_size = 0;
+  qtmux->last_moov_update = GST_CLOCK_TIME_NONE;
+  qtmux->muxed_since_last_update = 0;
+  qtmux->reserved_duration_remaining = GST_CLOCK_TIME_NONE;
 }
 
 static void
@@ -493,6 +627,11 @@ gst_qt_mux_init (GstQTMux * qtmux, GstQTMuxClass * qtmux_klass)
 
   /* properties set to default upon construction */
 
+  qtmux->reserved_max_duration = DEFAULT_RESERVED_MAX_DURATION;
+  qtmux->reserved_moov_update_period = DEFAULT_RESERVED_MOOV_UPDATE_PERIOD;
+  qtmux->reserved_bytes_per_sec_per_trak =
+      DEFAULT_RESERVED_BYTES_PER_SEC_PER_TRAK;
+
   /* always need this */
   qtmux->context =
       atoms_context_new (gst_qt_mux_map_format_to_flavor (qtmux_klass->format));
@@ -555,16 +694,19 @@ gst_qt_mux_prepare_tx3g_buffer (GstQTPad * qtpad, GstBuffer * buf,
   GstMapInfo frommap;
   GstMapInfo tomap;
   gsize size;
+  const guint8 *dataend;
 
   GST_LOG_OBJECT (qtmux, "Preparing tx3g buffer %" GST_PTR_FORMAT, buf);
 
   if (buf == NULL)
     return NULL;
 
-  size = gst_buffer_get_size (buf);
+  gst_buffer_map (buf, &frommap, GST_MAP_READ);
+
+  dataend = memchr (frommap.data, 0, frommap.size);
+  size = dataend ? dataend - frommap.data : frommap.size;
   newbuf = gst_buffer_new_and_alloc (size + 2);
 
-  gst_buffer_map (buf, &frommap, GST_MAP_READ);
   gst_buffer_map (newbuf, &tomap, GST_MAP_WRITE);
 
   GST_WRITE_UINT16_BE (tomap.data, size);
@@ -575,11 +717,91 @@ gst_qt_mux_prepare_tx3g_buffer (GstQTPad * qtpad, GstBuffer * buf,
 
   gst_buffer_copy_into (newbuf, buf, GST_BUFFER_COPY_METADATA, 0, size);
 
+  /* gst_buffer_copy_into is trying to be too clever and
+   * won't copy duration when size is different */
+  GST_BUFFER_DURATION (newbuf) = GST_BUFFER_DURATION (buf);
+
   gst_buffer_unref (buf);
 
   return newbuf;
 }
 
+static void
+gst_qt_mux_pad_add_ac3_extension (GstQTMux * qtmux, GstQTPad * qtpad,
+    guint8 fscod, guint8 frmsizcod, guint8 bsid, guint8 bsmod, guint8 acmod,
+    guint8 lfe_on)
+{
+  AtomInfo *ext;
+
+  g_return_if_fail (qtpad->trak_ste);
+
+  ext = build_ac3_extension (fscod, bsid, bsmod, acmod, lfe_on, frmsizcod >> 1);        /* bitrate_code is inside frmsizcod */
+
+  sample_table_entry_add_ext_atom (qtpad->trak_ste, ext);
+}
+
+static GstBuffer *
+gst_qt_mux_prepare_parse_ac3_frame (GstQTPad * qtpad, GstBuffer * buf,
+    GstQTMux * qtmux)
+{
+  GstMapInfo map;
+  GstByteReader reader;
+  guint off;
+
+  if (!gst_buffer_map (buf, &map, GST_MAP_READ)) {
+    GST_WARNING_OBJECT (qtpad->collect.pad, "Failed to map buffer");
+    return buf;
+  }
+
+  if (G_UNLIKELY (map.size < 8))
+    goto done;
+
+  gst_byte_reader_init (&reader, map.data, map.size);
+  off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffff0000, 0x0b770000,
+      0, map.size);
+
+  if (off != -1) {
+    GstBitReader bits;
+    guint8 fscod, frmsizcod, bsid, bsmod, acmod, lfe_on;
+
+    GST_DEBUG_OBJECT (qtpad->collect.pad, "Found ac3 sync point at offset: %u",
+        off);
+
+    gst_bit_reader_init (&bits, map.data, map.size);
+
+    /* off + sync + crc */
+    gst_bit_reader_skip_unchecked (&bits, off * 8 + 16 + 16);
+
+    fscod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+    frmsizcod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 6);
+    bsid = gst_bit_reader_get_bits_uint8_unchecked (&bits, 5);
+    bsmod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+    acmod = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+
+    if ((acmod & 0x1) && (acmod != 0x1))        /* 3 front channels */
+      gst_bit_reader_skip_unchecked (&bits, 2);
+    if ((acmod & 0x4))          /* if a surround channel exists */
+      gst_bit_reader_skip_unchecked (&bits, 2);
+    if (acmod == 0x2)           /* if in 2/0 mode */
+      gst_bit_reader_skip_unchecked (&bits, 2);
+
+    lfe_on = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+
+    gst_qt_mux_pad_add_ac3_extension (qtmux, qtpad, fscod, frmsizcod, bsid,
+        bsmod, acmod, lfe_on);
+
+    /* AC-3 spec says that those values should be constant for the
+     * whole stream when muxed in mp4. We trust the input follows it */
+    GST_DEBUG_OBJECT (qtpad->collect.pad, "Data parsed, removing "
+        "prepare buffer function");
+    qtpad->prepare_buf_func = NULL;
+  }
+
+done:
+  gst_buffer_unmap (buf, &map);
+  return buf;
+}
+
 static GstBuffer *
 gst_qt_mux_create_empty_tx3g_buffer (GstQTPad * qtpad, gint64 duration)
 {
@@ -588,12 +810,12 @@ gst_qt_mux_create_empty_tx3g_buffer (GstQTPad * qtpad, gint64 duration)
   data = g_malloc (2);
   GST_WRITE_UINT16_BE (data, 0);
 
-  return gst_buffer_new_wrapped (data, 2);;
+  return gst_buffer_new_wrapped (data, 2);
 }
 
 static void
 gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   switch (gst_tag_get_type (tag)) {
       /* strings */
@@ -605,7 +827,7 @@ gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
         break;
       GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %s",
           GST_FOURCC_ARGS (fourcc), str);
-      atom_moov_add_str_tag (qtmux->moov, fourcc, str);
+      atom_udta_add_str_tag (udta, fourcc, str);
       g_free (str);
       break;
     }
@@ -618,7 +840,7 @@ gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
         break;
       GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %u",
           GST_FOURCC_ARGS (fourcc), (gint) value);
-      atom_moov_add_uint_tag (qtmux->moov, fourcc, 21, (gint) value);
+      atom_udta_add_uint_tag (udta, fourcc, 21, (gint) value);
       break;
     }
     case G_TYPE_UINT:
@@ -635,7 +857,7 @@ gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
           break;
         GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %u/%u",
             GST_FOURCC_ARGS (fourcc), value, count);
-        atom_moov_add_uint_tag (qtmux->moov, fourcc, 0,
+        atom_udta_add_uint_tag (udta, fourcc, 0,
             value << 16 | (count & 0xFFFF));
       } else {
         /* unpaired unsigned integers */
@@ -643,7 +865,7 @@ gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
           break;
         GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %u",
             GST_FOURCC_ARGS (fourcc), value);
-        atom_moov_add_uint_tag (qtmux->moov, fourcc, 1, value);
+        atom_udta_add_uint_tag (udta, fourcc, 1, value);
       }
       break;
     }
@@ -655,7 +877,7 @@ gst_qt_mux_add_mp4_tag (GstQTMux * qtmux, const GstTagList * list,
 
 static void
 gst_qt_mux_add_mp4_date (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   GDate *date = NULL;
   GDateYear year;
@@ -683,13 +905,13 @@ gst_qt_mux_add_mp4_date (GstQTMux * qtmux, const GstTagList * list,
   str = g_strdup_printf ("%u-%u-%u", year, month, day);
   GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %s",
       GST_FOURCC_ARGS (fourcc), str);
-  atom_moov_add_str_tag (qtmux->moov, fourcc, str);
+  atom_udta_add_str_tag (udta, fourcc, str);
   g_free (str);
 }
 
 static void
 gst_qt_mux_add_mp4_cover (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   GValue value = { 0, };
   GstBuffer *buf;
@@ -735,7 +957,7 @@ gst_qt_mux_add_mp4_cover (GstQTMux * qtmux, const GstTagList * list,
   gst_buffer_map (buf, &map, GST_MAP_READ);
   GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT
       " -> image size %" G_GSIZE_FORMAT "", GST_FOURCC_ARGS (fourcc), map.size);
-  atom_moov_add_tag (qtmux->moov, fourcc, flags, map.data, map.size);
+  atom_udta_add_tag (udta, fourcc, flags, map.data, map.size);
   gst_buffer_unmap (buf, &map);
 done:
   g_value_unset (&value);
@@ -743,7 +965,7 @@ done:
 
 static void
 gst_qt_mux_add_3gp_str (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   gchar *str = NULL;
   guint number;
@@ -761,11 +983,11 @@ gst_qt_mux_add_3gp_str (GstQTMux * qtmux, const GstTagList * list,
   if (!tag2) {
     GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %s",
         GST_FOURCC_ARGS (fourcc), str);
-    atom_moov_add_3gp_str_tag (qtmux->moov, fourcc, str);
+    atom_udta_add_3gp_str_tag (udta, fourcc, str);
   } else {
     GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %s/%d",
         GST_FOURCC_ARGS (fourcc), str, number);
-    atom_moov_add_3gp_str_int_tag (qtmux->moov, fourcc, str, number);
+    atom_udta_add_3gp_str_int_tag (udta, fourcc, str, number);
   }
 
   g_free (str);
@@ -773,7 +995,7 @@ gst_qt_mux_add_3gp_str (GstQTMux * qtmux, const GstTagList * list,
 
 static void
 gst_qt_mux_add_3gp_date (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   GDate *date = NULL;
   GDateYear year;
@@ -784,6 +1006,7 @@ gst_qt_mux_add_3gp_date (GstQTMux * qtmux, const GstTagList * list,
     return;
 
   year = g_date_get_year (date);
+  g_date_free (date);
 
   if (year == G_DATE_BAD_YEAR) {
     GST_WARNING_OBJECT (qtmux, "invalid date in tag");
@@ -792,12 +1015,12 @@ gst_qt_mux_add_3gp_date (GstQTMux * qtmux, const GstTagList * list,
 
   GST_DEBUG_OBJECT (qtmux, "Adding tag %" GST_FOURCC_FORMAT " -> %d",
       GST_FOURCC_ARGS (fourcc), year);
-  atom_moov_add_3gp_uint_tag (qtmux->moov, fourcc, year);
+  atom_udta_add_3gp_uint_tag (udta, fourcc, year);
 }
 
 static void
 gst_qt_mux_add_3gp_location (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   gdouble latitude = -360, longitude = -360, altitude = 0;
   gchar *location = NULL;
@@ -845,13 +1068,13 @@ gst_qt_mux_add_3gp_location (GstQTMux * qtmux, const GstTagList * list,
   GST_WRITE_UINT16_BE (data + 13, 0);
 
   GST_DEBUG_OBJECT (qtmux, "Adding tag 'loci'");
-  atom_moov_add_3gp_tag (qtmux->moov, fourcc, ddata, size);
+  atom_udta_add_3gp_tag (udta, fourcc, ddata, size);
   g_free (ddata);
 }
 
 static void
 gst_qt_mux_add_3gp_keywords (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   gchar *keywords = NULL;
   guint8 *data, *ddata;
@@ -896,7 +1119,7 @@ gst_qt_mux_add_3gp_keywords (GstQTMux * qtmux, const GstTagList * list,
 
   g_strfreev (kwds);
 
-  atom_moov_add_3gp_tag (qtmux->moov, fourcc, ddata, size);
+  atom_udta_add_3gp_tag (udta, fourcc, ddata, size);
   g_free (ddata);
 }
 
@@ -974,7 +1197,7 @@ mismatch:
 
 static void
 gst_qt_mux_add_3gp_classification (GstQTMux * qtmux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc)
+    AtomUDTA * udta, const char *tag, const char *tag2, guint32 fourcc)
 {
   gchar *clsf_data = NULL;
   gint size = 0;
@@ -1009,12 +1232,13 @@ gst_qt_mux_add_3gp_classification (GstQTMux * qtmux, const GstTagList * list,
   memcpy (data + 8, content, size);
   g_free (content);
 
-  atom_moov_add_3gp_tag (qtmux->moov, fourcc, data, 4 + 2 + 2 + size);
+  atom_udta_add_3gp_tag (udta, fourcc, data, 4 + 2 + 2 + size);
   g_free (data);
 }
 
-typedef void (*GstQTMuxAddTagFunc) (GstQTMux * mux, const GstTagList * list,
-    const char *tag, const char *tag2, guint32 fourcc);
+typedef void (*GstQTMuxAddUdtaTagFunc) (GstQTMux * mux,
+    const GstTagList * list, AtomUDTA * udta, const char *tag,
+    const char *tag2, guint32 fourcc);
 
 /*
  * Struct to record mappings from gstreamer tags to fourcc codes
@@ -1024,7 +1248,7 @@ typedef struct _GstTagToFourcc
   guint32 fourcc;
   const gchar *gsttag;
   const gchar *gsttag2;
-  const GstQTMuxAddTagFunc func;
+  const GstQTMuxAddUdtaTagFunc func;
 } GstTagToFourcc;
 
 /* tag list tags to fourcc matching */
@@ -1035,6 +1259,7 @@ static const GstTagToFourcc tag_matches_mp4[] = {
   {FOURCC_soar, GST_TAG_ARTIST_SORTNAME, NULL, gst_qt_mux_add_mp4_tag},
   {FOURCC_aART, GST_TAG_ALBUM_ARTIST, NULL, gst_qt_mux_add_mp4_tag},
   {FOURCC_soaa, GST_TAG_ALBUM_ARTIST_SORTNAME, NULL, gst_qt_mux_add_mp4_tag},
+  {FOURCC__swr, GST_TAG_APPLICATION_NAME, NULL, gst_qt_mux_add_mp4_tag},
   {FOURCC__cmt, GST_TAG_COMMENT, NULL, gst_qt_mux_add_mp4_tag},
   {FOURCC__wrt, GST_TAG_COMPOSER, NULL, gst_qt_mux_add_mp4_tag},
   {FOURCC_soco, GST_TAG_COMPOSER_SORTNAME, NULL, gst_qt_mux_add_mp4_tag},
@@ -1101,7 +1326,7 @@ gst_qt_mux_add_xmp_tags (GstQTMux * qtmux, const GstTagList * list)
     xmp = gst_tag_xmp_writer_tag_list_to_xmp_buffer (GST_TAG_XMP_WRITER (qtmux),
         list, TRUE);
     if (xmp)
-      atom_moov_add_xmp_tags (qtmux->moov, xmp);
+      atom_udta_add_xmp_tags (&qtmux->moov->udta, xmp);
   } else {
     AtomInfo *ainfo;
     /* for isom/mp4, it is a top level uuid atom */
@@ -1119,7 +1344,8 @@ gst_qt_mux_add_xmp_tags (GstQTMux * qtmux, const GstTagList * list)
 }
 
 static void
-gst_qt_mux_add_metadata_tags (GstQTMux * qtmux, const GstTagList * list)
+gst_qt_mux_add_metadata_tags (GstQTMux * qtmux, const GstTagList * list,
+    AtomUDTA * udta)
 {
   GstQTMuxClass *qtmux_klass = (GstQTMuxClass *) (G_OBJECT_GET_CLASS (qtmux));
   guint32 fourcc;
@@ -1143,13 +1369,16 @@ gst_qt_mux_add_metadata_tags (GstQTMux * qtmux, const GstTagList * list)
   if (!tag_matches)
     return;
 
+  /* Clear existing tags so we don't add them over and over */
+  atom_udta_clear_tags (udta);
+
   for (i = 0; tag_matches[i].fourcc; i++) {
     fourcc = tag_matches[i].fourcc;
     tag = tag_matches[i].gsttag;
     tag2 = tag_matches[i].gsttag2;
 
     g_assert (tag_matches[i].func);
-    tag_matches[i].func (qtmux, list, tag, tag2, fourcc);
+    tag_matches[i].func (qtmux, list, udta, tag, tag2, fourcc);
   }
 
   /* add unparsed blobs if present */
@@ -1183,11 +1412,12 @@ gst_qt_mux_add_metadata_tags (GstQTMux * qtmux, const GstTagList * list)
               (strcmp (style, "iso") == 0 &&
                   qtmux_klass->format == GST_QT_MUX_FORMAT_3GP)) {
             GST_DEBUG_OBJECT (qtmux, "Adding private tag");
-            atom_moov_add_blob_tag (qtmux->moov, map.data, map.size);
+            atom_udta_add_blob_tag (udta, map.data, map.size);
           }
         }
         gst_buffer_unmap (buf, &map);
       }
+      gst_sample_unref (sample);
     }
   }
 
@@ -1201,10 +1431,14 @@ gst_qt_mux_add_metadata_tags (GstQTMux * qtmux, const GstTagList * list)
 static void
 gst_qt_mux_setup_metadata (GstQTMux * qtmux)
 {
-  const GstTagList *tags;
+  const GstTagList *tags = NULL;
+  GSList *walk;
 
   GST_OBJECT_LOCK (qtmux);
-  tags = gst_tag_setter_get_tag_list (GST_TAG_SETTER (qtmux));
+  if (qtmux->tags_changed) {
+    tags = gst_tag_setter_get_tag_list (GST_TAG_SETTER (qtmux));
+    qtmux->tags_changed = FALSE;
+  }
   GST_OBJECT_UNLOCK (qtmux);
 
   GST_LOG_OBJECT (qtmux, "tags: %" GST_PTR_FORMAT, tags);
@@ -1218,11 +1452,27 @@ gst_qt_mux_setup_metadata (GstQTMux * qtmux)
     gst_tag_list_remove_tag (copy, GST_TAG_CONTAINER_FORMAT);
 
     GST_DEBUG_OBJECT (qtmux, "Formatting tags");
-    gst_qt_mux_add_metadata_tags (qtmux, copy);
+    gst_qt_mux_add_metadata_tags (qtmux, copy, &qtmux->moov->udta);
     gst_qt_mux_add_xmp_tags (qtmux, copy);
     gst_tag_list_unref (copy);
   } else {
-    GST_DEBUG_OBJECT (qtmux, "No tags received");
+    GST_DEBUG_OBJECT (qtmux, "No new tags received");
+  }
+
+  for (walk = qtmux->sinkpads; walk; walk = g_slist_next (walk)) {
+    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstQTPad *qpad = (GstQTPad *) cdata;
+    GstPad *pad = qpad->collect.pad;
+
+    if (qpad->tags_changed && qpad->tags) {
+      GST_DEBUG_OBJECT (pad, "Adding tags");
+      gst_tag_list_remove_tag (qpad->tags, GST_TAG_CONTAINER_FORMAT);
+      gst_qt_mux_add_metadata_tags (qtmux, qpad->tags, &qpad->trak->udta);
+      qpad->tags_changed = FALSE;
+      GST_DEBUG_OBJECT (pad, "Tags added");
+    } else {
+      GST_DEBUG_OBJECT (pad, "No new tags received");
+    }
   }
 }
 
@@ -1377,46 +1627,55 @@ fail:
  */
 static GstFlowReturn
 gst_qt_mux_send_mdat_header (GstQTMux * qtmux, guint64 * off, guint64 size,
-    gboolean extended)
+    gboolean extended, gboolean fsync_after)
 {
-  Atom *node_header;
   GstBuffer *buf;
-  guint8 *data = NULL;
-  guint64 offset = 0;
+  GstMapInfo map;
 
   GST_DEBUG_OBJECT (qtmux, "Sending mdat's atom header, "
       "size %" G_GUINT64_FORMAT, size);
 
-  node_header = g_malloc0 (sizeof (Atom));
-  node_header->type = FOURCC_mdat;
+  /* if the qtmux state is EOS, really write the mdat, otherwise
+   * allow size == 0 for a placeholder atom */
+  if (qtmux->state == GST_QT_MUX_STATE_EOS || size > 0)
+    size += 8;
+
   if (extended) {
-    /* use extended size */
-    node_header->size = 1;
-    node_header->extended_size = 0;
-    if (size)
-      node_header->extended_size = size + 16;
+    gboolean large_file = (size > MDAT_LARGE_FILE_LIMIT);
+    /* Always write 16-bytes, but put a free atom first
+     * if the size is < 4GB. */
+    buf = gst_buffer_new_and_alloc (16);
+    gst_buffer_map (buf, &map, GST_MAP_WRITE);
+
+    if (large_file) {
+      /* Write extended mdat header and large_size field */
+      GST_WRITE_UINT32_BE (map.data, 1);
+      GST_WRITE_UINT32_LE (map.data + 4, FOURCC_mdat);
+      GST_WRITE_UINT64_BE (map.data + 8, size + 8);
+    } else {
+      /* Write an empty free atom, then standard 32-bit mdat */
+      GST_WRITE_UINT32_BE (map.data, 8);
+      GST_WRITE_UINT32_LE (map.data + 4, FOURCC_free);
+      GST_WRITE_UINT32_BE (map.data + 8, size);
+      GST_WRITE_UINT32_LE (map.data + 12, FOURCC_mdat);
+    }
+    gst_buffer_unmap (buf, &map);
   } else {
-    node_header->size = size + 8;
-  }
+    buf = gst_buffer_new_and_alloc (8);
+    gst_buffer_map (buf, &map, GST_MAP_WRITE);
 
-  size = offset = 0;
-  if (atom_copy_data (node_header, &data, &size, &offset) == 0)
-    goto serialize_error;
+    /* Vanilla 32-bit mdat */
+    GST_WRITE_UINT32_BE (map.data, size);
+    GST_WRITE_UINT32_LE (map.data + 4, FOURCC_mdat);
+    gst_buffer_unmap (buf, &map);
+  }
 
-  buf = _gst_buffer_new_take_data (data, offset);
-  g_free (node_header);
+  GST_LOG_OBJECT (qtmux, "Pushing mdat header");
+  if (fsync_after)
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_SYNC_AFTER);
 
-  GST_LOG_OBJECT (qtmux, "Pushing mdat start");
   return gst_qt_mux_send_buffer (qtmux, buf, off, FALSE);
 
-  /* ERRORS */
-serialize_error:
-  {
-    GST_ELEMENT_ERROR (qtmux, STREAM, MUX, (NULL),
-        ("Failed to serialize mdat"));
-    g_free (node_header);
-    return GST_FLOW_ERROR;
-  }
 }
 
 /*
@@ -1425,38 +1684,20 @@ serialize_error:
  */
 static GstFlowReturn
 gst_qt_mux_update_mdat_size (GstQTMux * qtmux, guint64 mdat_pos,
-    guint64 mdat_size, guint64 * offset)
+    guint64 mdat_size, guint64 * offset, gboolean fsync_after)
 {
-  GstBuffer *buf;
-  gboolean large_file;
   GstSegment segment;
-  GstMapInfo map;
 
-  large_file = (mdat_size > MDAT_LARGE_FILE_LIMIT);
-
-  if (large_file)
-    mdat_pos += 8;
+  /* We must have recorded the mdat position for this to work */
+  g_assert (mdat_pos != 0);
 
   /* seek and rewrite the header */
   gst_segment_init (&segment, GST_FORMAT_BYTES);
   segment.start = mdat_pos;
   gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
 
-  if (large_file) {
-    buf = gst_buffer_new_and_alloc (sizeof (guint64));
-    gst_buffer_map (buf, &map, GST_MAP_WRITE);
-    GST_WRITE_UINT64_BE (map.data, mdat_size + 16);
-  } else {
-    buf = gst_buffer_new_and_alloc (16);
-    gst_buffer_map (buf, &map, GST_MAP_WRITE);
-    GST_WRITE_UINT32_BE (map.data, 8);
-    GST_WRITE_UINT32_LE (map.data + 4, FOURCC_free);
-    GST_WRITE_UINT32_BE (map.data + 8, mdat_size + 8);
-    GST_WRITE_UINT32_LE (map.data + 12, FOURCC_mdat);
-  }
-  gst_buffer_unmap (buf, &map);
-
-  return gst_qt_mux_send_buffer (qtmux, buf, offset, FALSE);
+  return gst_qt_mux_send_mdat_header (qtmux, offset, mdat_size, TRUE,
+      fsync_after);
 }
 
 static GstFlowReturn
@@ -1563,15 +1804,83 @@ gst_qt_mux_set_header_on_caps (GstQTMux * mux, GstBuffer * buf)
   gst_caps_unref (caps);
 }
 
+/*
+ * Write out a free space atom. The offset is adjusted by the full
+ * size, but a smaller buffer is sent
+ */
+static GstFlowReturn
+gst_qt_mux_send_free_atom (GstQTMux * qtmux, guint64 * off, guint32 size,
+    gboolean fsync_after)
+{
+  Atom *node_header;
+  GstBuffer *buf;
+  guint8 *data = NULL;
+  guint64 offset = 0, bsize = 0;
+  GstFlowReturn ret;
+
+  GST_DEBUG_OBJECT (qtmux, "Sending free atom header of size %u", size);
+
+  /* We can't make a free space atom smaller than the header */
+  if (size < 8)
+    goto too_small;
+
+  node_header = g_malloc0 (sizeof (Atom));
+  node_header->type = FOURCC_free;
+  node_header->size = size;
+
+  bsize = offset = 0;
+  if (atom_copy_data (node_header, &data, &bsize, &offset) == 0)
+    goto serialize_error;
+
+  buf = _gst_buffer_new_take_data (data, offset);
+  g_free (node_header);
+
+  if (fsync_after)
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_SYNC_AFTER);
+
+  GST_LOG_OBJECT (qtmux, "Pushing free atom");
+  ret = gst_qt_mux_send_buffer (qtmux, buf, off, FALSE);
+
+  if (off) {
+    GstSegment segment;
+
+    *off += size - 8;
+
+    /* Make sure downstream position ends up at the end of this free box */
+    gst_segment_init (&segment, GST_FORMAT_BYTES);
+    segment.start = *off;
+    gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
+  }
+
+  return ret;
+
+  /* ERRORS */
+too_small:
+  {
+    GST_ELEMENT_ERROR (qtmux, STREAM, MUX, (NULL),
+        ("Not enough free reserved space"));
+    return GST_FLOW_ERROR;
+  }
+serialize_error:
+  {
+    GST_ELEMENT_ERROR (qtmux, STREAM, MUX, (NULL),
+        ("Failed to serialize mdat"));
+    g_free (node_header);
+    return GST_FLOW_ERROR;
+  }
+}
+
 static void
-gst_qt_mux_configure_moov (GstQTMux * qtmux, guint32 * _timescale)
+gst_qt_mux_configure_moov (GstQTMux * qtmux)
 {
-  gboolean fragmented;
+  gboolean fragmented = FALSE;
   guint32 timescale;
 
   GST_OBJECT_LOCK (qtmux);
   timescale = qtmux->timescale;
-  fragmented = qtmux->fragment_sequence > 0;
+  if (qtmux->mux_mode == GST_QT_MUX_MODE_FRAGMENTED ||
+      qtmux->mux_mode == GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE)
+    fragmented = TRUE;
   GST_OBJECT_UNLOCK (qtmux);
 
   /* inform lower layers of our property wishes, and determine duration.
@@ -1583,13 +1892,11 @@ gst_qt_mux_configure_moov (GstQTMux * qtmux, guint32 * _timescale)
   atom_moov_set_fragmented (qtmux->moov, fragmented);
 
   atom_moov_update_duration (qtmux->moov);
-
-  if (_timescale)
-    *_timescale = timescale;
 }
 
 static GstFlowReturn
-gst_qt_mux_send_moov (GstQTMux * qtmux, guint64 * _offset, gboolean mind_fast)
+gst_qt_mux_send_moov (GstQTMux * qtmux, guint64 * _offset,
+    guint64 padded_moov_size, gboolean mind_fast, gboolean fsync_after)
 {
   guint64 offset = 0, size = 0;
   guint8 *data;
@@ -1602,14 +1909,41 @@ gst_qt_mux_send_moov (GstQTMux * qtmux, guint64 * _offset, gboolean mind_fast)
   GST_LOG_OBJECT (qtmux, "Copying movie header into buffer");
   if (!atom_moov_copy_data (qtmux->moov, &data, &size, &offset))
     goto serialize_error;
+  qtmux->last_moov_size = offset;
 
+  /* Check we have enough reserved space for this and a Free atom */
+  if (padded_moov_size > 0 && offset + 8 > padded_moov_size)
+    goto too_small_reserved;
   buf = _gst_buffer_new_take_data (data, offset);
   GST_DEBUG_OBJECT (qtmux, "Pushing moov atoms");
-  gst_qt_mux_set_header_on_caps (qtmux, buf);
+
+  /* If at EOS, this is the final moov, put in the streamheader
+   * (apparently used by a flumotion util) */
+  if (qtmux->state == GST_QT_MUX_STATE_EOS)
+    gst_qt_mux_set_header_on_caps (qtmux, buf);
+
+  if (fsync_after)
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_SYNC_AFTER);
   ret = gst_qt_mux_send_buffer (qtmux, buf, _offset, mind_fast);
 
-  return ret;
+  /* Write out a free atom if needed */
+  if (ret == GST_FLOW_OK && offset < padded_moov_size) {
+    GST_LOG_OBJECT (qtmux, "Writing out free atom of size %u",
+        (guint32) (padded_moov_size - offset));
+    ret =
+        gst_qt_mux_send_free_atom (qtmux, _offset, padded_moov_size - offset,
+        fsync_after);
+  }
 
+  return ret;
+too_small_reserved:
+  {
+    GST_ELEMENT_ERROR (qtmux, STREAM, MUX,
+        ("Not enough free reserved header space"),
+        ("Needed %" G_GUINT64_FORMAT " bytes, reserved %" G_GUINT64_FORMAT,
+            offset, padded_moov_size));
+    return GST_FLOW_ERROR;
+  }
 serialize_error:
   {
     g_free (data);
@@ -1661,6 +1995,75 @@ serialize_error:
   }
 }
 
+static gboolean
+gst_qt_mux_downstream_is_seekable (GstQTMux * qtmux)
+{
+  gboolean seekable = FALSE;
+  GstQuery *query = gst_query_new_seeking (GST_FORMAT_BYTES);
+
+  if (gst_pad_peer_query (qtmux->srcpad, query)) {
+    gst_query_parse_seeking (query, NULL, &seekable, NULL, NULL);
+    GST_INFO_OBJECT (qtmux, "downstream is %sseekable", seekable ? "" : "not ");
+  } else {
+    /* have to assume seeking is not supported if query not handled downstream */
+    GST_WARNING_OBJECT (qtmux, "downstream did not handle seeking query");
+    seekable = FALSE;
+  }
+  gst_query_unref (query);
+
+  return seekable;
+}
+
+static void
+gst_qt_mux_prepare_moov_recovery (GstQTMux * qtmux)
+{
+  GSList *walk;
+  gboolean fail = FALSE;
+  AtomFTYP *ftyp = NULL;
+  GstBuffer *prefix = NULL;
+
+  GST_DEBUG_OBJECT (qtmux, "Openning moov recovery file: %s",
+      qtmux->moov_recov_file_path);
+
+  qtmux->moov_recov_file = g_fopen (qtmux->moov_recov_file_path, "wb+");
+  if (qtmux->moov_recov_file == NULL) {
+    GST_WARNING_OBJECT (qtmux, "Failed to open moov recovery file in %s",
+        qtmux->moov_recov_file_path);
+    return;
+  }
+
+  gst_qt_mux_prepare_ftyp (qtmux, &ftyp, &prefix);
+
+  if (!atoms_recov_write_headers (qtmux->moov_recov_file, ftyp, prefix,
+          qtmux->moov, qtmux->timescale, g_slist_length (qtmux->sinkpads))) {
+    GST_WARNING_OBJECT (qtmux, "Failed to write moov recovery file " "headers");
+    goto fail;
+  }
+
+  atom_ftyp_free (ftyp);
+  if (prefix)
+    gst_buffer_unref (prefix);
+
+  for (walk = qtmux->sinkpads; walk && !fail; walk = g_slist_next (walk)) {
+    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstQTPad *qpad = (GstQTPad *) cdata;
+    /* write info for each stream */
+    fail = atoms_recov_write_trak_info (qtmux->moov_recov_file, qpad->trak);
+    if (fail) {
+      GST_WARNING_OBJECT (qtmux, "Failed to write trak info to recovery "
+          "file");
+      break;
+    }
+  }
+
+fail:
+  /* cleanup */
+  fclose (qtmux->moov_recov_file);
+  qtmux->moov_recov_file = NULL;
+  GST_WARNING_OBJECT (qtmux, "An error was detected while writing to "
+      "recover file, moov recovery won't work");
+}
+
 static GstFlowReturn
 gst_qt_mux_start_file (GstQTMux * qtmux)
 {
@@ -1669,9 +2072,16 @@ gst_qt_mux_start_file (GstQTMux * qtmux)
   GstCaps *caps;
   GstSegment segment;
   gchar s_id[32];
+  GstClockTime reserved_max_duration;
+  guint reserved_bytes_per_sec_per_trak;
 
   GST_DEBUG_OBJECT (qtmux, "starting file");
 
+  GST_OBJECT_LOCK (qtmux);
+  reserved_max_duration = qtmux->reserved_max_duration;
+  reserved_bytes_per_sec_per_trak = qtmux->reserved_bytes_per_sec_per_trak;
+  GST_OBJECT_UNLOCK (qtmux);
+
   /* stream-start (FIXME: create id based on input ids) */
   g_snprintf (s_id, sizeof (s_id), "qtmux-%08x", g_random_int ());
   gst_pad_push_event (qtmux->srcpad, gst_event_new_stream_start (s_id));
@@ -1683,39 +2093,52 @@ gst_qt_mux_start_file (GstQTMux * qtmux)
   gst_pad_set_caps (qtmux->srcpad, caps);
   gst_caps_unref (caps);
 
-  /* if not streaming, check if downstream is seekable */
-  if (!qtmux->streamable) {
-    gboolean seekable;
-    GstQuery *query;
+  /* Default is 'normal' mode */
+  qtmux->mux_mode = GST_QT_MUX_MODE_MOOV_AT_END;
 
-    query = gst_query_new_seeking (GST_FORMAT_BYTES);
-    if (gst_pad_peer_query (qtmux->srcpad, query)) {
-      gst_query_parse_seeking (query, NULL, &seekable, NULL, NULL);
-      GST_INFO_OBJECT (qtmux, "downstream is %sseekable",
-          seekable ? "" : "not ");
-    } else {
-      /* have to assume seeking is supported if query not handled downstream */
-      GST_WARNING_OBJECT (qtmux, "downstream did not handle seeking query");
-      seekable = FALSE;
-    }
-    gst_query_unref (query);
-    if (!seekable) {
-      if (qtmux_klass->format != GST_QT_MUX_FORMAT_ISML) {
-        if (!qtmux->fast_start) {
-          GST_ELEMENT_WARNING (qtmux, STREAM, FAILED,
-              ("Downstream is not seekable and headers can't be rewritten"),
-              (NULL));
-          /* FIXME: Is there something better we can do? */
-          qtmux->streamable = TRUE;
-        }
-      } else {
+  /* Require a sensible fragment duration when muxing
+   * using the ISML muxer */
+  if (qtmux_klass->format == GST_QT_MUX_FORMAT_ISML &&
+      qtmux->fragment_duration == 0)
+    goto invalid_isml;
+
+  if (qtmux->fragment_duration > 0) {
+    if (qtmux->streamable)
+      qtmux->mux_mode = GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE;
+    else
+      qtmux->mux_mode = GST_QT_MUX_MODE_FRAGMENTED;
+  } else if (qtmux->fast_start) {
+    qtmux->mux_mode = GST_QT_MUX_MODE_FAST_START;
+  } else if (reserved_max_duration != GST_CLOCK_TIME_NONE) {
+    qtmux->mux_mode = GST_QT_MUX_MODE_ROBUST_RECORDING;
+  }
+
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_MOOV_AT_END:
+    case GST_QT_MUX_MODE_ROBUST_RECORDING:
+      /* We have to be able to seek to rewrite the mdat header, or any
+       * moov atom we write will not be visible in the file, because an
+       * MDAT with 0 as the size covers the rest of the file. A file
+       * with no moov is not playable, so error out now. */
+      if (!gst_qt_mux_downstream_is_seekable (qtmux)) {
+        GST_ELEMENT_ERROR (qtmux, STREAM, MUX,
+            ("Downstream is not seekable - will not be able to create a playable file"),
+            (NULL));
+        return GST_FLOW_ERROR;
+      }
+      break;
+    case GST_QT_MUX_MODE_FAST_START:
+    case GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE:
+      break;                    /* Don't need seekability, ignore */
+    case GST_QT_MUX_MODE_FRAGMENTED:
+      if (!gst_qt_mux_downstream_is_seekable (qtmux)) {
         GST_WARNING_OBJECT (qtmux, "downstream is not seekable, but "
             "streamable=false. Will ignore that and create streamable output "
             "instead");
         qtmux->streamable = TRUE;
         g_object_notify (G_OBJECT (qtmux), "streamable");
       }
-    }
+      break;
   }
 
   /* let downstream know we think in BYTES and expect to do seeking later on */
@@ -1725,136 +2148,200 @@ gst_qt_mux_start_file (GstQTMux * qtmux)
   /* initialize our moov recovery file */
   GST_OBJECT_LOCK (qtmux);
   if (qtmux->moov_recov_file_path) {
-    GST_DEBUG_OBJECT (qtmux, "Openning moov recovery file: %s",
-        qtmux->moov_recov_file_path);
-    qtmux->moov_recov_file = g_fopen (qtmux->moov_recov_file_path, "wb+");
-    if (qtmux->moov_recov_file == NULL) {
-      GST_WARNING_OBJECT (qtmux, "Failed to open moov recovery file in %s",
-          qtmux->moov_recov_file_path);
-    } else {
-      GSList *walk;
-      gboolean fail = FALSE;
-      AtomFTYP *ftyp = NULL;
-      GstBuffer *prefix = NULL;
-
-      gst_qt_mux_prepare_ftyp (qtmux, &ftyp, &prefix);
-
-      if (!atoms_recov_write_headers (qtmux->moov_recov_file, ftyp, prefix,
-              qtmux->moov, qtmux->timescale,
-              g_slist_length (qtmux->sinkpads))) {
-        GST_WARNING_OBJECT (qtmux, "Failed to write moov recovery file "
-            "headers");
-        fail = TRUE;
-      }
-
-      atom_ftyp_free (ftyp);
-      if (prefix)
-        gst_buffer_unref (prefix);
-
-      for (walk = qtmux->sinkpads; walk && !fail; walk = g_slist_next (walk)) {
-        GstCollectData *cdata = (GstCollectData *) walk->data;
-        GstQTPad *qpad = (GstQTPad *) cdata;
-        /* write info for each stream */
-        fail = atoms_recov_write_trak_info (qtmux->moov_recov_file, qpad->trak);
-        if (fail) {
-          GST_WARNING_OBJECT (qtmux, "Failed to write trak info to recovery "
-              "file");
-        }
-      }
-      if (fail) {
-        /* cleanup */
-        fclose (qtmux->moov_recov_file);
-        qtmux->moov_recov_file = NULL;
-        GST_WARNING_OBJECT (qtmux, "An error was detected while writing to "
-            "recover file, moov recovery won't work");
-      }
-    }
+    gst_qt_mux_prepare_moov_recovery (qtmux);
   }
+
+  /* Make sure the first time we update the moov, we'll
+   * include any tagsetter tags */
+  qtmux->tags_changed = TRUE;
+
   GST_OBJECT_UNLOCK (qtmux);
 
-  /* 
+  /*
    * send mdat header if already needed, and mark position for later update.
    * We don't send ftyp now if we are on fast start mode, because we can
    * better fine tune using the information we gather to create the whole moov
    * atom.
    */
-  if (qtmux->fast_start) {
-    GST_OBJECT_LOCK (qtmux);
-    qtmux->fast_start_file = g_fopen (qtmux->fast_start_file_path, "wb+");
-    if (!qtmux->fast_start_file)
-      goto open_failed;
-    GST_OBJECT_UNLOCK (qtmux);
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_MOOV_AT_END:
+      ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
+      if (ret != GST_FLOW_OK)
+        break;
 
-    /* send a dummy buffer for preroll */
-    ret = gst_qt_mux_send_buffer (qtmux, gst_buffer_new (), NULL, FALSE);
-    if (ret != GST_FLOW_OK)
-      goto exit;
+      /* Store this as the mdat offset for later updating
+       * when we write the moov */
+      qtmux->mdat_pos = qtmux->header_size;
+      /* extended atom in case we go over 4GB while writing and need
+       * the full 64-bit atom */
+      ret =
+          gst_qt_mux_send_mdat_header (qtmux, &qtmux->header_size, 0, TRUE,
+          FALSE);
+      break;
+    case GST_QT_MUX_MODE_ROBUST_RECORDING:
 
-  } else {
-    ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
-    if (ret != GST_FLOW_OK) {
-      goto exit;
-    }
+      ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
+      if (ret != GST_FLOW_OK)
+        break;
+
+      /* Pad ftyp out to an 8-byte boundary before starting the moov
+       * ping pong region. It should be well less than 1 disk sector,
+       * unless there's a bajillion compatible types listed,
+       * but let's be sure the free atom doesn't cross a sector
+       * boundary anyway */
+      if (qtmux->header_size % 8) {
+        /* Extra 8 bytes for the padding free atom header */
+        guint padding = (guint) (16 - (qtmux->header_size % 8));
+        GST_LOG_OBJECT (qtmux, "Rounding ftyp by %u bytes", padding);
+        ret =
+            gst_qt_mux_send_free_atom (qtmux, &qtmux->header_size, padding,
+            FALSE);
+        if (ret != GST_FLOW_OK)
+          return ret;
+      }
+
+      /* Store this as the moov offset for later updating.
+       * We record mdat position below */
+      qtmux->moov_pos = qtmux->header_size;
+
+      /* Set up the initial 'ping' state of the ping-pong buffers */
+      qtmux->reserved_moov_first_active = TRUE;
+
+      gst_qt_mux_configure_moov (qtmux);
+      gst_qt_mux_setup_metadata (qtmux);
+      /* Empty free atom to begin, starting on an 8-byte boundary */
+      ret = gst_qt_mux_send_free_atom (qtmux, &qtmux->header_size, 8, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+      /* Moov header, not padded yet */
+      ret = gst_qt_mux_send_moov (qtmux, &qtmux->header_size, 0, FALSE, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+      /* The moov we just sent contains the 'base' size of the moov, before
+       * we put in any time-dependent per-trak data. Use that to make
+       * a good estimate of how much extra to reserve */
+      /* Calculate how much space to reserve for our MOOV atom.
+       * We actually reserve twice that, for ping-pong buffers */
+      qtmux->base_moov_size = qtmux->last_moov_size;
+      GST_LOG_OBJECT (qtmux, "Base moov size is %u before any indexes",
+          qtmux->base_moov_size);
+      qtmux->reserved_moov_size = qtmux->base_moov_size +
+          gst_util_uint64_scale (reserved_max_duration,
+          reserved_bytes_per_sec_per_trak *
+          atom_moov_get_trak_count (qtmux->moov), GST_SECOND);
+
+      /* Need space for at least 4 atom headers. More really, but
+       * this as an absolute minimum */
+      if (qtmux->reserved_moov_size < 4 * 8)
+        goto reserved_moov_too_small;
+
+      GST_DEBUG_OBJECT (qtmux, "reserving header area of size %u",
+          2 * qtmux->reserved_moov_size + 16);
+
+      GST_OBJECT_LOCK (qtmux);
+      qtmux->reserved_duration_remaining =
+          gst_util_uint64_scale (qtmux->reserved_moov_size -
+          qtmux->base_moov_size, GST_SECOND,
+          reserved_bytes_per_sec_per_trak *
+          atom_moov_get_trak_count (qtmux->moov));
+      GST_OBJECT_UNLOCK (qtmux);
+
+      /* Now that we know how much reserved space is targetted,
+       * output a free atom to fill the extra reserved */
+      ret = gst_qt_mux_send_free_atom (qtmux, &qtmux->header_size,
+          qtmux->reserved_moov_size - qtmux->base_moov_size, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+
+      /* Then a free atom containing 'pong' buffer, with an
+       * extra 8 bytes to account for the free atom header itself */
+      ret = gst_qt_mux_send_free_atom (qtmux, &qtmux->header_size,
+          qtmux->reserved_moov_size + 8, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
 
-    /* well, it's moov pos if fragmented ... */
-    qtmux->mdat_pos = qtmux->header_size;
+      /* extra atoms go after the free/moov(s), before the mdat */
+      ret =
+          gst_qt_mux_send_extra_atoms (qtmux, TRUE, &qtmux->header_size, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+
+      qtmux->mdat_pos = qtmux->header_size;
+      /* extended atom in case we go over 4GB while writing and need
+       * the full 64-bit atom */
+      ret =
+          gst_qt_mux_send_mdat_header (qtmux, &qtmux->header_size, 0, TRUE,
+          FALSE);
+      break;
+    case GST_QT_MUX_MODE_FAST_START:
+      GST_OBJECT_LOCK (qtmux);
+      qtmux->fast_start_file = g_fopen (qtmux->fast_start_file_path, "wb+");
+      if (!qtmux->fast_start_file)
+        goto open_failed;
+      GST_OBJECT_UNLOCK (qtmux);
+      /* send a dummy buffer for preroll */
+      ret = gst_qt_mux_send_buffer (qtmux, gst_buffer_new (), NULL, FALSE);
+      break;
+    case GST_QT_MUX_MODE_FRAGMENTED:
+    case GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE:
+      ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
+      if (ret != GST_FLOW_OK)
+        break;
+      /* store the moov pos so we can update the duration later
+       * in non-streamable mode */
+      qtmux->moov_pos = qtmux->header_size;
 
-    if (qtmux->fragment_duration) {
       GST_DEBUG_OBJECT (qtmux, "fragment duration %d ms, writing headers",
           qtmux->fragment_duration);
       /* also used as snapshot marker to indicate fragmented file */
       qtmux->fragment_sequence = 1;
       /* prepare moov and/or tags */
-      gst_qt_mux_configure_moov (qtmux, NULL);
+      gst_qt_mux_configure_moov (qtmux);
       gst_qt_mux_setup_metadata (qtmux);
-      ret = gst_qt_mux_send_moov (qtmux, &qtmux->header_size, FALSE);
+      ret = gst_qt_mux_send_moov (qtmux, &qtmux->header_size, 0, FALSE, FALSE);
       if (ret != GST_FLOW_OK)
         return ret;
       /* extra atoms */
       ret =
           gst_qt_mux_send_extra_atoms (qtmux, TRUE, &qtmux->header_size, FALSE);
       if (ret != GST_FLOW_OK)
-        return ret;
-      /* prepare index */
-      if (!qtmux->streamable)
+        break;
+      /* prepare index if not streamable */
+      if (qtmux->mux_mode == GST_QT_MUX_MODE_FRAGMENTED)
         qtmux->mfra = atom_mfra_new (qtmux->context);
-    } else {
-      /* extended to ensure some spare space */
-      ret = gst_qt_mux_send_mdat_header (qtmux, &qtmux->header_size, 0, TRUE);
-    }
+      break;
   }
 
-exit:
   return ret;
-
   /* ERRORS */
-open_failed:
+invalid_isml:
   {
-    GST_ELEMENT_ERROR (qtmux, RESOURCE, OPEN_READ_WRITE,
-        (("Could not open temporary file \"%s\""), qtmux->fast_start_file_path),
-        GST_ERROR_SYSTEM);
-    GST_OBJECT_UNLOCK (qtmux);
+    GST_ELEMENT_ERROR (qtmux, STREAM, MUX,
+        ("Cannot create an ISML file with 0 fragment duration"), (NULL));
     return GST_FLOW_ERROR;
   }
-}
-
-static GstFlowReturn
-gst_qt_mux_stop_file (GstQTMux * qtmux)
-{
-  gboolean ret = GST_FLOW_OK;
-  guint64 offset = 0, size = 0;
-  GSList *walk;
-  gboolean large_file;
-  guint32 timescale;
-  GstClockTime first_ts = GST_CLOCK_TIME_NONE;
-
-  /* for setting some subtitles fields */
-  guint max_width = 0;
-  guint max_height = 0;
+reserved_moov_too_small:
+  {
+    GST_ELEMENT_ERROR (qtmux, STREAM, MUX,
+        ("Not enough reserved space for creating headers"), (NULL));
+    return GST_FLOW_ERROR;
+  }
+open_failed:
+  {
+    GST_ELEMENT_ERROR (qtmux, RESOURCE, OPEN_READ_WRITE,
+        (("Could not open temporary file \"%s\""),
+            qtmux->fast_start_file_path), GST_ERROR_SYSTEM);
+    GST_OBJECT_UNLOCK (qtmux);
+    return GST_FLOW_ERROR;
+  }
+}
 
-  GST_DEBUG_OBJECT (qtmux, "Updating remaining values and sending last data");
+static GstFlowReturn
+gst_qt_mux_send_last_buffers (GstQTMux * qtmux)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  GSList *walk;
 
-  /* pushing last buffers for each pad */
   for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
     GstCollectData *cdata = (GstCollectData *) walk->data;
     GstQTPad *qtpad = (GstQTPad *) cdata;
@@ -1876,19 +2363,43 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
           "flow return: %s", GST_PAD_NAME (qtpad->collect.pad),
           gst_flow_get_name (ret));
     }
+  }
 
-    /* having flushed above, can check for buffers now */
-    if (!GST_CLOCK_TIME_IS_VALID (qtpad->first_ts)) {
-      GST_DEBUG_OBJECT (qtmux, "Pad %s has no buffers",
+  return ret;
+}
+
+static void
+gst_qt_mux_update_global_statistics (GstQTMux * qtmux)
+{
+  GSList *walk;
+
+  /* for setting some subtitles fields */
+  guint max_width = 0;
+  guint max_height = 0;
+
+  qtmux->first_ts = qtmux->last_dts = GST_CLOCK_TIME_NONE;
+
+  for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
+    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstQTPad *qtpad = (GstQTPad *) cdata;
+
+    if (!qtpad->fourcc) {
+      GST_DEBUG_OBJECT (qtmux, "Pad %s has never had buffers",
           GST_PAD_NAME (qtpad->collect.pad));
       continue;
     }
 
-    /* determine max stream duration */
-    if (!GST_CLOCK_TIME_IS_VALID (first_ts) ||
-        (GST_CLOCK_TIME_IS_VALID (qtpad->first_ts) &&
-            qtpad->last_dts > first_ts)) {
-      first_ts = qtpad->last_dts;
+    /* having flushed above, can check for buffers now */
+    if (GST_CLOCK_TIME_IS_VALID (qtpad->first_ts)) {
+      /* determine max stream duration */
+      if (!GST_CLOCK_TIME_IS_VALID (qtmux->last_dts)
+          || qtpad->last_dts > qtmux->last_dts) {
+        qtmux->last_dts = qtpad->last_dts;
+      }
+      if (!GST_CLOCK_TIME_IS_VALID (qtmux->first_ts)
+          || qtpad->first_ts < qtmux->first_ts) {
+        qtmux->first_ts = qtpad->first_ts;
+      }
     }
 
     /* subtitles need to know the video width/height,
@@ -1928,11 +2439,97 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
       atom_trak_tx3g_update_dimension (qtpad->trak, max_width, max_height);
     }
   }
+}
 
-  if (qtmux->fragment_sequence) {
-    GstSegment segment;
+/* Called after gst_qt_mux_update_global_statistics() updates the
+ * first_ts tracking, to create/set edit lists for delayed streams */
+static void
+gst_qt_mux_update_edit_lists (GstQTMux * qtmux)
+{
+  GSList *walk;
+
+  GST_DEBUG_OBJECT (qtmux, "Media first ts selected: %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (qtmux->first_ts));
+  /* add/update EDTSs for late streams. configure_moov will have
+   * set the trak durations above by summing the sample tables,
+   * here we extend that if needing to insert an empty segment */
+  for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
+    GstCollectData *cdata = (GstCollectData *) walk->data;
+    GstQTPad *qtpad = (GstQTPad *) cdata;
+
+    if (GST_CLOCK_TIME_IS_VALID (qtpad->first_ts)) {
+      guint32 lateness = 0;
+      guint32 duration = qtpad->trak->tkhd.duration;
+      gboolean has_gap;
+      gboolean has_shift;
+
+      has_gap = (qtpad->first_ts > (qtmux->first_ts + qtpad->dts_adjustment));
+      has_shift = (qtpad->dts_adjustment > 0);
+
+      if (has_gap) {
+        GstClockTime diff;
+
+        diff = qtpad->first_ts - (qtmux->first_ts + qtpad->dts_adjustment);
+        lateness = gst_util_uint64_scale_round (diff,
+            qtmux->timescale, GST_SECOND);
+
+        GST_DEBUG_OBJECT (qtmux, "Pad %s is a late stream by %" GST_TIME_FORMAT,
+            GST_PAD_NAME (qtpad->collect.pad), GST_TIME_ARGS (lateness));
+
+        atom_trak_set_elst_entry (qtpad->trak, 0, lateness, (guint32) - 1,
+            (guint32) (1 * 65536.0));
+      }
+
+      if (has_gap || has_shift) {
+        GstClockTime ctts;
+        guint32 media_start;
+
+        ctts = qtpad->first_ts - qtpad->first_dts;
+        media_start = gst_util_uint64_scale_round (ctts,
+            atom_trak_get_timescale (qtpad->trak), GST_SECOND);
+
+        atom_trak_set_elst_entry (qtpad->trak, 1, duration, media_start,
+            (guint32) (1 * 65536.0));
+      }
+
+      /* need to add the empty time to the trak duration */
+      duration += lateness;
+
+      qtpad->trak->tkhd.duration = duration;
+
+      /* And possibly grow the moov duration */
+      if (duration > qtmux->moov->mvhd.time_info.duration) {
+        qtmux->moov->mvhd.time_info.duration = duration;
+        qtmux->moov->mvex.mehd.fragment_duration = duration;
+      }
+    }
+  }
+}
+
+static GstFlowReturn
+gst_qt_mux_stop_file (GstQTMux * qtmux)
+{
+  gboolean ret = GST_FLOW_OK;
+  guint64 offset = 0, size = 0;
+  gboolean large_file;
+
+  GST_DEBUG_OBJECT (qtmux, "Updating remaining values and sending last data");
+
+  /* pushing last buffers for each pad */
+  if ((ret = gst_qt_mux_send_last_buffers (qtmux)) != GST_FLOW_OK)
+    return ret;
+
+  if (qtmux->mux_mode == GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE) {
+    /* Streamable mode; no need to write duration or MFRA */
+    GST_DEBUG_OBJECT (qtmux, "streamable file; nothing to stop");
+    return GST_FLOW_OK;
+  }
 
-    if (qtmux->mfra) {
+  gst_qt_mux_update_global_statistics (qtmux);
+
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_FRAGMENTED:{
+      GstSegment segment;
       guint8 *data = NULL;
       GstBuffer *buf;
 
@@ -1944,103 +2541,82 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
       ret = gst_qt_mux_send_buffer (qtmux, buf, NULL, FALSE);
       if (ret != GST_FLOW_OK)
         return ret;
-    } else {
-      /* must have been streamable; no need to write duration */
-      GST_DEBUG_OBJECT (qtmux, "streamable file; nothing to stop");
-      return GST_FLOW_OK;
-    }
-
-    timescale = qtmux->timescale;
-    /* only mvex duration is updated,
-     * mvhd should be consistent with empty moov
-     * (but TODO maybe some clients do not handle that well ?) */
-    qtmux->moov->mvex.mehd.fragment_duration =
-        gst_util_uint64_scale (first_ts, timescale, GST_SECOND);
-    GST_DEBUG_OBJECT (qtmux, "rewriting moov with mvex duration %"
-        GST_TIME_FORMAT, GST_TIME_ARGS (first_ts));
-    /* seek and rewrite the header */
-    gst_segment_init (&segment, GST_FORMAT_BYTES);
-    segment.start = qtmux->mdat_pos;
-    gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
-    /* no need to seek back */
-    return gst_qt_mux_send_moov (qtmux, NULL, FALSE);
-  }
-
-  gst_qt_mux_configure_moov (qtmux, &timescale);
-
-  /* check for late streams */
-  first_ts = GST_CLOCK_TIME_NONE;
-  for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
-    GstQTPad *qtpad = (GstQTPad *) cdata;
 
-    if (!GST_CLOCK_TIME_IS_VALID (first_ts) ||
-        (GST_CLOCK_TIME_IS_VALID (qtpad->first_ts) &&
-            qtpad->first_ts < first_ts)) {
-      first_ts = qtpad->first_ts;
+      /* only mvex duration is updated,
+       * mvhd should be consistent with empty moov
+       * (but TODO maybe some clients do not handle that well ?) */
+      qtmux->moov->mvex.mehd.fragment_duration =
+          gst_util_uint64_scale (qtmux->last_dts, qtmux->timescale, GST_SECOND);
+      GST_DEBUG_OBJECT (qtmux, "rewriting moov with mvex duration %"
+          GST_TIME_FORMAT, GST_TIME_ARGS (qtmux->last_dts));
+      /* seek and rewrite the header */
+      gst_segment_init (&segment, GST_FORMAT_BYTES);
+      segment.start = qtmux->moov_pos;
+      gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
+      /* no need to seek back */
+      return gst_qt_mux_send_moov (qtmux, NULL, 0, FALSE, FALSE);
     }
-  }
-  GST_DEBUG_OBJECT (qtmux, "Media first ts selected: %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (first_ts));
-  /* add EDTSs for late streams */
-  for (walk = qtmux->collect->data; walk; walk = g_slist_next (walk)) {
-    GstCollectData *cdata = (GstCollectData *) walk->data;
-    GstQTPad *qtpad = (GstQTPad *) cdata;
-    guint32 lateness;
-    guint32 duration;
-
-    if (GST_CLOCK_TIME_IS_VALID (qtpad->first_ts) && qtpad->first_ts > first_ts) {
-      GST_DEBUG_OBJECT (qtmux, "Pad %s is a late stream by %" GST_TIME_FORMAT,
-          GST_PAD_NAME (qtpad->collect.pad),
-          GST_TIME_ARGS (qtpad->first_ts - first_ts));
-      lateness = gst_util_uint64_scale_round (qtpad->first_ts - first_ts,
-          timescale, GST_SECOND);
-      duration = qtpad->trak->tkhd.duration;
-      atom_trak_add_elst_entry (qtpad->trak, lateness, (guint32) - 1,
-          (guint32) (1 * 65536.0));
-      atom_trak_add_elst_entry (qtpad->trak, duration, 0,
-          (guint32) (1 * 65536.0));
-
-      /* need to add the empty time to the trak duration */
-      qtpad->trak->tkhd.duration += lateness;
+    case GST_QT_MUX_MODE_ROBUST_RECORDING:{
+      ret = gst_qt_mux_robust_recording_rewrite_moov (qtmux);
+      if (G_UNLIKELY (ret != GST_FLOW_OK))
+        return ret;
+      /* Finalise by writing the final size into the mdat. Up until now
+       * it's been 0, which means 'rest of the file'
+       * No need to seek back after this, we won't write any more */
+      return gst_qt_mux_update_mdat_size (qtmux, qtmux->mdat_pos,
+          qtmux->mdat_size, NULL, TRUE);
     }
+    default:
+      break;
   }
 
+  /* Moov-at-end or fast-start mode from here down */
+  gst_qt_mux_configure_moov (qtmux);
+
+  gst_qt_mux_update_edit_lists (qtmux);
+
   /* tags into file metadata */
   gst_qt_mux_setup_metadata (qtmux);
 
   large_file = (qtmux->mdat_size > MDAT_LARGE_FILE_LIMIT);
-  /* if faststart, update the offset of the atoms in the movie with the offset
-   * that the movie headers before mdat will cause.
-   * Also, send the ftyp */
-  if (qtmux->fast_start_file) {
-    GstFlowReturn flow_ret;
-    offset = size = 0;
 
-    flow_ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
-    if (flow_ret != GST_FLOW_OK) {
-      goto ftyp_error;
-    }
-    /* copy into NULL to obtain size */
-    if (!atom_moov_copy_data (qtmux->moov, NULL, &size, &offset))
-      goto serialize_error;
-    GST_DEBUG_OBJECT (qtmux, "calculated moov atom size %" G_GUINT64_FORMAT,
-        offset);
-    offset += qtmux->header_size + (large_file ? 16 : 8);
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_FAST_START:{
+      /* if faststart, update the offset of the atoms in the movie with the offset
+       * that the movie headers before mdat will cause.
+       * Also, send the ftyp */
+      offset = size = 0;
 
-    /* sum up with the extra atoms size */
-    ret = gst_qt_mux_send_extra_atoms (qtmux, FALSE, &offset, FALSE);
-    if (ret != GST_FLOW_OK)
-      return ret;
-  } else {
-    offset = qtmux->header_size;
+      ret = gst_qt_mux_prepare_and_send_ftyp (qtmux);
+      if (ret != GST_FLOW_OK) {
+        goto ftyp_error;
+      }
+      /* copy into NULL to obtain size */
+      if (!atom_moov_copy_data (qtmux->moov, NULL, &size, &offset))
+        goto serialize_error;
+      GST_DEBUG_OBJECT (qtmux, "calculated moov atom size %" G_GUINT64_FORMAT,
+          offset);
+      offset += qtmux->header_size + (large_file ? 16 : 8);
+
+      /* sum up with the extra atoms size */
+      ret = gst_qt_mux_send_extra_atoms (qtmux, FALSE, &offset, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+      break;
+    }
+    default:
+      offset = qtmux->header_size;
+      break;
   }
-  atom_moov_chunks_add_offset (qtmux->moov, offset);
 
-  /* moov */
+  /* Now that we know the size of moov + extra atoms, we can adjust
+   * the chunk offsets stored into the moov */
+  atom_moov_chunks_set_offset (qtmux->moov, offset);
+
+  /* write out moov and extra atoms */
   /* note: as of this point, we no longer care about tracking written data size,
    * since there is no more use for it anyway */
-  ret = gst_qt_mux_send_moov (qtmux, NULL, FALSE);
+  ret = gst_qt_mux_send_moov (qtmux, NULL, 0, FALSE, FALSE);
   if (ret != GST_FLOW_OK)
     return ret;
 
@@ -2049,23 +2625,32 @@ gst_qt_mux_stop_file (GstQTMux * qtmux)
   if (ret != GST_FLOW_OK)
     return ret;
 
-  /* if needed, send mdat atom and move buffered data into it */
-  if (qtmux->fast_start_file) {
-    /* mdat_size = accumulated (buffered data) */
-    ret = gst_qt_mux_send_mdat_header (qtmux, NULL, qtmux->mdat_size,
-        large_file);
-    if (ret != GST_FLOW_OK)
-      return ret;
-    ret = gst_qt_mux_send_buffered_data (qtmux, NULL);
-    if (ret != GST_FLOW_OK)
-      return ret;
-  } else if (!qtmux->streamable) {
-    /* mdat needs update iff not using faststart */
-    GST_DEBUG_OBJECT (qtmux, "updating mdat size");
-    ret = gst_qt_mux_update_mdat_size (qtmux, qtmux->mdat_pos,
-        qtmux->mdat_size, NULL);
-    /* note; no seeking back to the end of file is done,
-     * since we no longer write anything anyway */
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_MOOV_AT_END:
+    {
+      /* mdat needs update iff not using faststart */
+      GST_DEBUG_OBJECT (qtmux, "updating mdat size");
+      ret = gst_qt_mux_update_mdat_size (qtmux, qtmux->mdat_pos,
+          qtmux->mdat_size, NULL, FALSE);
+      /* note; no seeking back to the end of file is done,
+       * since we no longer write anything anyway */
+      break;
+    }
+    case GST_QT_MUX_MODE_FAST_START:
+    {
+      /* send mdat atom and move buffered data into it */
+      /* mdat_size = accumulated (buffered data) */
+      ret = gst_qt_mux_send_mdat_header (qtmux, NULL, qtmux->mdat_size,
+          large_file, FALSE);
+      if (ret != GST_FLOW_OK)
+        return ret;
+      ret = gst_qt_mux_send_buffered_data (qtmux, NULL);
+      if (ret != GST_FLOW_OK)
+        return ret;
+      break;
+    }
+    default:
+      g_assert_not_reached ();
   }
 
   return ret;
@@ -2131,7 +2716,7 @@ flush:
         atom_array_get_len (&pad->fragment_buffers), total_size);
     if (ret == GST_FLOW_OK)
       ret = gst_qt_mux_send_mdat_header (qtmux, &qtmux->header_size, total_size,
-          FALSE);
+          FALSE, FALSE);
     for (i = 0; i < atom_array_get_len (&pad->fragment_buffers); i++) {
       if (G_LIKELY (ret == GST_FLOW_OK))
         ret = gst_qt_mux_send_buffer (qtmux,
@@ -2180,26 +2765,179 @@ init:
   return ret;
 }
 
-static void
-check_and_subtract_ts (GstQTMux * qtmux, GstClockTime * ts_a, GstClockTime ts_b)
+/* Here's the clever bit of robust recording: Updating the moov
+ * header is done using a ping-pong scheme inside 2 blocks of size
+ * 'reserved_moov_size' at the start of the file, in such a way that the
+ * file on-disk is always valid if interrupted.
+ * Inside the reserved space, we have 2 pairs of free + moov atoms
+ * (in that order), free-A + moov-A @ offset 0 and free-B + moov-B at
+ * at offset "reserved_moov_size".
+ *
+ * 1. Free-A has 0 size payload, moov-A immediately after is
+ *    active/current, and is padded with an internal Free atom to
+ *    end at reserved_space/2. Free-B is at reserved_space/2, sized
+ *    to cover the remaining free space (including moov-B).
+ * 2. We write moov-B (which is invisible inside free-B), and pad it to
+ *    end at the end of free space. Then, we update free-A to size
+ *    reserved_space/2 + sizeof(free-B), which hides moov-A and the
+ *    free-B header, and makes moov-B active.
+ * 3. Rewrite moov-A inside free-A, with padding out to free-B.
+ *    Change the size of free-A to make moov-A active again.
+ * 4. Rinse and repeat.
+ *
+ */
+static GstFlowReturn
+gst_qt_mux_robust_recording_rewrite_moov (GstQTMux * qtmux)
 {
-  if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (*ts_a))) {
-    if (G_LIKELY (*ts_a >= ts_b)) {
-      *ts_a -= ts_b;
-    } else {
-      *ts_a = 0;
-      GST_WARNING_OBJECT (qtmux, "Subtraction would result in negative value, "
-          "using 0 as result");
-    }
+  GstSegment segment;
+  GstFlowReturn ret;
+  guint64 freeA_offset;
+  guint32 new_freeA_size;
+  guint64 new_moov_offset;
+
+  /* Update moov info, then seek and rewrite the MOOV atom */
+  gst_qt_mux_update_global_statistics (qtmux);
+  gst_qt_mux_configure_moov (qtmux);
+
+  gst_qt_mux_update_edit_lists (qtmux);
+
+  /* tags into file metadata */
+  gst_qt_mux_setup_metadata (qtmux);
+
+  /* chunks position is set relative to the first byte of the
+   * MDAT atom payload. Set the overall offset into the file */
+  atom_moov_chunks_set_offset (qtmux->moov, qtmux->header_size);
+
+  /* Calculate which moov to rewrite. qtmux->moov_pos points to
+   * the start of the free-A header */
+  freeA_offset = qtmux->moov_pos;
+  if (qtmux->reserved_moov_first_active) {
+    GST_DEBUG_OBJECT (qtmux, "Updating pong moov header");
+    /* After this, freeA will include itself, moovA, plus the freeB
+     * header */
+    new_freeA_size = qtmux->reserved_moov_size + 16;
+  } else {
+    GST_DEBUG_OBJECT (qtmux, "Updating ping moov header");
+    new_freeA_size = 8;
+  }
+  /* the moov we update is after free-A, calculate its offset */
+  new_moov_offset = freeA_offset + new_freeA_size;
+
+  /* Swap ping-pong cadence marker */
+  qtmux->reserved_moov_first_active = !qtmux->reserved_moov_first_active;
+
+  /* seek and rewrite the MOOV atom */
+  gst_segment_init (&segment, GST_FORMAT_BYTES);
+  segment.start = new_moov_offset;
+  gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
+
+  ret =
+      gst_qt_mux_send_moov (qtmux, NULL, qtmux->reserved_moov_size, FALSE,
+      TRUE);
+  if (ret != GST_FLOW_OK)
+    return ret;
+
+  /* Update the estimated recording space remaining, based on amount used so
+   * far and duration muxed so far */
+  if (qtmux->last_moov_size > qtmux->base_moov_size && qtmux->last_dts > 0) {
+    GstClockTime remain;
+    GstClockTime time_muxed = qtmux->last_dts;
+
+    remain =
+        gst_util_uint64_scale (qtmux->reserved_moov_size -
+        qtmux->last_moov_size, time_muxed,
+        qtmux->last_moov_size - qtmux->base_moov_size);
+    /* Always under-estimate slightly, so users
+     * have time to stop muxing before we run out */
+    if (remain < GST_SECOND / 2)
+      remain = 0;
+    else
+      remain -= GST_SECOND / 2;
+
+    GST_INFO_OBJECT (qtmux,
+        "Reserved %u header bytes. Used %u in %" GST_TIME_FORMAT
+        ". Remaining now %u or approx %" G_GUINT64_FORMAT " ns\n",
+        qtmux->reserved_moov_size, qtmux->last_moov_size,
+        GST_TIME_ARGS (qtmux->last_dts),
+        qtmux->reserved_moov_size - qtmux->last_moov_size, remain);
+
+    GST_OBJECT_LOCK (qtmux);
+    qtmux->reserved_duration_remaining = remain;
+    qtmux->muxed_since_last_update = 0;
+    GST_DEBUG_OBJECT (qtmux, "reserved remaining duration now %"
+        G_GUINT64_FORMAT, qtmux->reserved_duration_remaining);
+    GST_OBJECT_UNLOCK (qtmux);
   }
+
+
+  /* Now update the moov-A size. Don't pass offset, since we don't need
+   * send_free_atom() to seek for us - all our callers seek back to
+   * where they need after this, or they don't need it */
+  gst_segment_init (&segment, GST_FORMAT_BYTES);
+  segment.start = freeA_offset;
+  gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
+
+  ret = gst_qt_mux_send_free_atom (qtmux, NULL, new_freeA_size, TRUE);
+
+  return ret;
 }
 
+static GstFlowReturn
+gst_qt_mux_robust_recording_update (GstQTMux * qtmux, GstClockTime position)
+{
+  GstSegment segment;
+  GstFlowReturn flow_ret;
+
+  guint64 mdat_offset = qtmux->mdat_pos + 16 + qtmux->mdat_size;
+
+  GST_OBJECT_LOCK (qtmux);
+  if (qtmux->reserved_moov_update_period == GST_CLOCK_TIME_NONE) {
+    GST_OBJECT_UNLOCK (qtmux);
+    return GST_FLOW_OK;
+  }
+
+  /* Update if position is > the threshold or there's been no update yet */
+  if (qtmux->last_moov_update != GST_CLOCK_TIME_NONE &&
+      (position <= qtmux->last_moov_update ||
+          (position - qtmux->last_moov_update) <
+          qtmux->reserved_moov_update_period)) {
+    /* Update the offset of how much we've muxed, so the
+     * report of remaining space keeps counting down */
+    if (position > qtmux->last_moov_update &&
+        position - qtmux->last_moov_update > qtmux->muxed_since_last_update) {
+      GST_LOG_OBJECT (qtmux,
+          "Muxed time %" G_GUINT64_FORMAT " since last moov update",
+          qtmux->muxed_since_last_update);
+      qtmux->muxed_since_last_update = position - qtmux->last_moov_update;
+    }
+    GST_OBJECT_UNLOCK (qtmux);
+    return GST_FLOW_OK;         /* No update needed yet */
+  }
+
+  qtmux->last_moov_update = position;
+  GST_OBJECT_UNLOCK (qtmux);
+
+  GST_DEBUG_OBJECT (qtmux, "Update moov atom, position %" GST_TIME_FORMAT
+      " mdat starts @ %" G_GUINT64_FORMAT " we were a %" G_GUINT64_FORMAT,
+      GST_TIME_ARGS (position), qtmux->mdat_pos, mdat_offset);
+
+  flow_ret = gst_qt_mux_robust_recording_rewrite_moov (qtmux);
+  if (G_UNLIKELY (flow_ret != GST_FLOW_OK))
+    return flow_ret;
+
+  /* Seek back to previous position */
+  gst_segment_init (&segment, GST_FORMAT_BYTES);
+  segment.start = mdat_offset;
+  gst_pad_push_event (qtmux->srcpad, gst_event_new_segment (&segment));
+
+  return flow_ret;
+}
 
 static GstFlowReturn
 gst_qt_mux_register_and_push_sample (GstQTMux * qtmux, GstQTPad * pad,
     GstBuffer * buffer, gboolean is_last_buffer, guint nsamples,
     gint64 last_dts, gint64 scaled_duration, guint sample_size,
-    guint chunk_offset, gboolean sync, gboolean do_pts, gint64 pts_offset)
+    guint64 chunk_offset, gboolean sync, gboolean do_pts, gint64 pts_offset)
 {
   GstFlowReturn ret = GST_FLOW_OK;
 
@@ -2215,15 +2953,25 @@ gst_qt_mux_register_and_push_sample (GstQTMux * qtmux, GstQTPad * pad,
     }
   }
 
-  if (qtmux->fragment_sequence) {
-    /* ensure that always sync samples are marked as such */
-    ret = gst_qt_mux_pad_fragment_add_buffer (qtmux, pad, buffer,
-        is_last_buffer, nsamples, last_dts, (gint32) scaled_duration,
-        sample_size, !pad->sync || sync, pts_offset);
-  } else {
-    atom_trak_add_samples (pad->trak, nsamples, (gint32) scaled_duration,
-        sample_size, chunk_offset, sync, pts_offset);
-    ret = gst_qt_mux_send_buffer (qtmux, buffer, &qtmux->mdat_size, TRUE);
+  switch (qtmux->mux_mode) {
+    case GST_QT_MUX_MODE_MOOV_AT_END:
+    case GST_QT_MUX_MODE_FAST_START:
+    case GST_QT_MUX_MODE_ROBUST_RECORDING:
+      atom_trak_add_samples (pad->trak, nsamples, (gint32) scaled_duration,
+          sample_size, chunk_offset, sync, pts_offset);
+      ret = gst_qt_mux_send_buffer (qtmux, buffer, &qtmux->mdat_size, TRUE);
+      /* Check if it's time to re-write the headers in robust-recording mode */
+      if (ret == GST_FLOW_OK
+          && qtmux->mux_mode == GST_QT_MUX_MODE_ROBUST_RECORDING)
+        ret = gst_qt_mux_robust_recording_update (qtmux, pad->total_duration);
+      break;
+    case GST_QT_MUX_MODE_FRAGMENTED:
+    case GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE:
+      /* ensure that always sync samples are marked as such */
+      ret = gst_qt_mux_pad_fragment_add_buffer (qtmux, pad, buffer,
+          is_last_buffer, nsamples, last_dts, (gint32) scaled_duration,
+          sample_size, !pad->sync || sync, pts_offset);
+      break;
   }
 
   return ret;
@@ -2241,7 +2989,7 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
   guint64 chunk_offset;
   gint64 last_dts, scaled_duration;
   gint64 pts_offset = 0;
-  gboolean sync = FALSE, do_pts = FALSE;
+  gboolean sync = FALSE;
   GstFlowReturn ret = GST_FLOW_OK;
 
   if (!pad->fourcc)
@@ -2252,37 +3000,27 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
     buf = pad->prepare_buf_func (pad, buf, qtmux);
   }
 
-  if (G_LIKELY (buf != NULL && GST_CLOCK_TIME_IS_VALID (pad->first_ts) &&
-          pad->first_ts != 0)) {
-    buf = gst_buffer_make_writable (buf);
-    check_and_subtract_ts (qtmux, &GST_BUFFER_DTS (buf), pad->first_ts);
-    check_and_subtract_ts (qtmux, &GST_BUFFER_PTS (buf), pad->first_ts);
-  }
-
   last_buf = pad->last_buf;
 
-  /* if buffer has missing DTS, we take either segment start or previous buffer end time, 
-     which ever is later */
-  if (buf && !GST_BUFFER_DTS_IS_VALID (buf)) {
+  /* DTS delta is used to calculate sample duration.
+   * If buffer has missing DTS, we take either segment start or
+   *  previous buffer end time, whichever is later.
+   * This must only be done for non sparse streams, sparse streams
+   * can have gaps between buffers (which is handled later by adding
+   * extra empty buffer with duration that fills the gap). */
+  if (!pad->sparse && buf && !GST_BUFFER_DTS_IS_VALID (buf)) {
     GstClockTime last_buf_duration = last_buf
         && GST_BUFFER_DURATION_IS_VALID (last_buf) ?
         GST_BUFFER_DURATION (last_buf) : 0;
 
     buf = gst_buffer_make_writable (buf);
-    GST_BUFFER_DTS (buf) =
-        gst_segment_to_running_time (&pad->collect.segment, GST_FORMAT_TIME,
-        pad->collect.segment.start);
-    if (GST_CLOCK_TIME_IS_VALID (pad->first_ts))
-      check_and_subtract_ts (qtmux, &GST_BUFFER_DTS (buf), pad->first_ts);
+    GST_BUFFER_DTS (buf) = 0;   /* running-time 0 */
 
     if (last_buf
         && (GST_BUFFER_DTS (last_buf) + last_buf_duration) >
         GST_BUFFER_DTS (buf)) {
       GST_BUFFER_DTS (buf) = GST_BUFFER_DTS (last_buf) + last_buf_duration;
     }
-
-    if (GST_BUFFER_PTS_IS_VALID (buf))
-      GST_BUFFER_DTS (buf) = MIN (GST_BUFFER_DTS (buf), GST_BUFFER_PTS (buf));
   }
 
   if (last_buf && !buf && !GST_BUFFER_DURATION_IS_VALID (last_buf)) {
@@ -2310,32 +3048,28 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
 
   /* if this is the first buffer, store the timestamp */
   if (G_UNLIKELY (pad->first_ts == GST_CLOCK_TIME_NONE) && last_buf) {
-    if (GST_BUFFER_DTS_IS_VALID (last_buf)) {
-      /* first pad always has DTS. If it was not provided by upstream it was set to segment start */
+    if (GST_BUFFER_PTS_IS_VALID (last_buf)) {
+      pad->first_ts = GST_BUFFER_PTS (last_buf);
+    } else if (GST_BUFFER_DTS_IS_VALID (last_buf)) {
       pad->first_ts = GST_BUFFER_DTS (last_buf);
+    }
+
+    if (GST_BUFFER_DTS_IS_VALID (last_buf)) {
+      pad->first_dts = pad->last_dts = GST_BUFFER_DTS (last_buf);
     } else if (GST_BUFFER_PTS_IS_VALID (last_buf)) {
-      pad->first_ts = GST_BUFFER_PTS (last_buf);
+      pad->first_dts = pad->last_dts = GST_BUFFER_PTS (last_buf);
     }
 
     if (GST_CLOCK_TIME_IS_VALID (pad->first_ts)) {
       GST_DEBUG ("setting first_ts to %" G_GUINT64_FORMAT, pad->first_ts);
-      last_buf = gst_buffer_make_writable (last_buf);
-      check_and_subtract_ts (qtmux, &GST_BUFFER_DTS (last_buf), pad->first_ts);
-      check_and_subtract_ts (qtmux, &GST_BUFFER_PTS (last_buf), pad->first_ts);
-      if (buf) {
-        buf = gst_buffer_make_writable (buf);
-        check_and_subtract_ts (qtmux, &GST_BUFFER_DTS (buf), pad->first_ts);
-        check_and_subtract_ts (qtmux, &GST_BUFFER_PTS (buf), pad->first_ts);
-      }
     } else {
-      GST_ERROR_OBJECT (qtmux, "First buffer for pad %s has no timestamp, "
+      GST_WARNING_OBJECT (qtmux, "First buffer for pad %s has no timestamp, "
           "using 0 as first timestamp", GST_PAD_NAME (pad->collect.pad));
-      pad->first_ts = 0;
+      pad->first_ts = pad->first_dts = 0;
     }
     GST_DEBUG_OBJECT (qtmux, "Stored first timestamp for pad %s %"
         GST_TIME_FORMAT, GST_PAD_NAME (pad->collect.pad),
         GST_TIME_ARGS (pad->first_ts));
-
   }
 
   if (last_buf && buf && GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (buf)) &&
@@ -2446,7 +3180,6 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
   }
 
   if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (last_buf))) {
-    do_pts = TRUE;
     last_dts = gst_util_uint64_scale_round (GST_BUFFER_DTS (last_buf),
         atom_trak_get_timescale (pad->trak), GST_SECOND);
     pts_offset =
@@ -2455,7 +3188,6 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
 
   } else {
     pts_offset = 0;
-    do_pts = TRUE;
     last_dts = gst_util_uint64_scale_round (GST_BUFFER_PTS (last_buf),
         atom_trak_get_timescale (pad->trak), GST_SECOND);
   }
@@ -2479,7 +3211,7 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
   /* now we go and register this buffer/sample all over */
   ret = gst_qt_mux_register_and_push_sample (qtmux, pad, last_buf,
       buf == NULL, nsamples, last_dts, scaled_duration, sample_size,
-      chunk_offset, sync, do_pts, pts_offset);
+      chunk_offset, sync, TRUE, pts_offset);
 
   /* if this is sparse and we have a next buffer, check if there is any gap
    * between them to insert an empty sample */
@@ -2502,7 +3234,7 @@ gst_qt_mux_add_buffer (GstQTMux * qtmux, GstQTPad * pad, GstBuffer * buf)
       ret =
           gst_qt_mux_register_and_push_sample (qtmux, pad, empty_buf, FALSE, 1,
           last_dts + scaled_duration, empty_duration_scaled,
-          gst_buffer_get_size (empty_buf), qtmux->mdat_size, sync, do_pts, 0);
+          gst_buffer_get_size (empty_buf), qtmux->mdat_size, sync, TRUE, 0);
     } else {
       /* our only case currently is tx3g subtitles, so there is no reason to fill this yet */
       g_assert_not_reached ();
@@ -2544,6 +3276,57 @@ not_negotiated:
   }
 }
 
+/*
+ * DTS running time can be negative. There is no way to represent that in
+ * MP4 however, thus we need to offset DTS so that it starts from 0.
+ */
+static void
+gst_qt_pad_adjust_buffer_dts (GstQTMux * qtmux, GstQTPad * pad,
+    GstCollectData * cdata, GstBuffer ** buf)
+{
+  GstClockTime pts;
+  gint64 dts;
+
+  pts = GST_BUFFER_PTS (*buf);
+  dts = GST_COLLECT_PADS_DTS (cdata);
+
+  GST_LOG_OBJECT (qtmux, "selected pad %s with PTS %" GST_TIME_FORMAT
+      " and DTS %" GST_STIME_FORMAT, GST_PAD_NAME (cdata->pad),
+      GST_TIME_ARGS (pts), GST_STIME_ARGS (dts));
+
+  if (!GST_CLOCK_TIME_IS_VALID (pad->dts_adjustment)) {
+    if (GST_CLOCK_STIME_IS_VALID (dts) && dts < 0)
+      pad->dts_adjustment = -dts;
+    else
+      pad->dts_adjustment = 0;
+  }
+
+  if (pad->dts_adjustment > 0) {
+    *buf = gst_buffer_make_writable (*buf);
+
+    dts += pad->dts_adjustment;
+
+    if (GST_CLOCK_TIME_IS_VALID (pts))
+      pts += pad->dts_adjustment;
+
+    if (GST_CLOCK_STIME_IS_VALID (dts) && dts < 0) {
+      GST_WARNING_OBJECT (pad, "Decreasing DTS.");
+      dts = 0;
+    }
+
+    if (pts < dts) {
+      GST_WARNING_OBJECT (pad, "DTS is bigger then PTS");
+      pts = dts;
+    }
+
+    GST_BUFFER_PTS (*buf) = pts;
+    GST_BUFFER_DTS (*buf) = dts;
+
+    GST_LOG_OBJECT (qtmux, "time adjusted to PTS %" GST_TIME_FORMAT
+        " and DTS %" GST_TIME_FORMAT, GST_TIME_ARGS (pts), GST_TIME_ARGS (dts));
+  }
+}
+
 static GstFlowReturn
 gst_qt_mux_handle_buffer (GstCollectPads * pads, GstCollectData * cdata,
     GstBuffer * buf, gpointer user_data)
@@ -2551,13 +3334,12 @@ gst_qt_mux_handle_buffer (GstCollectPads * pads, GstCollectData * cdata,
   GstFlowReturn ret = GST_FLOW_OK;
   GstQTMux *qtmux = GST_QT_MUX_CAST (user_data);
   GstQTPad *best_pad = NULL;
-  GstClockTime best_time = GST_CLOCK_TIME_NONE;
 
   if (G_UNLIKELY (qtmux->state == GST_QT_MUX_STATE_STARTED)) {
     if ((ret = gst_qt_mux_start_file (qtmux)) != GST_FLOW_OK)
       return ret;
-    else
-      qtmux->state = GST_QT_MUX_STATE_DATA;
+
+    qtmux->state = GST_QT_MUX_STATE_DATA;
   }
 
   if (G_UNLIKELY (qtmux->state == GST_QT_MUX_STATE_EOS))
@@ -2568,11 +3350,10 @@ gst_qt_mux_handle_buffer (GstCollectPads * pads, GstCollectData * cdata,
   /* clipping already converted to running time */
   if (best_pad != NULL) {
     g_assert (buf);
-    best_time = GST_BUFFER_PTS (buf);
-    GST_LOG_OBJECT (qtmux, "selected pad %s with time %" GST_TIME_FORMAT,
-        GST_PAD_NAME (best_pad->collect.pad), GST_TIME_ARGS (best_time));
+    gst_qt_pad_adjust_buffer_dts (qtmux, best_pad, cdata, &buf);
     ret = gst_qt_mux_add_buffer (qtmux, best_pad, buf);
   } else {
+    qtmux->state = GST_QT_MUX_STATE_EOS;
     ret = gst_qt_mux_stop_file (qtmux);
     if (ret == GST_FLOW_OK) {
       GST_DEBUG_OBJECT (qtmux, "Pushing eos");
@@ -2582,7 +3363,6 @@ gst_qt_mux_handle_buffer (GstCollectPads * pads, GstCollectData * cdata,
       GST_WARNING_OBJECT (qtmux, "Failed to stop file: %s",
           gst_flow_get_name (ret));
     }
-    qtmux->state = GST_QT_MUX_STATE_EOS;
   }
 
   return ret;
@@ -2777,6 +3557,8 @@ gst_qt_mux_audio_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
         entry.fourcc = FOURCC_sowt;
       else if (info.finfo->endianness == G_BIG_ENDIAN)
         entry.fourcc = FOURCC_twos;
+      else
+        entry.fourcc = FOURCC_sowt;
       /* maximum backward compatibility; only new version for > 16 bit */
       if (info.finfo->depth <= 16)
         entry.version = 0;
@@ -2851,7 +3633,8 @@ gst_qt_mux_audio_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
     if (GST_READ_UINT32_LE (map.data + 4) == FOURCC_alac) {
       len -= 8;
       codec_config =
-          gst_buffer_copy_region ((GstBuffer *) codec_data, 0, 8, len);
+          gst_buffer_copy_region ((GstBuffer *) codec_data,
+          GST_BUFFER_COPY_MEMORY, 8, len);
     } else {
       codec_config = gst_buffer_ref ((GstBuffer *) codec_data);
     }
@@ -2870,6 +3653,18 @@ gst_qt_mux_audio_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
     entry.samples_per_packet = GST_READ_UINT32_BE (map.data + 4);
     gst_buffer_unmap (codec_config, &map);
     gst_buffer_unref (codec_config);
+  } else if (strcmp (mimetype, "audio/x-ac3") == 0) {
+    entry.fourcc = FOURCC_ac_3;
+
+    /* Fixed values according to TS 102 366 but it also mentions that
+     * they should be ignored */
+    entry.channels = 2;
+    entry.sample_size = 16;
+
+    /* AC-3 needs an extension atom but its data can only be obtained from
+     * the stream itself. Abuse the prepare_buf_func so we parse a frame
+     * and get the needed data */
+    qtpad->prepare_buf_func = gst_qt_mux_prepare_parse_ac3_frame;
   }
 
   if (!entry.fourcc)
@@ -2878,7 +3673,9 @@ gst_qt_mux_audio_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
   /* ok, set the pad info accordingly */
   qtpad->fourcc = entry.fourcc;
   qtpad->sample_size = constant_size;
-  atom_trak_set_audio_type (qtpad->trak, qtmux->context, &entry,
+  qtpad->trak_ste =
+      (SampleTableEntry *) atom_trak_set_audio_type (qtpad->trak,
+      qtmux->context, &entry,
       qtmux->trak_timescale ? qtmux->trak_timescale : entry.sample_rate,
       ext_atom, constant_size);
 
@@ -3029,6 +3826,13 @@ gst_qt_mux_video_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
         entry.depth = depth;
         sync = FALSE;
         break;
+      case GST_VIDEO_FORMAT_v210:
+        if (depth == -1)
+          depth = 24;
+        entry.fourcc = FOURCC_v210;
+        entry.depth = depth;
+        sync = FALSE;
+        break;
       default:
         if (GST_VIDEO_FORMAT_INFO_FLAGS (vinfo) & GST_VIDEO_FORMAT_FLAG_RGB) {
           entry.fourcc = FOURCC_raw_;
@@ -3224,6 +4028,18 @@ gst_qt_mux_video_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
 
     gst_structure_get_uint (structure, "format", &fourcc);
     entry.fourcc = fourcc;
+  } else if (strcmp (mimetype, "video/x-prores") == 0) {
+    const gchar *variant;
+
+    variant = gst_structure_get_string (structure, "format");
+    if (!variant || !g_strcmp0 (variant, "standard"))
+      entry.fourcc = GST_MAKE_FOURCC ('a', 'p', 'c', 'n');
+    else if (!g_strcmp0 (variant, "lt"))
+      entry.fourcc = GST_MAKE_FOURCC ('a', 'p', 'c', 's');
+    else if (!g_strcmp0 (variant, "hq"))
+      entry.fourcc = GST_MAKE_FOURCC ('a', 'p', 'c', 'h');
+    else if (!g_strcmp0 (variant, "proxy"))
+      entry.fourcc = GST_MAKE_FOURCC ('a', 'p', '4', 'h');
   }
 
   if (!entry.fourcc)
@@ -3232,8 +4048,9 @@ gst_qt_mux_video_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
   /* ok, set the pad info accordingly */
   qtpad->fourcc = entry.fourcc;
   qtpad->sync = sync;
-  atom_trak_set_video_type (qtpad->trak, qtmux->context, &entry, rate,
-      ext_atom_list);
+  qtpad->trak_ste =
+      (SampleTableEntry *) atom_trak_set_video_type (qtpad->trak,
+      qtmux->context, &entry, rate, ext_atom_list);
 
   gst_object_unref (qtmux);
   return TRUE;
@@ -3264,8 +4081,6 @@ gst_qt_mux_subtitle_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
   GstStructure *structure;
   SubtitleSampleEntry entry = { 0, };
 
-  qtpad->prepare_buf_func = NULL;
-
   /* does not go well to renegotiate stream mid-way, unless
    * the old caps are a subset of the new one (this means upstream
    * added more info to the caps, as both should be 'fixed' caps) */
@@ -3310,7 +4125,9 @@ gst_qt_mux_subtitle_sink_set_caps (GstQTPad * qtpad, GstCaps * caps)
     goto refuse_caps;
 
   qtpad->fourcc = entry.fourcc;
-  atom_trak_set_subtitle_type (qtpad->trak, qtmux->context, &entry);
+  qtpad->trak_ste =
+      (SampleTableEntry *) atom_trak_set_subtitle_type (qtpad->trak,
+      qtmux->context, &entry);
 
   gst_object_unref (qtmux);
   return TRUE;
@@ -3366,15 +4183,25 @@ gst_qt_mux_sink_event (GstCollectPads * pads, GstCollectData * data,
       GstTagSetter *setter = GST_TAG_SETTER (qtmux);
       GstTagMergeMode mode;
       gchar *code;
+      GstQTPad *collect_pad;
 
       GST_OBJECT_LOCK (qtmux);
       mode = gst_tag_setter_get_tag_merge_mode (setter);
+      collect_pad = (GstQTPad *) gst_pad_get_element_private (pad);
 
       gst_event_parse_tag (event, &list);
       GST_DEBUG_OBJECT (qtmux, "received tag event on pad %s:%s : %"
           GST_PTR_FORMAT, GST_DEBUG_PAD_NAME (pad), list);
 
-      gst_tag_setter_merge_tags (setter, list, mode);
+      if (gst_tag_list_get_scope (list) == GST_TAG_SCOPE_GLOBAL) {
+        gst_tag_setter_merge_tags (setter, list, mode);
+        qtmux->tags_changed = TRUE;
+      } else {
+        if (!collect_pad->tags)
+          collect_pad->tags = gst_tag_list_new_empty ();
+        gst_tag_list_insert (collect_pad->tags, list, mode);
+        collect_pad->tags_changed = TRUE;
+      }
       GST_OBJECT_UNLOCK (qtmux);
 
       if (gst_tag_list_get_uint (list, GST_TAG_BITRATE, &avg_bitrate) |
@@ -3451,6 +4278,7 @@ gst_qt_mux_request_new_pad (GstElement * element,
   GstQTPadSetCapsFunc setcaps_func;
   gchar *name;
   gint pad_id;
+  gboolean lock = TRUE;
 
   if (templ->direction != GST_PAD_SINK)
     goto wrong_direction;
@@ -3479,6 +4307,7 @@ gst_qt_mux_request_new_pad (GstElement * element,
     } else {
       name = g_strdup_printf ("subtitle_%u", qtmux->subtitle_pads++);
     }
+    lock = FALSE;
   } else
     goto wrong_template;
 
@@ -3489,7 +4318,7 @@ gst_qt_mux_request_new_pad (GstElement * element,
   g_free (name);
   collect_pad = (GstQTPad *)
       gst_collect_pads_add_pad (qtmux->collect, newpad, sizeof (GstQTPad),
-      (GstCollectDataDestroyNotify) (gst_qt_mux_pad_reset), TRUE);
+      (GstCollectDataDestroyNotify) (gst_qt_mux_pad_reset), lock);
   /* set up pad */
   gst_qt_mux_pad_reset (collect_pad);
   collect_pad->trak = atom_trak_new (qtmux->context);
@@ -3560,6 +4389,34 @@ gst_qt_mux_get_property (GObject * object,
     case PROP_STREAMABLE:
       g_value_set_boolean (value, qtmux->streamable);
       break;
+    case PROP_RESERVED_MAX_DURATION:
+      g_value_set_uint64 (value, qtmux->reserved_max_duration);
+      break;
+    case PROP_RESERVED_DURATION_REMAINING:
+      if (qtmux->reserved_duration_remaining == GST_CLOCK_TIME_NONE)
+        g_value_set_uint64 (value, qtmux->reserved_max_duration);
+      else {
+        GstClockTime remaining = qtmux->reserved_duration_remaining;
+
+        /* Report the remaining space as the calculated remaining, minus
+         * however much we've muxed since the last update */
+        if (remaining > qtmux->muxed_since_last_update)
+          remaining -= qtmux->muxed_since_last_update;
+        else
+          remaining = 0;
+        GST_LOG_OBJECT (qtmux, "reserved duration remaining - reporting %"
+            G_GUINT64_FORMAT "(%" G_GUINT64_FORMAT " - %" G_GUINT64_FORMAT,
+            remaining, qtmux->reserved_duration_remaining,
+            qtmux->muxed_since_last_update);
+        g_value_set_uint64 (value, remaining);
+      }
+      break;
+    case PROP_RESERVED_MOOV_UPDATE_PERIOD:
+      g_value_set_uint64 (value, qtmux->reserved_moov_update_period);
+      break;
+    case PROP_RESERVED_BYTES_PER_SEC:
+      g_value_set_uint (value, qtmux->reserved_bytes_per_sec_per_trak);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3628,6 +4485,15 @@ gst_qt_mux_set_property (GObject * object,
       }
       break;
     }
+    case PROP_RESERVED_MAX_DURATION:
+      qtmux->reserved_max_duration = g_value_get_uint64 (value);
+      break;
+    case PROP_RESERVED_MOOV_UPDATE_PERIOD:
+      qtmux->reserved_moov_update_period = g_value_get_uint64 (value);
+      break;
+    case PROP_RESERVED_BYTES_PER_SEC:
+      qtmux->reserved_bytes_per_sec_per_trak = g_value_get_uint (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/gst/isomp4/gstqtmux.h b/gst/isomp4/gstqtmux.h
index 0d7f662..81a23fa 100644
--- a/gst/isomp4/gstqtmux.h
+++ b/gst/isomp4/gstqtmux.h
@@ -109,15 +109,21 @@ struct _GstQTPad
   /* dts of last_buf */
   GstClockTime last_dts;
 
+  /* This is compensate for CTTS */
+  GstClockTime dts_adjustment;
+
   /* store the first timestamp for comparing with other streams and
    * know if there are late streams */
   GstClockTime first_ts;
+  GstClockTime first_dts;
+
   guint buf_head;
   guint buf_tail;
 
   /* all the atom and chunk book-keeping is delegated here
    * unowned/uncounted reference, parent MOOV owns */
   AtomTRAK *trak;
+  SampleTableEntry *trak_ste;
   /* fragmented support */
   /* meta data book-keeping delegated here */
   AtomTRAF *traf;
@@ -128,6 +134,11 @@ struct _GstQTPad
   /* optional fragment index book-keeping */
   AtomTFRA *tfra;
 
+  /* Set when tags are received, cleared when written to moov */
+  gboolean tags_changed;
+
+  GstTagList *tags;
+
   /* if nothing is set, it won't be called */
   GstQTPadPrepareBufferFunc prepare_buf_func;
   GstQTPadSetCapsFunc set_caps;
@@ -142,6 +153,14 @@ typedef enum _GstQTMuxState
   GST_QT_MUX_STATE_EOS
 } GstQTMuxState;
 
+typedef enum _GstQtMuxMode {
+    GST_QT_MUX_MODE_MOOV_AT_END,
+    GST_QT_MUX_MODE_FRAGMENTED,
+    GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE,
+    GST_QT_MUX_MODE_FAST_START,
+    GST_QT_MUX_MODE_ROBUST_RECORDING
+} GstQtMuxMode;
+
 struct _GstQTMux
 {
   GstElement element;
@@ -153,16 +172,29 @@ struct _GstQTMux
   /* state */
   GstQTMuxState state;
 
-  /* size of header (prefix, atoms (ftyp, mdat)) */
+  /* Mux mode, inferred from property
+   * set in gst_qt_mux_start_file() */
+  GstQtMuxMode mux_mode;
+
+  /* size of header (prefix, atoms (ftyp, possibly moov, mdat header)) */
   guint64 header_size;
-  /* accumulated size of raw media data (a priori not including mdat header) */
+  /* accumulated size of raw media data (not including mdat header) */
   guint64 mdat_size;
-  /* position of mdat atom (for later updating) */
+  /* position of the moov (for fragmented mode) or reserved moov atom
+   * area (for robust-muxing mode) */
+  guint64 moov_pos;
+  /* position of mdat atom header (for later updating of size) in
+   * moov-at-end, fragmented and robust-muxing modes */
   guint64 mdat_pos;
 
   /* keep track of the largest chunk to fine-tune brands */
   GstClockTime longest_chunk;
 
+  /* Earliest timestamp across all pads/traks */
+  GstClockTime first_ts;
+  /* Last DTS across all pads (= duration) */
+  GstClockTime last_dts;
+
   /* atom helper objects */
   AtomsContext *context;
   AtomFTYP *ftyp;
@@ -170,6 +202,10 @@ struct _GstQTMux
   GSList *extra_atoms; /* list of extra top-level atoms (e.g. UUID for xmp)
                         * Stored as AtomInfo structs */
 
+  /* Set when tags are received, cleared when written to moov */
+  gboolean tags_changed;
+
+
   /* fragmented file index */
   AtomMFRA *mfra;
 
@@ -194,8 +230,35 @@ struct _GstQTMux
   gchar *fast_start_file_path;
   gchar *moov_recov_file_path;
   guint32 fragment_duration;
+  /* Whether or not to work in 'streamable' mode and not
+   * seek to rewrite headers - only valid for fragmented
+   * mode. */
   gboolean streamable;
 
+  /* Requested target maximum duration */
+  GstClockTime reserved_max_duration;
+  /* Estimate of remaining reserved header space (in ns of recording) */
+  GstClockTime reserved_duration_remaining;
+  /* Multiplier for conversion from reserved_max_duration to bytes */
+  guint reserved_bytes_per_sec_per_trak;
+
+  /* Reserved minimum MOOV size in bytes
+   * This is converted from reserved_max_duration
+   * using the bytes/trak/sec estimate */
+  guint32 reserved_moov_size;
+  /* Basic size of the moov (static headers + tags) */
+  guint32 base_moov_size;
+  /* Size of the most recently generated moov header */
+  guint32 last_moov_size;
+  /* True if the first moov in the ping-pong buffers
+   * is the active one. See gst_qt_mux_robust_recording_rewrite_moov() */
+  gboolean reserved_moov_first_active;
+
+  /* Tracking of periodic MOOV updates */
+  GstClockTime last_moov_update;
+  GstClockTime reserved_moov_update_period;
+  GstClockTime muxed_since_last_update;
+
   /* for request pad naming */
   guint video_pads, audio_pads, subtitle_pads;
 };
diff --git a/gst/isomp4/gstqtmuxmap.c b/gst/isomp4/gstqtmuxmap.c
index 5b17f85..1a8b6ce 100644
--- a/gst/isomp4/gstqtmuxmap.c
+++ b/gst/isomp4/gstqtmuxmap.c
@@ -47,12 +47,12 @@
 /* static info related to various format */
 
 #define COMMON_VIDEO_CAPS \
-  "width = (int) [ 16, 4096 ], " \
-  "height = (int) [ 16, 4096 ]"
+  "width = (int) [ 16, MAX ], " \
+  "height = (int) [ 16, MAX ]"
 
 #define COMMON_VIDEO_CAPS_NO_FRAMERATE \
-  "width = (int) [ 16, 4096 ], " \
-  "height = (int) [ 16, 4096 ] "
+  "width = (int) [ 16, MAX ], " \
+  "height = (int) [ 16, MAX ] "
 
 #define H263_CAPS \
   "video/x-h263, " \
@@ -73,6 +73,10 @@
   "divxversion = (int) 5, "\
   COMMON_VIDEO_CAPS
 
+#define PRORES_CAPS \
+  "video/x-prores, variant = (string) {standard, lt, hq, proxy}, " \
+  COMMON_VIDEO_CAPS
+
 #define SVQ_CAPS \
   "video/x-svq, " \
   "svqversion = (int) 3, " \
@@ -93,15 +97,11 @@
   COMMON_AUDIO_CAPS (2, MAX)
 
 #define PCM_CAPS_FULL \
-  PCM_CAPS "; " \
   "audio/x-raw, " \
-  "format = (string) { S24LE, S24BE }, " \
+  "format = (string) { S32LE, S32BE, S24LE, S24BE }, " \
   "layout = (string) interleaved, " \
   COMMON_AUDIO_CAPS (2, MAX) "; " \
-  "audio/x-raw, " \
-  "format = (string) { S32LE, S32BE }, " \
-  "layout = (string) interleaved, " \
-  COMMON_AUDIO_CAPS (2, MAX)
+  PCM_CAPS
 
 #define MP3_CAPS \
   "audio/mpeg, " \
@@ -115,6 +115,10 @@
   "stream-format = (string) raw, " \
   COMMON_AUDIO_CAPS (8, MAX)
 
+#define AC3_CAPS \
+  "audio/x-ac3, " \
+  COMMON_AUDIO_CAPS (6, MAX)
+
 #define AMR_CAPS \
   "audio/AMR, " \
   "rate = (int) 8000, " \
@@ -149,9 +153,10 @@ GstQTMuxFormatProp gst_qt_mux_format_list[] = {
         GST_STATIC_CAPS ("video/quicktime, variant = (string) apple; "
             "video/quicktime"),
         GST_STATIC_CAPS ("video/x-raw, "
-            "format = (string) { RGB, UYVY }, "
+            "format = (string) { RGB, UYVY, v210 }, "
             COMMON_VIDEO_CAPS "; "
             MPEG4V_CAPS "; "
+            PRORES_CAPS "; "
             H263_CAPS "; "
             H264_CAPS "; "
             SVQ_CAPS "; "
@@ -184,7 +189,7 @@ GstQTMuxFormatProp gst_qt_mux_format_list[] = {
         GST_STATIC_CAPS ("video/quicktime, variant = (string) iso"),
         GST_STATIC_CAPS (MPEG4V_CAPS "; " H264_CAPS ";"
             "video/x-mp4-part," COMMON_VIDEO_CAPS),
-        GST_STATIC_CAPS (MP3_CAPS "; " AAC_CAPS " ; " ALAC_CAPS),
+        GST_STATIC_CAPS (MP3_CAPS "; " AAC_CAPS " ; " AC3_CAPS " ; " ALAC_CAPS),
       GST_STATIC_CAPS (TEXT_UTF8)}
   ,
   /* Microsoft Smooth Streaming fmp4/isml */
@@ -210,7 +215,7 @@ GstQTMuxFormatProp gst_qt_mux_format_list[] = {
         "Gst3GPPMux",
         GST_STATIC_CAPS ("video/quicktime, variant = (string) 3gpp"),
         GST_STATIC_CAPS (H263_CAPS "; " MPEG4V_CAPS "; " H264_CAPS),
-        GST_STATIC_CAPS (AMR_CAPS "; " MP3_CAPS "; " AAC_CAPS),
+        GST_STATIC_CAPS (AMR_CAPS "; " MP3_CAPS "; " AAC_CAPS "; " AC3_CAPS),
       GST_STATIC_CAPS (TEXT_UTF8)}
   ,
   /* ISO 15444-3: Motion-JPEG-2000 (also ISO base media extension) */
@@ -284,14 +289,15 @@ gst_qt_mux_map_format_to_header (GstQTMuxFormat format, GstBuffer ** _prefix,
     guint32 * _major, guint32 * _version, GList ** _compatible, AtomMOOV * moov,
     GstClockTime longest_chunk, gboolean faststart)
 {
-  static guint32 qt_brands[] = { 0 };
-  static guint32 mp4_brands[] = { FOURCC_mp41, FOURCC_isom, FOURCC_iso2, 0 };
-  static guint32 isml_brands[] = { FOURCC_iso2, 0 };
-  static guint32 gpp_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };
-  static guint32 mjp2_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };
-  static guint8 mjp2_prefix[] =
+  static const guint32 qt_brands[] = { 0 };
+  static const guint32 mp4_brands[] =
+      { FOURCC_mp41, FOURCC_isom, FOURCC_iso2, 0 };
+  static const guint32 isml_brands[] = { FOURCC_iso2, 0 };
+  static const guint32 gpp_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };
+  static const guint32 mjp2_brands[] = { FOURCC_isom, FOURCC_iso2, 0 };
+  static const guint8 mjp2_prefix[] =
       { 0, 0, 0, 12, 'j', 'P', ' ', ' ', 0x0D, 0x0A, 0x87, 0x0A };
-  guint32 *comp = NULL;
+  const guint32 *comp = NULL;
   guint32 major = 0, version = 0;
   GstBuffer *prefix = NULL;
   GList *result = NULL;
diff --git a/gst/isomp4/gstrtpxqtdepay.c b/gst/isomp4/gstrtpxqtdepay.c
index 3bce461..9116ccc 100644
--- a/gst/isomp4/gstrtpxqtdepay.c
+++ b/gst/isomp4/gstrtpxqtdepay.c
@@ -73,7 +73,7 @@ enum
 
 enum
 {
-  ARG_0,
+  PROP_0,
 };
 
 static GstStaticPadTemplate gst_rtp_xqt_depay_src_template =
diff --git a/gst/isomp4/properties.h b/gst/isomp4/properties.h
index 443288c..c36fe48 100644
--- a/gst/isomp4/properties.h
+++ b/gst/isomp4/properties.h
@@ -46,7 +46,7 @@
 #include <glib.h>
 #include <string.h>
 
-/**
+/*
  * Functions for copying atoms properties.
  *
  * All of them receive, as the input, the property to be copied, the destination
diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
index ae1491e..d727a54 100644
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -6,7 +6,10 @@
  * Copyright (C) <2009> Tim-Philipp Müller <tim centricular net>
  * Copyright (C) <2009> STEricsson <benjamin.gaignard@stericsson.com>
  * Copyright (C) <2013> Sreerenj Balachandran <sreerenj.balachandran@intel.com>
- * Copyright (C) <2013> Intel Coroporation
+ * Copyright (C) <2013> Intel Corporation
+ * Copyright (C) <2014> Centricular Ltd
+ * Copyright (C) <2015> YouView TV Ltd.
+ *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
@@ -34,7 +37,7 @@
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch-1.0 filesrc location=test.mov ! qtdemux name=demux  demux.audio_0 ! decodebin ! audioconvert ! audioresample ! autoaudiosink   demux.video_0 ! queue ! decodebin ! videoconvert ! videoscale ! autovideosink
+ * gst-launch-1.0 filesrc location=test.mov ! qtdemux name=demux  demux.audio_0 ! queue ! decodebin ! audioconvert ! audioresample ! autoaudiosink   demux.video_0 ! queue ! decodebin ! videoconvert ! videoscale ! autovideosink
  * ]| Play (parse and decode) a .mov file and try to output it to
  * an automatically detected soundcard and videosink. If the MOV file contains
  * compressed audio or video data, this will only work if you have the
@@ -90,7 +93,7 @@
 #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
     QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
 
-#define STREAM_IS_EOS(s) (s->time_position == -1)
+#define STREAM_IS_EOS(s) (s->time_position == GST_CLOCK_TIME_NONE)
 
 GST_DEBUG_CATEGORY (qtdemux_debug);
 
@@ -98,6 +101,8 @@ GST_DEBUG_CATEGORY (qtdemux_debug);
 typedef struct _QtDemuxSegment QtDemuxSegment;
 typedef struct _QtDemuxSample QtDemuxSample;
 
+typedef struct _QtDemuxCencSampleSetInfo QtDemuxCencSampleSetInfo;
+
 /*struct _QtNode
 {
   guint32 type;
@@ -115,15 +120,19 @@ struct _QtDemuxSample
   gboolean keyframe;            /* TRUE when this packet is a keyframe */
 };
 
+/* Macros for converting to/from timescale */
+#define QTSTREAMTIME_TO_GSTTIME(stream, value) (gst_util_uint64_scale((value), GST_SECOND, (stream)->timescale))
+#define GSTTIME_TO_QTSTREAMTIME(stream, value) (gst_util_uint64_scale((value), (stream)->timescale, GST_SECOND))
+
+#define QTTIME_TO_GSTTIME(qtdemux, value) (gst_util_uint64_scale((value), GST_SECOND, (qtdemux)->timescale))
+#define GSTTIME_TO_QTTIME(qtdemux, value) (gst_util_uint64_scale((value), (qtdemux)->timescale, GST_SECOND))
+
 /* timestamp is the DTS */
-#define QTSAMPLE_DTS(stream,sample) gst_util_uint64_scale ((sample)->timestamp,\
-    GST_SECOND, (stream)->timescale)
+#define QTSAMPLE_DTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)->timestamp))
 /* timestamp + offset is the PTS */
-#define QTSAMPLE_PTS(stream,sample) gst_util_uint64_scale ((sample)->timestamp + \
-    (sample)->pts_offset, GST_SECOND, (stream)->timescale)
+#define QTSAMPLE_PTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)->timestamp + (stream)->cslg_shift + (sample)->pts_offset))
 /* timestamp + duration - dts is the duration */
-#define QTSAMPLE_DUR_DTS(stream,sample,dts) (gst_util_uint64_scale ((sample)->timestamp + \
-    (sample)->duration, GST_SECOND, (stream)->timescale) - (dts));
+#define QTSAMPLE_DUR_DTS(stream, sample, dts) (QTSTREAMTIME_TO_GSTTIME ((stream), (sample)->timestamp + (sample)->duration) - (dts))
 
 #define QTSAMPLE_KEYFRAME(stream,sample) ((stream)->all_keyframe || (sample)->keyframe)
 
@@ -188,17 +197,26 @@ struct _QtDemuxSample
 struct _QtDemuxSegment
 {
   /* global time and duration, all gst time */
-  guint64 time;
-  guint64 stop_time;
-  guint64 duration;
+  GstClockTime time;
+  GstClockTime stop_time;
+  GstClockTime duration;
   /* media time of trak, all gst time */
-  guint64 media_start;
-  guint64 media_stop;
+  GstClockTime media_start;
+  GstClockTime media_stop;
   gdouble rate;
+  /* Media start time in trak timescale units */
+  guint32 trak_media_start;
 };
 
 #define QTSEGMENT_IS_EMPTY(s) ((s)->media_start == GST_CLOCK_TIME_NONE)
 
+/* Used with fragmented MP4 files (mfra atom) */
+typedef struct
+{
+  GstClockTime ts;
+  guint64 moof_offset;
+} QtDemuxRandomAccessEntry;
+
 struct _QtDemuxStream
 {
   GstPad *pad;
@@ -233,7 +251,7 @@ struct _QtDemuxStream
   guint32 n_samples;
   QtDemuxSample *samples;
   gboolean all_keyframe;        /* TRUE when all samples are keyframes (no stss) */
-  guint32 min_duration;         /* duration in timescale of first sample, used for figuring out
+  guint32 first_duration;       /* duration in timescale of first sample, used for figuring out
                                    the framerate, in timescale units */
   guint32 offset_in_sample;
   guint32 max_buffer_size;
@@ -288,7 +306,8 @@ struct _QtDemuxStream
   /* current position */
   guint32 segment_index;
   guint32 sample_index;
-  guint64 time_position;        /* in gst time */
+  GstClockTime time_position;   /* in gst time */
+  guint64 accumulated_base;
 
   /* the Gst segment we are processing out, used for clipping */
   GstSegment segment;
@@ -297,6 +316,7 @@ struct _QtDemuxStream
   /* quicktime segments */
   guint32 n_segments;
   QtDemuxSegment *segments;
+  gboolean dummy_segment;
   guint32 from_sample;
   guint32 to_sample;
 
@@ -347,6 +367,11 @@ struct _QtDemuxStream
   gboolean stps_present;
   guint32 n_sample_partial_syncs;
   guint32 stps_index;
+  QtDemuxRandomAccessEntry *ra_entries;
+  guint n_ra_entries;
+
+  const QtDemuxRandomAccessEntry *pending_seek;
+
   /* ctts */
   gboolean ctts_present;
   guint32 n_composition_times;
@@ -355,6 +380,9 @@ struct _QtDemuxStream
   guint32 ctts_count;
   gint32 ctts_soffset;
 
+  /* cslg */
+  guint32 cslg_shift;
+
   /* fragmented */
   gboolean parsed_trex;
   guint32 def_sample_duration;
@@ -362,6 +390,27 @@ struct _QtDemuxStream
   guint32 def_sample_flags;
 
   gboolean disabled;
+
+  /* stereoscopic video streams */
+  GstVideoMultiviewMode multiview_mode;
+  GstVideoMultiviewFlags multiview_flags;
+
+  /* protected streams */
+  gboolean protected;
+  guint32 protection_scheme_type;
+  guint32 protection_scheme_version;
+  gpointer protection_scheme_info;      /* specific to the protection scheme */
+  GQueue protection_scheme_event_queue;
+};
+
+/* Contains properties and cryptographic info for a set of samples from a
+ * track protected using Common Encryption (cenc) */
+struct _QtDemuxCencSampleSetInfo
+{
+  GstStructure *default_properties;
+
+  /* @crypto_info holds one GstStructure per sample */
+  GPtrArray *crypto_info;
 };
 
 enum QtDemuxState
@@ -379,6 +428,8 @@ static GNode *qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc);
 static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
     guint32 fourcc, GstByteReader * parser);
 
+static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
+
 static GstStaticPadTemplate gst_qtdemux_sink_template =
     GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
@@ -412,7 +463,7 @@ static void gst_qtdemux_dispose (GObject * object);
 
 static guint32
 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
-    guint64 media_time);
+    GstClockTime media_time);
 static guint32
 gst_qtdemux_find_index_for_given_media_offset_linear (GstQTDemux * qtdemux,
     QtDemuxStream * str, gint64 media_offset);
@@ -443,6 +494,8 @@ static gboolean qtdemux_parse_moov (GstQTDemux * qtdemux,
 static gboolean qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node,
     const guint8 * buffer, guint length);
 static gboolean qtdemux_parse_tree (GstQTDemux * qtdemux);
+static void qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist,
+    GNode * udta);
 
 static void gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
     QtDemuxStream * stream, GNode * esds, GstTagList * list);
@@ -471,6 +524,12 @@ static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
 static void qtdemux_do_allocation (GstQTDemux * qtdemux,
     QtDemuxStream * stream);
 
+static gboolean qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux);
+static void check_update_duration (GstQTDemux * qtdemux, GstClockTime duration);
+
+static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
+    const gchar * id);
+
 static void
 gst_qtdemux_class_init (GstQTDemuxClass * klass)
 {
@@ -530,19 +589,21 @@ gst_qtdemux_init (GstQTDemux * qtdemux)
   qtdemux->offset = 0;
   qtdemux->first_mdat = -1;
   qtdemux->got_moov = FALSE;
-  qtdemux->mdatoffset = GST_CLOCK_TIME_NONE;
+  qtdemux->mdatoffset = -1;
   qtdemux->mdatbuffer = NULL;
   qtdemux->restoredata_buffer = NULL;
-  qtdemux->restoredata_offset = GST_CLOCK_TIME_NONE;
+  qtdemux->restoredata_offset = -1;
   qtdemux->fragment_start = -1;
   qtdemux->fragment_start_offset = -1;
   qtdemux->media_caps = NULL;
   qtdemux->exposed = FALSE;
   qtdemux->mss_mode = FALSE;
   qtdemux->pending_newsegment = NULL;
-  qtdemux->upstream_newsegment = FALSE;
+  qtdemux->upstream_format_is_time = FALSE;
   qtdemux->have_group_id = FALSE;
   qtdemux->group_id = G_MAXUINT;
+  qtdemux->protection_system_ids = NULL;
+  g_queue_init (&qtdemux->protection_event_queue);
   gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
   qtdemux->flowcombiner = gst_flow_combiner_new ();
 
@@ -559,6 +620,9 @@ gst_qtdemux_dispose (GObject * object)
     qtdemux->adapter = NULL;
   }
   gst_flow_combiner_free (qtdemux->flowcombiner);
+  g_queue_foreach (&qtdemux->protection_event_queue, (GFunc) gst_event_unref,
+      NULL);
+  g_queue_clear (&qtdemux->protection_event_queue);
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
@@ -688,11 +752,11 @@ gst_qtdemux_src_convert (GstPad * pad, GstFormat src_format, gint64 src_value,
             return FALSE;
 
           *dest_value =
-              gst_util_uint64_scale (stream->samples[index].timestamp,
-              GST_SECOND, stream->timescale);
-          GST_DEBUG_OBJECT (qtdemux, "Format Conversion Offset->Time :%"
-              G_GUINT64_FORMAT "->%" GST_TIME_FORMAT,
-              src_value, GST_TIME_ARGS (*dest_value));
+              QTSTREAMTIME_TO_GSTTIME (stream,
+              stream->samples[index].timestamp);
+          GST_DEBUG_OBJECT (qtdemux,
+              "Format Conversion Offset->Time :%" G_GUINT64_FORMAT "->%"
+              GST_TIME_FORMAT, src_value, GST_TIME_ARGS (*dest_value));
           break;
         }
         default:
@@ -712,7 +776,7 @@ done:
 #endif
 
 static gboolean
-gst_qtdemux_get_duration (GstQTDemux * qtdemux, gint64 * duration)
+gst_qtdemux_get_duration (GstQTDemux * qtdemux, GstClockTime * duration)
 {
   gboolean res = TRUE;
 
@@ -720,8 +784,7 @@ gst_qtdemux_get_duration (GstQTDemux * qtdemux, gint64 * duration)
 
   if (qtdemux->duration != 0) {
     if (qtdemux->duration != G_MAXINT64 && qtdemux->timescale != 0) {
-      *duration = gst_util_uint64_scale (qtdemux->duration,
-          GST_SECOND, qtdemux->timescale);
+      *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux->duration);
     }
   }
   return res;
@@ -757,9 +820,8 @@ gst_qtdemux_handle_src_query (GstPad * pad, GstObject * parent,
         /* First try to query upstream */
         res = gst_pad_query_default (pad, parent, query);
         if (!res) {
-          gint64 duration = -1;
-          gst_qtdemux_get_duration (qtdemux, &duration);
-          if (duration > 0) {
+          guint64 duration;
+          if (gst_qtdemux_get_duration (qtdemux, &duration) && duration > 0) {
             gst_query_set_duration (query, GST_FORMAT_TIME, duration);
             res = TRUE;
           }
@@ -795,7 +857,7 @@ gst_qtdemux_handle_src_query (GstPad * pad, GstObject * parent,
       if (!res) {
         gst_query_parse_seeking (query, &fmt, NULL, NULL, NULL);
         if (fmt == GST_FORMAT_TIME) {
-          gint64 duration = -1;
+          GstClockTime duration = GST_CLOCK_TIME_NONE;
 
           gst_qtdemux_get_duration (qtdemux, &duration);
           seekable = TRUE;
@@ -925,7 +987,7 @@ typedef struct
 static gint
 find_func (QtDemuxSample * s1, guint64 * media_time, gpointer user_data)
 {
-  if (s1->timestamp > *media_time)
+  if (s1->timestamp + s1->pts_offset > *media_time)
     return 1;
 
   return -1;
@@ -1008,28 +1070,32 @@ parse_failed:
  */
 static guint32
 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
-    guint64 media_time)
+    GstClockTime media_time)
 {
   guint32 index = 0;
   guint64 mov_time;
+  QtDemuxSample *sample;
 
   /* convert media_time to mov format */
   mov_time =
       gst_util_uint64_scale_ceil (media_time, str->timescale, GST_SECOND);
 
-  if (mov_time == str->samples[0].timestamp)
+  sample = str->samples;
+  if (mov_time == sample->timestamp + sample->pts_offset)
     return index;
 
   /* use faster search if requested time in already parsed range */
+  sample = str->samples + str->stbl_index;
   if (str->stbl_index >= 0 &&
-      mov_time <= str->samples[str->stbl_index].timestamp)
+      mov_time <= (sample->timestamp + sample->pts_offset))
     return gst_qtdemux_find_index (qtdemux, str, media_time);
 
   while (index < str->n_samples - 1) {
     if (!qtdemux_parse_samples (qtdemux, str, index + 1))
       goto parse_failed;
 
-    if (mov_time < str->samples[index + 1].timestamp)
+    sample = str->samples + index + 1;
+    if (mov_time < (sample->timestamp + sample->pts_offset))
       break;
 
     index++;
@@ -1086,41 +1152,39 @@ beach:
 
 /* find the segment for @time_position for @stream
  *
- * Returns -1 if the segment cannot be found.
+ * Returns the index of the segment containing @time_position.
+ * Returns the last segment and sets the @eos variable to TRUE
+ * if the time is beyond the end. @eos may be NULL
  */
 static guint32
 gst_qtdemux_find_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
-    guint64 time_position)
+    GstClockTime time_position)
 {
   gint i;
   guint32 seg_idx;
 
-  GST_LOG_OBJECT (qtdemux, "finding segment for %" GST_TIME_FORMAT,
+  GST_LOG_OBJECT (stream->pad, "finding segment for %" GST_TIME_FORMAT,
       GST_TIME_ARGS (time_position));
 
-  /* find segment corresponding to time_position if we are looking
-   * for a segment. */
   seg_idx = -1;
   for (i = 0; i < stream->n_segments; i++) {
     QtDemuxSegment *segment = &stream->segments[i];
 
-    GST_LOG_OBJECT (qtdemux,
+    GST_LOG_OBJECT (stream->pad,
         "looking at segment %" GST_TIME_FORMAT "-%" GST_TIME_FORMAT,
         GST_TIME_ARGS (segment->time), GST_TIME_ARGS (segment->stop_time));
 
     /* For the last segment we include stop_time in the last segment */
     if (i < stream->n_segments - 1) {
       if (segment->time <= time_position && time_position < segment->stop_time) {
-        GST_LOG_OBJECT (qtdemux, "segment %d matches", i);
+        GST_LOG_OBJECT (stream->pad, "segment %d matches", i);
         seg_idx = i;
         break;
       }
     } else {
-      if (segment->time <= time_position && time_position <= segment->stop_time) {
-        GST_LOG_OBJECT (qtdemux, "segment %d matches", i);
-        seg_idx = i;
-        break;
-      }
+      /* Last segment always matches */
+      seg_idx = i;
+      break;
     }
   }
   return seg_idx;
@@ -1152,7 +1216,7 @@ gst_qtdemux_move_stream (GstQTDemux * qtdemux, QtDemuxStream * str,
 
 static void
 gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
-    gint64 * key_time, gint64 * key_offset)
+    gboolean use_sparse, gint64 * key_time, gint64 * key_offset)
 {
   guint64 min_offset;
   gint64 min_byte_offset = -1;
@@ -1166,20 +1230,19 @@ gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
     QtDemuxStream *str;
     guint32 index, kindex;
     guint32 seg_idx;
-    guint64 media_start;
-    guint64 media_time;
-    guint64 seg_time;
+    GstClockTime media_start;
+    GstClockTime media_time;
+    GstClockTime seg_time;
     QtDemuxSegment *seg;
 
     str = qtdemux->streams[n];
 
+    if (str->sparse && !use_sparse)
+      continue;
+
     seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
     GST_DEBUG_OBJECT (qtdemux, "align segment %d", seg_idx);
 
-    /* segment not found, continue with normal flow */
-    if (seg_idx == -1)
-      continue;
-
     /* get segment and time in the segment */
     seg = &str->segments[seg_idx];
     seg_time = desired_time - seg->time;
@@ -1202,18 +1265,17 @@ gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
       index = kindex;
 
       /* get timestamp of keyframe */
-      media_time =
-          gst_util_uint64_scale (str->samples[kindex].timestamp, GST_SECOND,
-          str->timescale);
-      GST_DEBUG_OBJECT (qtdemux, "keyframe at %u with time %" GST_TIME_FORMAT
-          " at offset %" G_GUINT64_FORMAT,
-          kindex, GST_TIME_ARGS (media_time), str->samples[kindex].offset);
+      media_time = QTSAMPLE_DTS (str, &str->samples[kindex]);
+      GST_DEBUG_OBJECT (qtdemux,
+          "keyframe at %u with time %" GST_TIME_FORMAT " at offset %"
+          G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
+          str->samples[kindex].offset);
 
       /* keyframes in the segment get a chance to change the
        * desired_offset. keyframes out of the segment are
        * ignored. */
       if (media_time >= seg->media_start) {
-        guint64 seg_time;
+        GstClockTime seg_time;
 
         /* this keyframe is inside the segment, convert back to
          * segment time */
@@ -1289,7 +1351,7 @@ gst_qtdemux_do_push_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
           stop_type, &stop))
     goto no_format;
 
-  /* Upstrea seek in bytes will have undefined stop, but qtdemux stores
+  /* Upstream seek in bytes will have undefined stop, but qtdemux stores
    * the original stop position to use when upstream pushes the new segment
    * for this seek */
   original_stop = stop;
@@ -1298,7 +1360,7 @@ gst_qtdemux_do_push_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
   /* find reasonable corresponding BYTE position,
    * also try to mind about keyframes, since we can not go back a bit for them
    * later on */
-  gst_qtdemux_adjust_seek (qtdemux, cur, &key_cur, &byte_cur);
+  gst_qtdemux_adjust_seek (qtdemux, cur, FALSE, &key_cur, &byte_cur);
 
   if (byte_cur == -1)
     goto abort_seek;
@@ -1367,7 +1429,7 @@ no_format:
  */
 static gboolean
 gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
-    guint32 seqnum)
+    guint32 seqnum, GstSeekFlags flags)
 {
   gint64 desired_offset;
   gint n;
@@ -1380,20 +1442,22 @@ gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
   /* may not have enough fragmented info to do this adjustment,
    * and we can't scan (and probably should not) at this time with
    * possibly flushing upstream */
-  if ((segment->flags & GST_SEEK_FLAG_KEY_UNIT) && !qtdemux->fragmented) {
+  if ((flags & GST_SEEK_FLAG_KEY_UNIT) && !qtdemux->fragmented) {
     gint64 min_offset;
 
-    gst_qtdemux_adjust_seek (qtdemux, desired_offset, &min_offset, NULL);
+    gst_qtdemux_adjust_seek (qtdemux, desired_offset, TRUE, &min_offset, NULL);
     GST_DEBUG_OBJECT (qtdemux, "keyframe seek, align to %"
         GST_TIME_FORMAT, GST_TIME_ARGS (min_offset));
     desired_offset = min_offset;
   }
 
   /* and set all streams to the final position */
+  gst_flow_combiner_reset (qtdemux->flowcombiner);
   for (n = 0; n < qtdemux->n_streams; n++) {
     QtDemuxStream *stream = qtdemux->streams[n];
 
     stream->time_position = desired_offset;
+    stream->accumulated_base = 0;
     stream->sample_index = -1;
     stream->offset_in_sample = 0;
     stream->segment_index = -1;
@@ -1405,11 +1469,18 @@ gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
   }
   segment->position = desired_offset;
   segment->time = desired_offset;
-  qtdemux->segment_base = desired_offset;
+  if (segment->rate >= 0) {
+    segment->start = desired_offset;
 
-  /* we stop at the end */
-  if (segment->stop == -1)
-    segment->stop = segment->duration;
+    /* we stop at the end */
+    if (segment->stop == -1)
+      segment->stop = segment->duration;
+  } else {
+    segment->stop = desired_offset;
+  }
+
+  if (qtdemux->fragmented)
+    qtdemux->fragmented_seek_pending = TRUE;
 
   return TRUE;
 }
@@ -1479,7 +1550,7 @@ gst_qtdemux_do_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
   }
 
   /* now do the seek, this actually never returns FALSE */
-  gst_qtdemux_perform_seek (qtdemux, &seeksegment, seqnum);
+  gst_qtdemux_perform_seek (qtdemux, &seeksegment, seqnum, flags);
 
   /* prepare for streaming again */
   if (flush) {
@@ -1502,6 +1573,7 @@ gst_qtdemux_do_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), msg);
   }
 
+  /* restart streaming, NEWSEGMENT will be sent from the streaming thread. */
   gst_pad_start_task (qtdemux->sinkpad, (GstTaskFunction) gst_qtdemux_loop,
       qtdemux->sinkpad, NULL);
 
@@ -1556,7 +1628,7 @@ gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
       GstClockTime ts = gst_util_get_timestamp ();
 #endif
 
-      if (qtdemux->upstream_newsegment && qtdemux->fragmented) {
+      if (qtdemux->upstream_format_is_time && qtdemux->fragmented) {
         /* seek should be handled by upstream, we might need to re-download fragments */
         GST_DEBUG_OBJECT (qtdemux,
             "let upstream handle seek for fragmented playback");
@@ -1663,8 +1735,7 @@ gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
       /* avoid index from sparse streams since they might be far away */
       if (!str->sparse) {
         /* determine min/max time */
-        time = str->samples[i].timestamp + str->samples[i].pts_offset;
-        time = gst_util_uint64_scale (time, GST_SECOND, str->timescale);
+        time = QTSAMPLE_PTS (str, &str->samples[i]);
         if (min_time == -1 || (!fw && time > min_time) ||
             (fw && time < min_time)) {
           min_time = time;
@@ -1710,6 +1781,13 @@ _create_stream (void)
   stream->sample_index = -1;
   stream->offset_in_sample = 0;
   stream->new_stream = TRUE;
+  stream->multiview_mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
+  stream->multiview_flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
+  stream->protected = FALSE;
+  stream->protection_scheme_type = 0;
+  stream->protection_scheme_version = 0;
+  stream->protection_scheme_info = NULL;
+  g_queue_init (&stream->protection_scheme_event_queue);
   return stream;
 }
 
@@ -1800,7 +1878,7 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
   GST_DEBUG_OBJECT (qtdemux, "Resetting demux");
   gst_pad_stop_task (qtdemux->sinkpad);
 
-  if (hard || qtdemux->upstream_newsegment) {
+  if (hard || qtdemux->upstream_format_is_time) {
     qtdemux->state = QTDEMUX_STATE_INITIAL;
     qtdemux->neededbytes = 16;
     qtdemux->todrop = 0;
@@ -1808,8 +1886,8 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     qtdemux->posted_redirect = FALSE;
     qtdemux->first_mdat = -1;
     qtdemux->header_size = 0;
-    qtdemux->mdatoffset = GST_CLOCK_TIME_NONE;
-    qtdemux->restoredata_offset = GST_CLOCK_TIME_NONE;
+    qtdemux->mdatoffset = -1;
+    qtdemux->restoredata_offset = -1;
     if (qtdemux->mdatbuffer)
       gst_buffer_unref (qtdemux->mdatbuffer);
     if (qtdemux->restoredata_buffer)
@@ -1837,23 +1915,29 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     if (qtdemux->pending_newsegment)
       gst_event_unref (qtdemux->pending_newsegment);
     qtdemux->pending_newsegment = NULL;
-    qtdemux->upstream_newsegment = FALSE;
+    qtdemux->upstream_format_is_time = FALSE;
     qtdemux->upstream_seekable = FALSE;
     qtdemux->upstream_size = 0;
 
     qtdemux->fragment_start = -1;
     qtdemux->fragment_start_offset = -1;
     qtdemux->duration = 0;
-    qtdemux->mfra_offset = 0;
     qtdemux->moof_offset = 0;
     qtdemux->chapters_track_id = 0;
     qtdemux->have_group_id = FALSE;
     qtdemux->group_id = G_MAXUINT;
+
+    if (qtdemux->protection_system_ids) {
+      g_ptr_array_free (qtdemux->protection_system_ids, TRUE);
+      qtdemux->protection_system_ids = NULL;
+    }
+    g_queue_foreach (&qtdemux->protection_event_queue, (GFunc) gst_event_unref,
+        NULL);
+    g_queue_clear (&qtdemux->protection_event_queue);
   }
   qtdemux->offset = 0;
   gst_adapter_clear (qtdemux->adapter);
   gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
-  qtdemux->segment_base = 0;
 
   if (hard) {
     for (n = 0; n < qtdemux->n_streams; n++) {
@@ -1871,13 +1955,16 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     qtdemux->timescale = 0;
     qtdemux->got_moov = FALSE;
   } else if (qtdemux->mss_mode) {
+    gst_flow_combiner_reset (qtdemux->flowcombiner);
     for (n = 0; n < qtdemux->n_streams; n++)
       gst_qtdemux_stream_clear (qtdemux, qtdemux->streams[n]);
   } else {
+    gst_flow_combiner_reset (qtdemux->flowcombiner);
     for (n = 0; n < qtdemux->n_streams; n++) {
       qtdemux->streams[n]->sent_eos = FALSE;
       qtdemux->streams[n]->segment_seqnum = 0;
       qtdemux->streams[n]->time_position = 0;
+      qtdemux->streams[n]->accumulated_base = 0;
     }
   }
 }
@@ -1908,7 +1995,7 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
       if (segment.format == GST_FORMAT_TIME) {
         GST_DEBUG_OBJECT (demux, "new pending_newsegment");
         gst_event_replace (&demux->pending_newsegment, event);
-        demux->upstream_newsegment = TRUE;
+        demux->upstream_format_is_time = TRUE;
       } else {
         GST_DEBUG_OBJECT (demux, "Not storing upstream newsegment, "
             "not in time format");
@@ -1960,16 +2047,9 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
           segment.stop = MAX (segment.stop, segment.start);
         }
       } else if (segment.format == GST_FORMAT_TIME) {
-        /* NOP */
-#if 0
-        gst_qtdemux_push_event (demux, gst_event_ref (event));
-        gst_event_new_new_segment_full (segment.update, segment.rate,
-            segment.arate, GST_FORMAT_TIME, segment.start, segment.stop,
-            segment.start);
-        gst_adapter_clear (demux->adapter);
-        demux->neededbytes = 16;
-        goto exit;
-#endif
+        /* push all data on the adapter before starting this
+         * new segment */
+        gst_qtdemux_process_adapter (demux, TRUE);
       } else {
         GST_DEBUG_OBJECT (demux, "unsupported segment format, ignoring");
         goto exit;
@@ -1990,26 +2070,30 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 
       /* clear leftover in current segment, if any */
       gst_adapter_clear (demux->adapter);
+
       /* set up streaming thread */
-      gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &stream, &idx, NULL);
       demux->offset = offset;
-      if (stream) {
-        demux->todrop = stream->samples[idx].offset - offset;
-        demux->neededbytes = demux->todrop + stream->samples[idx].size;
+      if (demux->upstream_format_is_time) {
+        GST_DEBUG_OBJECT (demux, "Upstream is driving in time format, "
+            "set values to restart reading from a new atom");
+        demux->neededbytes = 16;
+        demux->todrop = 0;
       } else {
-        /* set up for EOS */
-        if (demux->upstream_newsegment) {
-          demux->neededbytes = 16;
+        gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &stream, &idx,
+            NULL);
+        if (stream) {
+          demux->todrop = stream->samples[idx].offset - offset;
+          demux->neededbytes = demux->todrop + stream->samples[idx].size;
         } else {
+          /* set up for EOS */
           demux->neededbytes = -1;
+          demux->todrop = 0;
         }
-        demux->todrop = 0;
       }
     exit:
       gst_event_unref (event);
       res = TRUE;
       goto drop;
-      break;
     }
     case GST_EVENT_FLUSH_STOP:
     {
@@ -2051,7 +2135,21 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
       res = TRUE;
       gst_event_unref (event);
       goto drop;
-      break;
+    }
+    case GST_EVENT_PROTECTION:
+    {
+      const gchar *system_id = NULL;
+
+      gst_event_parse_protection (event, &system_id, NULL, NULL);
+      GST_DEBUG_OBJECT (demux, "Received protection event for system ID %s",
+          system_id);
+      gst_qtdemux_append_protection_system_id (demux, system_id);
+      /* save the event for later, for source pads that have not been created */
+      g_queue_push_tail (&demux->protection_event_queue, gst_event_ref (event));
+      /* send it to all pads that already exist */
+      gst_qtdemux_push_event (demux, event);
+      res = TRUE;
+      goto drop;
     }
     default:
       break;
@@ -2122,6 +2220,35 @@ gst_qtdemux_stbl_free (QtDemuxStream * stream)
 }
 
 static void
+gst_qtdemux_stream_flush_segments_data (GstQTDemux * qtdemux,
+    QtDemuxStream * stream)
+{
+  g_free (stream->segments);
+  stream->segments = NULL;
+  stream->segment_index = -1;
+  stream->accumulated_base = 0;
+}
+
+static void
+gst_qtdemux_stream_flush_samples_data (GstQTDemux * qtdemux,
+    QtDemuxStream * stream)
+{
+  g_free (stream->samples);
+  stream->samples = NULL;
+  gst_qtdemux_stbl_free (stream);
+
+  /* fragments */
+  g_free (stream->ra_entries);
+  stream->ra_entries = NULL;
+  stream->n_ra_entries = 0;
+
+  stream->sample_index = -1;
+  stream->stbl_index = -1;
+  stream->n_samples = 0;
+  stream->time_position = 0;
+}
+
+static void
 gst_qtdemux_stream_clear (GstQTDemux * qtdemux, QtDemuxStream * stream)
 {
   if (stream->allocator)
@@ -2134,25 +2261,34 @@ gst_qtdemux_stream_clear (GstQTDemux * qtdemux, QtDemuxStream * stream)
     gst_memory_unref (stream->rgb8_palette);
     stream->rgb8_palette = NULL;
   }
-  g_free (stream->samples);
-  stream->samples = NULL;
-  g_free (stream->segments);
-  stream->segments = NULL;
+
   if (stream->pending_tags)
     gst_tag_list_unref (stream->pending_tags);
   stream->pending_tags = NULL;
   g_free (stream->redirect_uri);
   stream->redirect_uri = NULL;
-  /* free stbl sub-atoms */
-  gst_qtdemux_stbl_free (stream);
-
   stream->sent_eos = FALSE;
-  stream->segment_index = -1;
-  stream->time_position = 0;
-  stream->sample_index = -1;
-  stream->stbl_index = -1;
-  stream->n_samples = 0;
   stream->sparse = FALSE;
+  stream->protected = FALSE;
+  if (stream->protection_scheme_info) {
+    if (stream->protection_scheme_type == FOURCC_cenc) {
+      QtDemuxCencSampleSetInfo *info =
+          (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+      if (info->default_properties)
+        gst_structure_free (info->default_properties);
+      if (info->crypto_info)
+        g_ptr_array_free (info->crypto_info, TRUE);
+    }
+    g_free (stream->protection_scheme_info);
+    stream->protection_scheme_info = NULL;
+  }
+  stream->protection_scheme_type = 0;
+  stream->protection_scheme_version = 0;
+  g_queue_foreach (&stream->protection_scheme_event_queue,
+      (GFunc) gst_event_unref, NULL);
+  g_queue_clear (&stream->protection_scheme_event_queue);
+  gst_qtdemux_stream_flush_segments_data (qtdemux, stream);
+  gst_qtdemux_stream_flush_samples_data (qtdemux, stream);
 }
 
 static void
@@ -2226,32 +2362,35 @@ qtdemux_parse_ftyp (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 }
 
 static void
-qtdemux_handle_xmp_taglist (GstQTDemux * qtdemux, GstTagList * taglist)
+qtdemux_handle_xmp_taglist (GstQTDemux * qtdemux, GstTagList * taglist,
+    GstTagList * xmptaglist)
 {
   /* Strip out bogus fields */
-  if (taglist) {
-    gst_tag_list_remove_tag (taglist, GST_TAG_VIDEO_CODEC);
+  if (xmptaglist) {
+    if (gst_tag_list_get_scope (taglist) == GST_TAG_SCOPE_GLOBAL) {
+      gst_tag_list_remove_tag (xmptaglist, GST_TAG_VIDEO_CODEC);
+      gst_tag_list_remove_tag (xmptaglist, GST_TAG_AUDIO_CODEC);
+    } else {
+      gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
+    }
 
-    GST_DEBUG_OBJECT (qtdemux, "Found XMP tags %" GST_PTR_FORMAT, taglist);
+    GST_DEBUG_OBJECT (qtdemux, "Found XMP tags %" GST_PTR_FORMAT, xmptaglist);
 
-    if (qtdemux->tag_list) {
-      /* prioritize native tags using _KEEP mode */
-      gst_tag_list_insert (qtdemux->tag_list, taglist, GST_TAG_MERGE_KEEP);
-      gst_tag_list_unref (taglist);
-    } else
-      qtdemux->tag_list = taglist;
+    /* prioritize native tags using _KEEP mode */
+    gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
+    gst_tag_list_unref (xmptaglist);
   }
 }
 
 static void
 qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 {
-  static guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
+  static const guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
     0x97, 0xA9, 0x42, 0xE8,
     0x9C, 0x71, 0x99, 0x94,
     0x91, 0xE3, 0xAF, 0xAC
   };
-  static guint8 playready_uuid[] = {
+  static const guint8 playready_uuid[] = {
     0xd0, 0x8a, 0x4f, 0x18, 0x10, 0xf3, 0x4a, 0x82,
     0xb6, 0xc8, 0x32, 0xd8, 0xab, 0xa1, 0x83, 0xd3
   };
@@ -2276,7 +2415,7 @@ qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
     taglist = gst_tag_list_from_xmp_buffer (buf);
     gst_buffer_unref (buf);
 
-    qtdemux_handle_xmp_taglist (qtdemux, taglist);
+    qtdemux_handle_xmp_taglist (qtdemux, qtdemux->tag_list, taglist);
 
   } else if (memcmp (buffer + offset, playready_uuid, 16) == 0) {
     int len;
@@ -2302,6 +2441,25 @@ qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
   }
 }
 
+static void
+qtdemux_parse_sidx (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
+{
+  GstSidxParser sidx_parser;
+  GstIsoffParserResult res;
+  guint consumed;
+
+  gst_isoff_qt_sidx_parser_init (&sidx_parser);
+
+  res =
+      gst_isoff_qt_sidx_parser_add_data (&sidx_parser, buffer, length,
+      &consumed);
+  GST_DEBUG_OBJECT (qtdemux, "sidx parse result: %d", res);
+  if (res == GST_ISOFF_QT_PARSER_DONE) {
+    check_update_duration (qtdemux, sidx_parser.cumulative_pts);
+  }
+  gst_isoff_qt_sidx_parser_clear (&sidx_parser);
+}
+
 /* caller verifies at least 8 bytes in buf */
 static void
 extract_initial_length_and_fourcc (const guint8 * data, guint size,
@@ -2316,7 +2474,7 @@ extract_initial_length_and_fourcc (const guint8 * data, guint size,
   GST_DEBUG ("atom type %" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
 
   if (length == 0) {
-    length = G_MAXUINT32;
+    length = G_MAXUINT64;
   } else if (length == 1 && size >= 16) {
     /* this means we have an extended size, which is the 64 bit value of
      * the next 8 bytes */
@@ -2334,7 +2492,7 @@ static gboolean
 qtdemux_parse_mehd (GstQTDemux * qtdemux, GstByteReader * br)
 {
   guint32 version = 0;
-  guint64 duration = 0;
+  GstClockTime duration = 0;
 
   if (!gst_byte_reader_get_uint32_be (br, &version))
     goto failed;
@@ -2426,12 +2584,66 @@ qtdemux_parse_trex (GstQTDemux * qtdemux, QtDemuxStream * stream,
   return TRUE;
 }
 
+/* This method should be called whenever a more accurate duration might
+ * have been found. It will update all relevant variables if/where needed
+ */
+static void
+check_update_duration (GstQTDemux * qtdemux, GstClockTime duration)
+{
+  guint i;
+  guint64 movdur;
+  GstClockTime prevdur;
+
+  movdur = GSTTIME_TO_QTTIME (qtdemux, duration);
+
+  if (movdur > qtdemux->duration) {
+    prevdur = QTTIME_TO_GSTTIME (qtdemux, qtdemux->duration);
+    GST_DEBUG_OBJECT (qtdemux,
+        "Updating total duration to %" GST_TIME_FORMAT " was %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (duration), GST_TIME_ARGS (prevdur));
+    qtdemux->duration = movdur;
+    GST_DEBUG_OBJECT (qtdemux,
+        "qtdemux->segment.duration: %" GST_TIME_FORMAT " .stop: %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (qtdemux->segment.duration),
+        GST_TIME_ARGS (qtdemux->segment.stop));
+    if (qtdemux->segment.duration == prevdur) {
+      /* If the current segment has duration/stop identical to previous duration
+       * update them also (because they were set at that point in time with
+       * the wrong duration */
+      /* We convert the value *from* the timescale version to avoid rounding errors */
+      GstClockTime fixeddur = QTTIME_TO_GSTTIME (qtdemux, movdur);
+      GST_DEBUG_OBJECT (qtdemux, "Updated segment.duration and segment.stop");
+      qtdemux->segment.duration = fixeddur;
+      qtdemux->segment.stop = fixeddur;
+    }
+  }
+  for (i = 0; i < qtdemux->n_streams; i++) {
+    QtDemuxStream *stream = qtdemux->streams[i];
+    if (stream) {
+      movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);
+      if (movdur > stream->duration) {
+        GST_DEBUG_OBJECT (qtdemux,
+            "Updating stream #%d duration to %" GST_TIME_FORMAT, i,
+            GST_TIME_ARGS (duration));
+        stream->duration = movdur;
+        if (stream->dummy_segment) {
+          /* Update all dummy values to new duration */
+          stream->segments[0].stop_time = duration;
+          stream->segments[0].duration = duration;
+          stream->segments[0].media_stop = duration;
+        }
+      }
+    }
+  }
+}
+
 static gboolean
 qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
     QtDemuxStream * stream, guint32 d_sample_duration, guint32 d_sample_size,
     guint32 d_sample_flags, gint64 moof_offset, gint64 moof_length,
-    gint64 * base_offset, gint64 * running_offset)
+    gint64 * base_offset, gint64 * running_offset, gint64 decode_ts)
 {
+  GstClockTime gst_ts = GST_CLOCK_TIME_NONE;
   guint64 timestamp;
   gint32 data_offset = 0;
   guint32 flags = 0, first_flags = 0, samples_count = 0;
@@ -2442,9 +2654,14 @@ qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
   gboolean ismv = FALSE;
 
   GST_LOG_OBJECT (qtdemux, "parsing trun stream %d; "
-      "default dur %d, size %d, flags 0x%x, base offset %" G_GINT64_FORMAT,
-      stream->track_id, d_sample_duration, d_sample_size, d_sample_flags,
-      *base_offset);
+      "default dur %d, size %d, flags 0x%x, base offset %" G_GINT64_FORMAT ", "
+      "decode ts %" G_GINT64_FORMAT, stream->track_id, d_sample_duration,
+      d_sample_size, d_sample_flags, *base_offset, decode_ts);
+
+  if (stream->pending_seek && moof_offset < stream->pending_seek->moof_offset) {
+    GST_INFO_OBJECT (stream->pad, "skipping trun before seek target fragment");
+    return TRUE;
+  }
 
   /* presence of stss or not can't really tell us much,
    * and flags and so on tend to be marginally reliable in these files */
@@ -2531,40 +2748,62 @@ qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
     goto fail;
   data = (guint8 *) gst_byte_reader_peek_data_unchecked (trun);
 
-  if (stream->n_samples >=
+  if (stream->n_samples + samples_count >=
       QTDEMUX_MAX_SAMPLE_INDEX_SIZE / sizeof (QtDemuxSample))
     goto index_too_big;
 
   GST_DEBUG_OBJECT (qtdemux, "allocating n_samples %u * %u (%.2f MB)",
-      stream->n_samples, (guint) sizeof (QtDemuxSample),
-      stream->n_samples * sizeof (QtDemuxSample) / (1024.0 * 1024.0));
+      stream->n_samples + samples_count, (guint) sizeof (QtDemuxSample),
+      (stream->n_samples + samples_count) *
+      sizeof (QtDemuxSample) / (1024.0 * 1024.0));
 
   /* create a new array of samples if it's the first sample parsed */
-  if (stream->n_samples == 0)
+  if (stream->n_samples == 0) {
+    g_assert (stream->samples == NULL);
     stream->samples = g_try_new0 (QtDemuxSample, samples_count);
-  /* or try to reallocate it with space enough to insert the new samples */
-  else
+    /* or try to reallocate it with space enough to insert the new samples */
+  } else
     stream->samples = g_try_renew (QtDemuxSample, stream->samples,
         stream->n_samples + samples_count);
   if (stream->samples == NULL)
     goto out_of_memory;
 
   if (qtdemux->fragment_start != -1) {
-    timestamp = gst_util_uint64_scale_int (qtdemux->fragment_start,
-        stream->timescale, GST_SECOND);
+    timestamp = GSTTIME_TO_QTSTREAMTIME (stream, qtdemux->fragment_start);
     qtdemux->fragment_start = -1;
   } else {
-    if (G_UNLIKELY (stream->n_samples == 0)) {
-      /* the timestamp of the first sample is also provided by the tfra entry
-       * but we shouldn't rely on it as it is at the end of files */
-      timestamp = 0;
+    if (stream->n_samples == 0) {
+      if (decode_ts > 0) {
+        timestamp = decode_ts;
+      } else if (stream->pending_seek != NULL) {
+        /* if we don't have a timestamp from a tfdt box, we'll use the one
+         * from the mfra seek table */
+        GST_INFO_OBJECT (stream->pad, "pending seek ts = %" GST_TIME_FORMAT,
+            GST_TIME_ARGS (stream->pending_seek->ts));
+
+        /* FIXME: this is not fully correct, the timestamp refers to the random
+         * access sample refered to in the tfra entry, which may not necessarily
+         * be the first sample in the tfrag/trun (but hopefully/usually is) */
+        timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream->pending_seek->ts);
+      } else {
+        timestamp = 0;
+      }
+
+      gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
+      GST_INFO_OBJECT (stream->pad, "first sample ts %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (gst_ts));
     } else {
       /* subsequent fragments extend stream */
       timestamp =
           stream->samples[stream->n_samples - 1].timestamp +
           stream->samples[stream->n_samples - 1].duration;
+
+      gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
+      GST_INFO_OBJECT (qtdemux, "first sample ts %" GST_TIME_FORMAT
+          " (extends previous samples)", GST_TIME_ARGS (gst_ts));
     }
   }
+
   sample = stream->samples + stream->n_samples;
   for (i = 0; i < samples_count; i++) {
     guint32 dur, size, sflags, ct;
@@ -2613,8 +2852,14 @@ qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
     sample++;
   }
 
+  /* Update total duration if needed */
+  check_update_duration (qtdemux, QTSTREAMTIME_TO_GSTTIME (stream, timestamp));
+
   stream->n_samples += samples_count;
 
+  if (stream->pending_seek != NULL)
+    stream->pending_seek = NULL;
+
   return TRUE;
 
 fail:
@@ -2672,6 +2917,22 @@ qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id)
 }
 
 static gboolean
+qtdemux_parse_mfhd (GstQTDemux * qtdemux, GstByteReader * mfhd,
+    guint32 * fragment_number)
+{
+  if (!gst_byte_reader_skip (mfhd, 4))
+    goto fail;
+  if (!gst_byte_reader_get_uint32_be (mfhd, fragment_number))
+    goto fail;
+  return TRUE;
+fail:
+  {
+    GST_WARNING_OBJECT (qtdemux, "Failed to parse mfhd atom");
+    return FALSE;
+  }
+}
+
+static gboolean
 qtdemux_parse_tfhd (GstQTDemux * qtdemux, GstByteReader * tfhd,
     QtDemuxStream ** stream, guint32 * default_sample_duration,
     guint32 * default_sample_size, guint32 * default_sample_flags,
@@ -2691,6 +2952,9 @@ qtdemux_parse_tfhd (GstQTDemux * qtdemux, GstByteReader * tfhd,
   if (G_UNLIKELY (!*stream))
     goto unknown_stream;
 
+  if (flags & TF_DEFAULT_BASE_IS_MOOF)
+    *base_offset = qtdemux->moof_offset;
+
   if (flags & TF_BASE_DATA_OFFSET)
     if (!gst_byte_reader_get_uint64_be (tfhd, (guint64 *) base_offset))
       goto invalid_track;
@@ -2762,14 +3026,303 @@ failed:
   }
 }
 
+/* Returns a pointer to a GstStructure containing the properties of
+ * the stream sample identified by @sample_index. The caller must unref
+ * the returned object after use. Returns NULL if unsuccessful. */
+static GstStructure *
+qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
+    QtDemuxStream * stream, guint sample_index)
+{
+  QtDemuxCencSampleSetInfo *info = NULL;
+
+  g_return_val_if_fail (stream != NULL, NULL);
+  g_return_val_if_fail (stream->protected, NULL);
+  g_return_val_if_fail (stream->protection_scheme_info != NULL, NULL);
+
+  info = (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+
+  /* Currently, cenc properties for groups of samples are not supported, so
+   * simply return a copy of the default sample properties */
+  return gst_structure_copy (info->default_properties);
+}
+
+/* Parses the sizes of sample auxiliary information contained within a stream,
+ * as given in a saiz box. Returns array of sample_count guint8 size values,
+ * or NULL on failure */
+static guint8 *
+qtdemux_parse_saiz (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GstByteReader * br, guint32 * sample_count)
+{
+  guint32 flags = 0;
+  guint8 *info_sizes;
+  guint8 default_info_size;
+
+  g_return_val_if_fail (qtdemux != NULL, NULL);
+  g_return_val_if_fail (stream != NULL, NULL);
+  g_return_val_if_fail (br != NULL, NULL);
+  g_return_val_if_fail (sample_count != NULL, NULL);
+
+  if (!gst_byte_reader_get_uint32_be (br, &flags))
+    return NULL;
+
+  if (flags & 0x1) {
+    /* aux_info_type and aux_info_type_parameter are ignored */
+    if (!gst_byte_reader_skip (br, 8))
+      return NULL;
+  }
+
+  if (!gst_byte_reader_get_uint8 (br, &default_info_size))
+    return NULL;
+  GST_DEBUG_OBJECT (qtdemux, "default_info_size: %u", default_info_size);
+
+  if (!gst_byte_reader_get_uint32_be (br, sample_count))
+    return NULL;
+  GST_DEBUG_OBJECT (qtdemux, "sample_count: %u", *sample_count);
+
+
+  if (default_info_size == 0) {
+    if (!gst_byte_reader_dup_data (br, *sample_count, &info_sizes)) {
+      return NULL;
+    }
+  } else {
+    info_sizes = g_new (guint8, *sample_count);
+    memset (info_sizes, default_info_size, *sample_count);
+  }
+
+  return info_sizes;
+}
+
+/* Parses the offset of sample auxiliary information contained within a stream,
+ * as given in a saio box. Returns TRUE if successful; FALSE otherwise. */
+static gboolean
+qtdemux_parse_saio (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GstByteReader * br, guint32 * info_type, guint32 * info_type_parameter,
+    guint64 * offset)
+{
+  guint8 version = 0;
+  guint32 flags = 0;
+  guint32 aux_info_type = 0;
+  guint32 aux_info_type_parameter = 0;
+  guint32 entry_count;
+  guint32 off_32;
+  guint64 off_64;
+
+  g_return_val_if_fail (qtdemux != NULL, FALSE);
+  g_return_val_if_fail (stream != NULL, FALSE);
+  g_return_val_if_fail (br != NULL, FALSE);
+  g_return_val_if_fail (offset != NULL, FALSE);
+
+  if (!gst_byte_reader_get_uint8 (br, &version))
+    return FALSE;
+
+  if (!gst_byte_reader_get_uint24_be (br, &flags))
+    return FALSE;
+
+  if (flags & 0x1) {
+    if (!gst_byte_reader_get_uint32_be (br, &aux_info_type))
+      return FALSE;
+    if (!gst_byte_reader_get_uint32_be (br, &aux_info_type_parameter))
+      return FALSE;
+  } else if (stream->protected) {
+    aux_info_type = stream->protection_scheme_type;
+  } else {
+    aux_info_type = stream->fourcc;
+  }
+
+  if (info_type)
+    *info_type = aux_info_type;
+  if (info_type_parameter)
+    *info_type_parameter = aux_info_type_parameter;
+
+  GST_DEBUG_OBJECT (qtdemux, "aux_info_type: '%" GST_FOURCC_FORMAT "', "
+      "aux_info_type_parameter:  %#06x",
+      GST_FOURCC_ARGS (aux_info_type), aux_info_type_parameter);
+
+  if (!gst_byte_reader_get_uint32_be (br, &entry_count))
+    return FALSE;
+
+  if (entry_count != 1) {
+    GST_ERROR_OBJECT (qtdemux, "multiple offsets are not supported");
+    return FALSE;
+  }
+
+  if (version == 0) {
+    if (!gst_byte_reader_get_uint32_be (br, &off_32))
+      return FALSE;
+    *offset = (guint64) off_32;
+  } else {
+    if (!gst_byte_reader_get_uint64_be (br, &off_64))
+      return FALSE;
+    *offset = off_64;
+  }
+
+  GST_DEBUG_OBJECT (qtdemux, "offset: %" G_GUINT64_FORMAT, *offset);
+  return TRUE;
+}
+
+static void
+qtdemux_gst_structure_free (GstStructure * gststructure)
+{
+  if (gststructure) {
+    gst_structure_free (gststructure);
+  }
+}
+
+/* Parses auxiliary information relating to samples protected using Common
+ * Encryption (cenc); the format of this information is defined in
+ * ISO/IEC 23001-7. Returns TRUE if successful; FALSE otherwise. */
+static gboolean
+qtdemux_parse_cenc_aux_info (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GstByteReader * br, guint8 * info_sizes, guint32 sample_count)
+{
+  QtDemuxCencSampleSetInfo *ss_info = NULL;
+  guint8 size;
+  gint i;
+
+  g_return_val_if_fail (qtdemux != NULL, FALSE);
+  g_return_val_if_fail (stream != NULL, FALSE);
+  g_return_val_if_fail (br != NULL, FALSE);
+  g_return_val_if_fail (stream->protected, FALSE);
+  g_return_val_if_fail (stream->protection_scheme_info != NULL, FALSE);
+
+  ss_info = (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+
+  if (ss_info->crypto_info) {
+    GST_LOG_OBJECT (qtdemux, "unreffing existing crypto_info");
+    g_ptr_array_free (ss_info->crypto_info, TRUE);
+  }
+
+  ss_info->crypto_info =
+      g_ptr_array_new_full (sample_count,
+      (GDestroyNotify) qtdemux_gst_structure_free);
+
+  for (i = 0; i < sample_count; ++i) {
+    GstStructure *properties;
+    guint16 n_subsamples;
+    guint8 *data;
+    guint iv_size;
+    GstBuffer *buf;
+
+    properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
+    if (properties == NULL) {
+      GST_ERROR_OBJECT (qtdemux, "failed to get properties for sample %u", i);
+      return FALSE;
+    }
+    if (!gst_structure_get_uint (properties, "iv_size", &iv_size)) {
+      GST_ERROR_OBJECT (qtdemux, "failed to get iv_size for sample %u", i);
+      gst_structure_free (properties);
+      return FALSE;
+    }
+    if (!gst_byte_reader_dup_data (br, iv_size, &data)) {
+      GST_ERROR_OBJECT (qtdemux, "failed to get IV for sample %u", i);
+      gst_structure_free (properties);
+      return FALSE;
+    }
+    buf = gst_buffer_new_wrapped (data, iv_size);
+    gst_structure_set (properties, "iv", GST_TYPE_BUFFER, buf, NULL);
+    size = info_sizes[i];
+    if (size > iv_size) {
+      if (!gst_byte_reader_get_uint16_be (br, &n_subsamples)
+          || !(n_subsamples > 0)) {
+        gst_structure_free (properties);
+        GST_ERROR_OBJECT (qtdemux,
+            "failed to get subsample count for sample %u", i);
+        return FALSE;
+      }
+      GST_LOG_OBJECT (qtdemux, "subsample count: %u", n_subsamples);
+      if (!gst_byte_reader_dup_data (br, n_subsamples * 6, &data)) {
+        GST_ERROR_OBJECT (qtdemux, "failed to get subsample data for sample %u",
+            i);
+        gst_structure_free (properties);
+        return FALSE;
+      }
+      buf = gst_buffer_new_wrapped (data, n_subsamples * 6);
+      if (!buf) {
+        gst_structure_free (properties);
+        return FALSE;
+      }
+      gst_structure_set (properties,
+          "subsample_count", G_TYPE_UINT, n_subsamples,
+          "subsamples", GST_TYPE_BUFFER, buf, NULL);
+    } else {
+      gst_structure_set (properties, "subsample_count", G_TYPE_UINT, 0, NULL);
+    }
+    g_ptr_array_add (ss_info->crypto_info, properties);
+  }
+  return TRUE;
+}
+
+/* Converts a UUID in raw byte form to a string representation, as defined in
+ * RFC 4122. The caller takes ownership of the returned string and is
+ * responsible for freeing it after use. */
+static gchar *
+qtdemux_uuid_bytes_to_string (gconstpointer uuid_bytes)
+{
+  const guint8 *uuid = (const guint8 *) uuid_bytes;
+
+  return g_strdup_printf ("%02x%02x%02x%02x-%02x%02x-%02x%02x-"
+      "%02x%02x-%02x%02x%02x%02x%02x%02x",
+      uuid[0], uuid[1], uuid[2], uuid[3],
+      uuid[4], uuid[5], uuid[6], uuid[7],
+      uuid[8], uuid[9], uuid[10], uuid[11],
+      uuid[12], uuid[13], uuid[14], uuid[15]);
+}
+
+/* Parses a Protection System Specific Header box (pssh), as defined in the
+ * Common Encryption (cenc) standard (ISO/IEC 23001-7), which contains
+ * information needed by a specific content protection system in order to
+ * decrypt cenc-protected tracks. Returns TRUE if successful; FALSE
+ * otherwise. */
+static gboolean
+qtdemux_parse_pssh (GstQTDemux * qtdemux, GNode * node)
+{
+  gchar *sysid_string;
+  guint32 pssh_size = QT_UINT32 (node->data);
+  GstBuffer *pssh = NULL;
+  GstEvent *event = NULL;
+  guint32 parent_box_type;
+  gint i;
+
+  if (G_UNLIKELY (pssh_size < 32U)) {
+    GST_ERROR_OBJECT (qtdemux, "invalid box size");
+    return FALSE;
+  }
+
+  sysid_string =
+      qtdemux_uuid_bytes_to_string ((const guint8 *) node->data + 12);
+
+  gst_qtdemux_append_protection_system_id (qtdemux, sysid_string);
+
+  pssh = gst_buffer_new_wrapped (g_memdup (node->data, pssh_size), pssh_size);
+  GST_LOG_OBJECT (qtdemux, "cenc pssh size: %" G_GSIZE_FORMAT,
+      gst_buffer_get_size (pssh));
+
+  parent_box_type = QT_FOURCC ((const guint8 *) node->parent->data + 4);
+
+  /* Push an event containing the pssh box onto the queues of all streams. */
+  event = gst_event_new_protection (sysid_string, pssh,
+      (parent_box_type == FOURCC_moov) ? "isobmff/moov" : "isobmff/moof");
+  for (i = 0; i < qtdemux->n_streams; ++i) {
+    g_queue_push_tail (&qtdemux->streams[i]->protection_scheme_event_queue,
+        gst_event_ref (event));
+  }
+  g_free (sysid_string);
+  gst_event_unref (event);
+  gst_buffer_unref (pssh);
+  return TRUE;
+}
+
 static gboolean
 qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     guint64 moof_offset, QtDemuxStream * stream)
 {
-  GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node;
-  GstByteReader trun_data, tfhd_data, tfdt_data;
+  GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node, *mfhd_node;
+  GstByteReader mfhd_data, trun_data, tfhd_data, tfdt_data;
+  GNode *saiz_node, *saio_node, *pssh_node;
+  GstByteReader saiz_data, saio_data;
   guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
   gint64 base_offset, running_offset;
+  guint32 frag_num;
 
   /* NOTE @stream ignored */
 
@@ -2777,10 +3330,21 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
   qtdemux_parse_node (qtdemux, moof_node, buffer, length);
   qtdemux_node_dump (qtdemux, moof_node);
 
+  /* Get fragment number from mfhd and check it's valid */
+  mfhd_node =
+      qtdemux_tree_get_child_by_type_full (moof_node, FOURCC_mfhd, &mfhd_data);
+  if (mfhd_node == NULL)
+    goto missing_mfhd;
+  if (!qtdemux_parse_mfhd (qtdemux, &mfhd_data, &frag_num))
+    goto fail;
+  GST_DEBUG_OBJECT (qtdemux, "Fragment #%d", frag_num);
+
   /* unknown base_offset to start with */
   base_offset = running_offset = -1;
   traf_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_traf);
   while (traf_node) {
+    guint64 decode_time = 0;
+
     /* Fragment Header node */
     tfhd_node =
         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfhd,
@@ -2790,23 +3354,82 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     if (!qtdemux_parse_tfhd (qtdemux, &tfhd_data, &stream, &ds_duration,
             &ds_size, &ds_flags, &base_offset))
       goto missing_tfhd;
+
+    /* The following code assumes at most a single set of sample auxiliary
+     * data in the fragment (consisting of a saiz box and a corresponding saio
+     * box); in theory, however, there could be multiple sets of sample
+     * auxiliary data in a fragment. */
+    saiz_node =
+        qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_saiz,
+        &saiz_data);
+    if (saiz_node) {
+      guint8 *info_sizes;
+      guint32 sample_count;
+      guint32 info_type = 0;
+      guint64 offset = 0;
+      guint32 info_type_parameter = 0;
+
+      info_sizes = qtdemux_parse_saiz (qtdemux, stream, &saiz_data,
+          &sample_count);
+      if (G_UNLIKELY (info_sizes == NULL)) {
+        GST_ERROR_OBJECT (qtdemux, "failed to parse saiz box");
+        goto fail;
+      }
+      saio_node =
+          qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_saio,
+          &saio_data);
+      if (!saio_node) {
+        GST_ERROR_OBJECT (qtdemux, "saiz box without a corresponding saio box");
+        goto fail;
+      }
+
+      if (G_UNLIKELY (!qtdemux_parse_saio (qtdemux, stream, &saio_data,
+                  &info_type, &info_type_parameter, &offset))) {
+        GST_ERROR_OBJECT (qtdemux, "failed to parse saio box");
+        g_free (info_sizes);
+        goto fail;
+      }
+      if (base_offset > qtdemux->moof_offset)
+        offset += (guint64) (base_offset - qtdemux->moof_offset);
+      if (info_type == FOURCC_cenc && info_type_parameter == 0U) {
+        GstByteReader br;
+        if (offset > length) {
+          GST_ERROR_OBJECT (qtdemux, "cenc auxiliary info outside moof "
+              "boxes is not supported");
+          g_free (info_sizes);
+          goto fail;
+        }
+        gst_byte_reader_init (&br, buffer + offset, length - offset);
+        if (!qtdemux_parse_cenc_aux_info (qtdemux, stream, &br,
+                info_sizes, sample_count)) {
+          GST_ERROR_OBJECT (qtdemux, "failed to parse cenc auxiliary info");
+          goto fail;
+        }
+      }
+      g_free (info_sizes);
+    }
+
     tfdt_node =
         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfdt,
         &tfdt_data);
     if (tfdt_node) {
-      guint64 decode_time = 0;
       GstClockTime decode_time_ts;
 
+      /* We'll use decode_time to interpolate timestamps
+       * in case the input timestamps are missing */
       qtdemux_parse_tfdt (qtdemux, &tfdt_data, &decode_time);
 
-      /* FIXME, we can use decode_time to interpolate timestamps
-       * in case the input timestamps are missing */
-      decode_time_ts = gst_util_uint64_scale (decode_time, GST_SECOND,
-          stream->timescale);
+      decode_time_ts = QTSTREAMTIME_TO_GSTTIME (stream, decode_time);
 
-      GST_DEBUG_OBJECT (qtdemux, "decode time %" G_GUINT64_FORMAT
+      GST_DEBUG_OBJECT (qtdemux, "decode time %" G_GINT64_FORMAT
           " (%" GST_TIME_FORMAT ")", decode_time,
           GST_TIME_ARGS (decode_time_ts));
+
+      /* Discard the fragment buffer timestamp info to avoid using it.
+       * Rely on tfdt instead as it is more accurate than the timestamp
+       * that is fetched from a manifest/playlist and is usually
+       * less accurate. */
+      qtdemux->fragment_start = -1;
     }
 
     if (G_UNLIKELY (!stream)) {
@@ -2817,6 +3440,10 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     }
     if (G_UNLIKELY (base_offset < -1))
       goto lost_offset;
+
+    if (qtdemux->upstream_format_is_time)
+      gst_qtdemux_stream_flush_samples_data (qtdemux, stream);
+
     /* Track Run node */
     trun_node =
         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_trun,
@@ -2824,7 +3451,7 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     while (trun_node) {
       qtdemux_parse_trun (qtdemux, &trun_data, stream,
           ds_duration, ds_size, ds_flags, moof_offset, length, &base_offset,
-          &running_offset);
+          &running_offset, decode_time);
       /* iterate all siblings */
       trun_node = qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,
           &trun_data);
@@ -2837,6 +3464,15 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
     /* iterate all siblings */
     traf_node = qtdemux_tree_get_sibling_by_type (traf_node, FOURCC_traf);
   }
+
+  /* parse any protection system info */
+  pssh_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_pssh);
+  while (pssh_node) {
+    GST_LOG_OBJECT (qtdemux, "Parsing pssh box.");
+    qtdemux_parse_pssh (qtdemux, pssh_node);
+    pssh_node = qtdemux_tree_get_sibling_by_type (pssh_node, FOURCC_pssh);
+  }
+
   g_node_destroy (moof_node);
   return TRUE;
 
@@ -2845,6 +3481,11 @@ missing_tfhd:
     GST_DEBUG_OBJECT (qtdemux, "missing tfhd box");
     goto fail;
   }
+missing_mfhd:
+  {
+    GST_DEBUG_OBJECT (qtdemux, "Missing mfhd box");
+    goto fail;
+  }
 lost_offset:
   {
     GST_DEBUG_OBJECT (qtdemux, "lost offset");
@@ -2859,44 +3500,53 @@ fail:
   }
 }
 
+#if 0
 /* might be used if some day we actually use mfra & co
  * for random access to fragments,
  * but that will require quite some modifications and much less relying
  * on a sample array */
-#if 0
+#endif
+
 static gboolean
-qtdemux_parse_tfra (GstQTDemux * qtdemux, GNode * tfra_node,
-    QtDemuxStream * stream)
+qtdemux_parse_tfra (GstQTDemux * qtdemux, GNode * tfra_node)
 {
-  guint64 time = 0, moof_offset = 0;
+  QtDemuxStream *stream;
   guint32 ver_flags, track_id, len, num_entries, i;
   guint value_size, traf_size, trun_size, sample_size;
+  guint64 time = 0, moof_offset = 0;
+#if 0
   GstBuffer *buf = NULL;
   GstFlowReturn ret;
+#endif
   GstByteReader tfra;
 
-  gst_byte_reader_init (&tfra, (guint8 *) tfra_node->data + (4 + 4),
-      QT_UINT32 ((guint8 *) tfra_node->data) - (4 + 4));
+  gst_byte_reader_init (&tfra, tfra_node->data, QT_UINT32 (tfra_node->data));
 
-  if (!gst_byte_reader_get_uint32_be (&tfra, &ver_flags))
+  if (!gst_byte_reader_skip (&tfra, 8))
     return FALSE;
 
-  if (!(gst_byte_reader_get_uint32_be (&tfra, &track_id) &&
-          gst_byte_reader_get_uint32_be (&tfra, &len) &&
-          gst_byte_reader_get_uint32_be (&tfra, &num_entries)))
+  if (!gst_byte_reader_get_uint32_be (&tfra, &ver_flags))
     return FALSE;
 
-  GST_LOG_OBJECT (qtdemux, "id %d == stream id %d ?",
-      track_id, stream->track_id);
-  if (track_id != stream->track_id) {
+  if (!gst_byte_reader_get_uint32_be (&tfra, &track_id)
+      || !gst_byte_reader_get_uint32_be (&tfra, &len)
+      || !gst_byte_reader_get_uint32_be (&tfra, &num_entries))
     return FALSE;
-  }
+
+  GST_DEBUG_OBJECT (qtdemux, "parsing tfra box for track id %u", track_id);
+
+  stream = qtdemux_find_stream (qtdemux, track_id);
+  if (stream == NULL)
+    goto unknown_trackid;
 
   value_size = ((ver_flags >> 24) == 1) ? sizeof (guint64) : sizeof (guint32);
   sample_size = (len & 3) + 1;
   trun_size = ((len & 12) >> 2) + 1;
   traf_size = ((len & 48) >> 4) + 1;
 
+  GST_DEBUG_OBJECT (qtdemux, "%u entries, sizes: value %u, traf %u, trun %u, "
+      "sample %u", num_entries, value_size, traf_size, trun_size, sample_size);
+
   if (num_entries == 0)
     goto no_samples;
 
@@ -2904,6 +3554,10 @@ qtdemux_parse_tfra (GstQTDemux * qtdemux, GNode * tfra_node,
           value_size + value_size + traf_size + trun_size + sample_size))
     goto corrupt_file;
 
+  g_free (stream->ra_entries);
+  stream->ra_entries = g_new (QtDemuxRandomAccessEntry, num_entries);
+  stream->n_ra_entries = num_entries;
+
   for (i = 0; i < num_entries; i++) {
     qt_atom_parser_get_offset (&tfra, value_size, &time);
     qt_atom_parser_get_offset (&tfra, value_size, &moof_offset);
@@ -2911,26 +3565,38 @@ qtdemux_parse_tfra (GstQTDemux * qtdemux, GNode * tfra_node,
     qt_atom_parser_get_uint_with_size_unchecked (&tfra, trun_size);
     qt_atom_parser_get_uint_with_size_unchecked (&tfra, sample_size);
 
-    GST_LOG_OBJECT (qtdemux,
-        "fragment time: %" GST_TIME_FORMAT " moof_offset: %u",
-        GST_TIME_ARGS (gst_util_uint64_scale (time, GST_SECOND,
-                stream->timescale)), moof_offset);
+    time = QTSTREAMTIME_TO_GSTTIME (stream, time);
+
+    GST_LOG_OBJECT (qtdemux, "fragment time: %" GST_TIME_FORMAT ", "
+        " moof_offset: %" G_GUINT64_FORMAT, GST_TIME_ARGS (time), moof_offset);
 
+    stream->ra_entries[i].ts = time;
+    stream->ra_entries[i].moof_offset = moof_offset;
+
+    /* don't want to go through the entire file and read all moofs at startup */
+#if 0
     ret = gst_qtdemux_pull_atom (qtdemux, moof_offset, 0, &buf);
     if (ret != GST_FLOW_OK)
       goto corrupt_file;
     qtdemux_parse_moof (qtdemux, GST_BUFFER_DATA (buf), GST_BUFFER_SIZE (buf),
         moof_offset, stream);
     gst_buffer_unref (buf);
+#endif
   }
 
+  check_update_duration (qtdemux, time);
+
   return TRUE;
 
 /* ERRORS */
+unknown_trackid:
+  {
+    GST_WARNING_OBJECT (qtdemux, "Couldn't find stream for track %u", track_id);
+    return FALSE;
+  }
 corrupt_file:
   {
-    GST_ELEMENT_ERROR (qtdemux, STREAM, DECODE,
-        (_("This file is corrupt and cannot be played.")), (NULL));
+    GST_WARNING_OBJECT (qtdemux, "broken traf box, ignoring");
     return FALSE;
   }
 no_samples:
@@ -2941,106 +3607,113 @@ no_samples:
 }
 
 static gboolean
-qtdemux_parse_mfra (GstQTDemux * qtdemux, QtDemuxStream * stream)
+qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux)
 {
-  GstFlowReturn ret;
+  GstMapInfo mfro_map = GST_MAP_INFO_INIT;
+  GstMapInfo mfra_map = GST_MAP_INFO_INIT;
+  GstBuffer *mfro = NULL, *mfra = NULL;
+  GstFlowReturn flow;
+  gboolean ret = FALSE;
   GNode *mfra_node, *tfra_node;
-  GstBuffer *buffer;
-
-  if (!qtdemux->mfra_offset)
-    return FALSE;
-
-  ret = gst_qtdemux_pull_atom (qtdemux, qtdemux->mfra_offset, 0, &buffer);
-  if (ret != GST_FLOW_OK)
-    goto corrupt_file;
-
-  mfra_node = g_node_new ((guint8 *) GST_BUFFER_DATA (buffer));
-  qtdemux_parse_node (qtdemux, mfra_node, GST_BUFFER_DATA (buffer),
-      GST_BUFFER_SIZE (buffer));
-
-  tfra_node = qtdemux_tree_get_child_by_type (mfra_node, FOURCC_tfra);
-
-  while (tfra_node) {
-    qtdemux_parse_tfra (qtdemux, tfra_node, stream);
-    /* iterate all siblings */
-    tfra_node = qtdemux_tree_get_sibling_by_type (tfra_node, FOURCC_tfra);
-  }
-  g_node_destroy (mfra_node);
-  gst_buffer_unref (buffer);
-
-  return TRUE;
-
-corrupt_file:
-  {
-    GST_ELEMENT_ERROR (qtdemux, STREAM, DECODE,
-        (_("This file is corrupt and cannot be played.")), (NULL));
-    return FALSE;
-  }
-}
-
-static GstFlowReturn
-qtdemux_parse_mfro (GstQTDemux * qtdemux, guint64 * mfra_offset,
-    guint32 * mfro_size)
-{
-  GstFlowReturn ret = GST_FLOW_ERROR;
-  GstBuffer *mfro = NULL;
-  guint32 fourcc;
+  guint64 mfra_offset = 0;
+  guint32 fourcc, mfra_size;
   gint64 len;
-  GstFormat fmt = GST_FORMAT_BYTES;
 
-  if (!gst_pad_peer_query_duration (qtdemux->sinkpad, &fmt, &len)) {
-    GST_DEBUG_OBJECT (qtdemux, "upstream size not available; "
-        "can not locate mfro");
-    goto exit;
-  }
+  /* query upstream size in bytes */
+  if (!gst_pad_peer_query_duration (qtdemux->sinkpad, GST_FORMAT_BYTES, &len))
+    goto size_query_failed;
 
-  ret = gst_qtdemux_pull_atom (qtdemux, len - 16, 16, &mfro);
-  if (ret != GST_FLOW_OK)
+  /* mfro box should be at the very end of the file */
+  flow = gst_qtdemux_pull_atom (qtdemux, len - 16, 16, &mfro);
+  if (flow != GST_FLOW_OK)
     goto exit;
 
-  fourcc = QT_FOURCC (GST_BUFFER_DATA (mfro) + 4);
+  gst_buffer_map (mfro, &mfro_map, GST_MAP_READ);
+
+  fourcc = QT_FOURCC (mfro_map.data + 4);
   if (fourcc != FOURCC_mfro)
     goto exit;
 
-  GST_INFO_OBJECT (qtdemux, "Found mfro atom: fragmented mp4 container");
-  if (GST_BUFFER_SIZE (mfro) >= 16) {
-    GST_DEBUG_OBJECT (qtdemux, "parsing 'mfro' atom");
-    *mfro_size = QT_UINT32 (GST_BUFFER_DATA (mfro) + 12);
-    if (*mfro_size >= len) {
-      GST_WARNING_OBJECT (qtdemux, "mfro.size is invalid");
-      ret = GST_FLOW_ERROR;
-      goto exit;
-    }
-    *mfra_offset = len - *mfro_size;
+  GST_INFO_OBJECT (qtdemux, "Found mfro box");
+  if (mfro_map.size < 16)
+    goto invalid_mfro_size;
+
+  mfra_size = QT_UINT32 (mfro_map.data + 12);
+  if (mfra_size >= len)
+    goto invalid_mfra_size;
+
+  mfra_offset = len - mfra_size;
+
+  GST_INFO_OBJECT (qtdemux, "mfra offset: %" G_GUINT64_FORMAT ", size %u",
+      mfra_offset, mfra_size);
+
+  /* now get and parse mfra box */
+  flow = gst_qtdemux_pull_atom (qtdemux, mfra_offset, mfra_size, &mfra);
+  if (flow != GST_FLOW_OK)
+    goto broken_file;
+
+  gst_buffer_map (mfra, &mfra_map, GST_MAP_READ);
+
+  mfra_node = g_node_new ((guint8 *) mfra_map.data);
+  qtdemux_parse_node (qtdemux, mfra_node, mfra_map.data, mfra_map.size);
+
+  tfra_node = qtdemux_tree_get_child_by_type (mfra_node, FOURCC_tfra);
+
+  while (tfra_node) {
+    qtdemux_parse_tfra (qtdemux, tfra_node);
+    /* iterate all siblings */
+    tfra_node = qtdemux_tree_get_sibling_by_type (tfra_node, FOURCC_tfra);
   }
+  g_node_destroy (mfra_node);
+
+  GST_INFO_OBJECT (qtdemux, "parsed movie fragment random access box (mfra)");
+  ret = TRUE;
 
 exit:
-  if (mfro)
-    gst_buffer_unref (mfro);
 
+  if (mfro) {
+    if (mfro_map.memory != NULL)
+      gst_buffer_unmap (mfro, &mfro_map);
+    gst_buffer_unref (mfro);
+  }
+  if (mfra) {
+    if (mfra_map.memory != NULL)
+      gst_buffer_unmap (mfra, &mfra_map);
+    gst_buffer_unref (mfra);
+  }
   return ret;
+
+/* ERRORS */
+size_query_failed:
+  {
+    GST_WARNING_OBJECT (qtdemux, "could not query upstream size");
+    goto exit;
+  }
+invalid_mfro_size:
+  {
+    GST_WARNING_OBJECT (qtdemux, "mfro size is too small");
+    goto exit;
+  }
+invalid_mfra_size:
+  {
+    GST_WARNING_OBJECT (qtdemux, "mfra_size in mfro box is invalid");
+    goto exit;
+  }
+broken_file:
+  {
+    GST_WARNING_OBJECT (qtdemux, "bogus mfra offset or size, broken file");
+    goto exit;
+  }
 }
 
-static void
-qtdemux_parse_fragmented (GstQTDemux * qtdemux)
+static guint64
+add_offset (guint64 offset, guint64 advance)
 {
-  GstFlowReturn ret;
-  guint32 mfra_size = 0;
-  guint64 mfra_offset = 0;
-
-  /* default */
-  qtdemux->fragmented = FALSE;
-
-  /* We check here if it is a fragmented mp4 container */
-  ret = qtdemux_parse_mfro (qtdemux, &mfra_offset, &mfra_size);
-  if (ret == GST_FLOW_OK && mfra_size != 0 && mfra_offset != 0) {
-    qtdemux->fragmented = TRUE;
-    GST_DEBUG_OBJECT (qtdemux,
-        "mfra atom expected at offset %" G_GUINT64_FORMAT, mfra_offset);
-    qtdemux->mfra_offset = mfra_offset;
-  }
+  /* Avoid 64-bit overflow by clamping */
+  if (offset > G_MAXUINT64 - advance)
+    return G_MAXUINT64;
+  return offset + advance;
 }
-#endif
 
 static GstFlowReturn
 gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
@@ -3077,7 +3750,17 @@ gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
       if (!qtdemux->moof_offset) {
         qtdemux->moof_offset = qtdemux->offset;
       }
-      /* fall-through */
+      if (qtdemux_pull_mfro_mfra (qtdemux)) {
+        /* FIXME */
+      } else {
+        qtdemux->offset += length;      /* skip moof and keep going */
+      }
+      if (qtdemux->got_moov) {
+        GST_INFO_OBJECT (qtdemux, "moof header, got moov, done with headers");
+        ret = GST_FLOW_EOS;
+        goto beach;
+      }
+      break;
     case FOURCC_mdat:
     case FOURCC_free:
     case FOURCC_wide:
@@ -3087,7 +3770,7 @@ gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
       GST_LOG_OBJECT (qtdemux,
           "skipping atom '%" GST_FOURCC_FORMAT "' at %" G_GUINT64_FORMAT,
           GST_FOURCC_ARGS (fourcc), cur_offset);
-      qtdemux->offset += length;
+      qtdemux->offset = add_offset (qtdemux->offset, length);
       break;
     }
     case FOURCC_moov:
@@ -3096,7 +3779,7 @@ gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
 
       if (qtdemux->got_moov) {
         GST_DEBUG_OBJECT (qtdemux, "Skipping moov atom as we have one already");
-        qtdemux->offset += length;
+        qtdemux->offset = add_offset (qtdemux->offset, length);
         goto beach;
       }
 
@@ -3185,6 +3868,19 @@ gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
       gst_buffer_unref (uuid);
       break;
     }
+    case FOURCC_sidx:
+    {
+      GstBuffer *sidx = NULL;
+      ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &sidx);
+      if (ret != GST_FLOW_OK)
+        goto beach;
+      qtdemux->offset += length;
+      gst_buffer_map (sidx, &map, GST_MAP_READ);
+      qtdemux_parse_sidx (qtdemux, map.data, map.size);
+      gst_buffer_unmap (sidx, &map);
+      gst_buffer_unref (sidx);
+      break;
+    }
     default:
     {
       GstBuffer *unknown = NULL;
@@ -3229,10 +3925,11 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
   guint8 n = 0;
   guint32 seg_idx = 0, k_index = 0;
   guint32 ref_seg_idx, ref_k_index;
-  guint64 k_pos = 0, last_stop = 0;
+  GstClockTime k_pos = 0, last_stop = 0;
   QtDemuxSegment *seg = NULL;
   QtDemuxStream *ref_str = NULL;
   guint64 seg_media_start_mov;  /* segment media start time in mov format */
+  guint64 target_ts;
 
   /* Now we choose an arbitrary stream, get the previous keyframe timestamp
    * and finally align all the other streams on that timestamp with their
@@ -3240,14 +3937,7 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
   for (n = 0; n < qtdemux->n_streams; n++) {
     QtDemuxStream *str = qtdemux->streams[n];
 
-    seg_idx = gst_qtdemux_find_segment (qtdemux, str,
-        qtdemux->segment.position);
-
-    /* segment not found, continue with normal flow */
-    if (seg_idx == -1)
-      continue;
-
-    /* No candidate yet, take that one */
+    /* No candidate yet, take the first stream */
     if (!ref_str) {
       ref_str = str;
       continue;
@@ -3283,34 +3973,44 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
       k_index = 0;
   }
 
+  target_ts =
+      ref_str->samples[k_index].timestamp +
+      ref_str->samples[k_index].pts_offset;
+
   /* get current segment for that stream */
   seg = &ref_str->segments[ref_str->segment_index];
-  /* convert seg->media_start to mov format time for timestamp comparison */
-  seg_media_start_mov =
-      gst_util_uint64_scale (seg->media_start, ref_str->timescale, GST_SECOND);
+  /* Use segment start in original timescale for comparisons */
+  seg_media_start_mov = seg->trak_media_start;
+
+  GST_LOG_OBJECT (qtdemux, "keyframe index %u ts %" G_GUINT64_FORMAT
+      " seg start %" G_GUINT64_FORMAT " %" GST_TIME_FORMAT "\n",
+      k_index, target_ts, seg_media_start_mov,
+      GST_TIME_ARGS (seg->media_start));
+
   /* Crawl back through segments to find the one containing this I frame */
-  while (ref_str->samples[k_index].timestamp < seg_media_start_mov) {
-    GST_DEBUG_OBJECT (qtdemux, "keyframe position is out of segment %u",
-        ref_str->segment_index);
+  while (target_ts < seg_media_start_mov) {
+    GST_DEBUG_OBJECT (qtdemux,
+        "keyframe position (sample %u) is out of segment %u " " target %"
+        G_GUINT64_FORMAT " seg start %" G_GUINT64_FORMAT, k_index,
+        ref_str->segment_index, target_ts, seg_media_start_mov);
+
     if (G_UNLIKELY (!ref_str->segment_index)) {
       /* Reached first segment, let's consider it's EOS */
       goto eos;
     }
     ref_str->segment_index--;
     seg = &ref_str->segments[ref_str->segment_index];
-    /* convert seg->media_start to mov format time for timestamp comparison */
-    seg_media_start_mov =
-        gst_util_uint64_scale (seg->media_start, ref_str->timescale,
-        GST_SECOND);
+    /* Use segment start in original timescale for comparisons */
+    seg_media_start_mov = seg->trak_media_start;
   }
   /* Calculate time position of the keyframe and where we should stop */
   k_pos =
-      (gst_util_uint64_scale (ref_str->samples[k_index].timestamp, GST_SECOND,
-          ref_str->timescale) - seg->media_start) + seg->time;
+      QTSTREAMTIME_TO_GSTTIME (ref_str,
+      target_ts - seg->trak_media_start) + seg->time;
   last_stop =
-      gst_util_uint64_scale (ref_str->samples[ref_str->from_sample].timestamp,
-      GST_SECOND, ref_str->timescale);
-  last_stop = (last_stop - seg->media_start) + seg->time;
+      QTSTREAMTIME_TO_GSTTIME (ref_str,
+      ref_str->samples[ref_str->from_sample].timestamp -
+      seg->trak_media_start) + seg->time;
 
   GST_DEBUG_OBJECT (qtdemux, "preferred stream played from sample %u, "
       "now going to sample %u (pts %" GST_TIME_FORMAT ")", ref_str->from_sample,
@@ -3332,7 +4032,7 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
   /* Align them all on this */
   for (n = 0; n < qtdemux->n_streams; n++) {
     guint32 index = 0;
-    guint64 media_start = 0, seg_time = 0;
+    GstClockTime seg_time = 0;
     QtDemuxStream *str = qtdemux->streams[n];
 
     /* aligning reference stream again might lead to backing up to yet another
@@ -3342,27 +4042,28 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
       seg_idx = ref_seg_idx;
       seg = &str->segments[seg_idx];
       k_index = ref_k_index;
-      GST_DEBUG_OBJECT (qtdemux, "reference stream segment %d, "
-          "sample at index %d", ref_str->segment_index, k_index);
+      GST_DEBUG_OBJECT (qtdemux, "reference stream %d segment %d, "
+          "sample at index %d", n, ref_str->segment_index, k_index);
     } else {
       seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
-      GST_DEBUG_OBJECT (qtdemux, "align segment %d", seg_idx);
-
-      /* segment not found, continue with normal flow */
-      if (seg_idx == -1)
-        continue;
+      GST_DEBUG_OBJECT (qtdemux,
+          "stream %d align segment %d for keyframe pos %" GST_TIME_FORMAT, n,
+          seg_idx, GST_TIME_ARGS (k_pos));
 
       /* get segment and time in the segment */
       seg = &str->segments[seg_idx];
       seg_time = k_pos - seg->time;
 
-      /* get the media time in the segment */
-      media_start = seg->media_start + seg_time;
+      /* get the media time in the segment.
+       * No adjustment for empty "filler" segments */
+      if (seg->media_start != GST_CLOCK_TIME_NONE)
+        seg_time += seg->media_start;
 
       /* get the index of the sample with media time */
-      index = gst_qtdemux_find_index_linear (qtdemux, str, media_start);
-      GST_DEBUG_OBJECT (qtdemux, "sample for %" GST_TIME_FORMAT " at %u",
-          GST_TIME_ARGS (media_start), index);
+      index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
+      GST_DEBUG_OBJECT (qtdemux,
+          "stream %d sample for %" GST_TIME_FORMAT " at %u", n,
+          GST_TIME_ARGS (seg_time), index);
 
       /* find previous keyframe */
       k_index = gst_qtdemux_find_keyframe (qtdemux, str, index);
@@ -3371,13 +4072,16 @@ gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
     /* Remember until where we want to go */
     str->to_sample = str->from_sample - 1;
     /* Define our time position */
-    str->time_position =
-        (gst_util_uint64_scale (str->samples[k_index].timestamp, GST_SECOND,
-            str->timescale) - seg->media_start) + seg->time;
+    target_ts =
+        str->samples[k_index].timestamp + str->samples[k_index].pts_offset;
+    str->time_position = QTSTREAMTIME_TO_GSTTIME (str, target_ts) + seg->time;
+    if (seg->media_start != GST_CLOCK_TIME_NONE)
+      str->time_position -= seg->media_start;
+
     /* Now seek back in time */
     gst_qtdemux_move_stream (qtdemux, str, k_index);
-    GST_DEBUG_OBJECT (qtdemux, "keyframe at %u, time position %"
-        GST_TIME_FORMAT " playing from sample %u to %u", k_index,
+    GST_DEBUG_OBJECT (qtdemux, "stream %d keyframe at %u, time position %"
+        GST_TIME_FORMAT " playing from sample %u to %u", n, k_index,
         GST_TIME_ARGS (str->time_position), str->from_sample, str->to_sample);
   }
 
@@ -3393,20 +4097,22 @@ eos:
  * This will push out a NEWSEGMENT event with the right values and
  * position the stream index to the first decodable sample before
  * @offset.
+ *
+ * PULL-BASED
  */
 static gboolean
 gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
-    guint32 seg_idx, guint64 offset)
+    guint32 seg_idx, GstClockTime offset)
 {
   GstEvent *event;
   QtDemuxSegment *segment;
   guint32 index, kf_index;
-  guint64 seg_time;
-  guint64 start, stop, time;
+  GstClockTime seg_time;
+  GstClockTime start, stop, time;
   gdouble rate;
 
-  GST_LOG_OBJECT (qtdemux, "activate segment %d, offset %" G_GUINT64_FORMAT,
-      seg_idx, offset);
+  GST_LOG_OBJECT (stream->pad, "activate segment %d, offset %" GST_TIME_FORMAT,
+      seg_idx, GST_TIME_ARGS (offset));
 
   /* update the current segment */
   stream->segment_index = seg_idx;
@@ -3415,30 +4121,32 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
   segment = &stream->segments[seg_idx];
 
   if (G_UNLIKELY (offset < segment->time)) {
-    GST_WARNING_OBJECT (qtdemux, "offset < segment->time %" G_GUINT64_FORMAT,
-        segment->time);
+    GST_WARNING_OBJECT (stream->pad, "offset < segment->time %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (segment->time));
     return FALSE;
   }
 
   /* segment lies beyond total indicated duration */
-  if (G_UNLIKELY (qtdemux->segment.duration != -1 &&
+  if (G_UNLIKELY (qtdemux->segment.duration != GST_CLOCK_TIME_NONE &&
           segment->time > qtdemux->segment.duration)) {
-    GST_WARNING_OBJECT (qtdemux, "file duration %" G_GINT64_FORMAT
-        " < segment->time %" G_GUINT64_FORMAT, qtdemux->segment.duration,
-        segment->time);
+    GST_WARNING_OBJECT (stream->pad, "file duration %" GST_TIME_FORMAT
+        " < segment->time %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (qtdemux->segment.duration),
+        GST_TIME_ARGS (segment->time));
     return FALSE;
   }
 
   /* get time in this segment */
   seg_time = offset - segment->time;
 
-  GST_LOG_OBJECT (qtdemux, "seg_time %" GST_TIME_FORMAT,
+  GST_LOG_OBJECT (stream->pad, "seg_time %" GST_TIME_FORMAT,
       GST_TIME_ARGS (seg_time));
 
   if (G_UNLIKELY (seg_time > segment->duration)) {
-    GST_LOG_OBJECT (qtdemux, "seg_time > segment->duration %" GST_TIME_FORMAT,
+    GST_LOG_OBJECT (stream->pad,
+        "seg_time > segment->duration %" GST_TIME_FORMAT,
         GST_TIME_ARGS (segment->duration));
-    return FALSE;
+    seg_time = segment->duration;
   }
 
   /* qtdemux->segment.stop is in outside-time-realm, whereas
@@ -3448,9 +4156,9 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
    * into the track-time-realm */
 
   stop = qtdemux->segment.stop;
-  if (stop == -1)
+  if (stop == GST_CLOCK_TIME_NONE)
     stop = qtdemux->segment.duration;
-  if (stop == -1)
+  if (stop == GST_CLOCK_TIME_NONE)
     stop = segment->media_stop;
   else
     stop =
@@ -3459,15 +4167,14 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (segment))) {
     start = segment->time + seg_time;
     time = offset;
+    stop = start - seg_time + segment->duration;
   } else if (qtdemux->segment.rate >= 0) {
     start = MIN (segment->media_start + seg_time, stop);
     time = offset;
   } else {
     if (segment->media_start >= qtdemux->segment.start) {
-      start = segment->media_start;
       time = segment->time;
     } else {
-      start = qtdemux->segment.start;
       time = segment->time + (qtdemux->segment.start - segment->media_start);
     }
 
@@ -3475,59 +4182,74 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
     stop = MIN (segment->media_start + seg_time, stop);
   }
 
-  GST_DEBUG_OBJECT (qtdemux, "newsegment %d from %" GST_TIME_FORMAT
+  GST_DEBUG_OBJECT (stream->pad, "new segment %d from %" GST_TIME_FORMAT
       " to %" GST_TIME_FORMAT ", time %" GST_TIME_FORMAT, seg_idx,
       GST_TIME_ARGS (start), GST_TIME_ARGS (stop), GST_TIME_ARGS (time));
 
   /* combine global rate with that of the segment */
   rate = segment->rate * qtdemux->segment.rate;
 
+  /* Copy flags from main segment */
+  stream->segment.flags = qtdemux->segment.flags;
+
   /* update the segment values used for clipping */
-  /* accumulate previous segments */
-  if (GST_CLOCK_TIME_IS_VALID (stream->segment.stop))
-    stream->segment.base += (stream->segment.stop - stream->segment.start) /
-        ABS (stream->segment.rate);
+  stream->segment.offset = qtdemux->segment.offset;
+  stream->segment.base = qtdemux->segment.base + stream->accumulated_base;
+  stream->segment.applied_rate = qtdemux->segment.applied_rate;
   stream->segment.rate = rate;
-  stream->segment.start = start;
-  stream->segment.stop = stop;
+  stream->segment.start = start + QTSTREAMTIME_TO_GSTTIME (stream,
+      stream->cslg_shift);
+  stream->segment.stop = stop + QTSTREAMTIME_TO_GSTTIME (stream,
+      stream->cslg_shift);
   stream->segment.time = time;
-  stream->segment.position = start;
-  stream->segment.base =
-      segment->time >
-      qtdemux->segment_base ? segment->time - qtdemux->segment_base : 0;
+  stream->segment.position = stream->segment.start;
+
+  GST_DEBUG_OBJECT (stream->pad, "New segment: %" GST_SEGMENT_FORMAT,
+      &stream->segment);
 
   /* now prepare and send the segment */
   if (stream->pad) {
     event = gst_event_new_segment (&stream->segment);
     if (stream->segment_seqnum) {
       gst_event_set_seqnum (event, stream->segment_seqnum);
-      stream->segment_seqnum = 0;
     }
     gst_pad_push_event (stream->pad, event);
+    /* assume we can send more data now */
+    GST_PAD_LAST_FLOW_RETURN (stream->pad) = GST_FLOW_OK;
     /* clear to send tags on this pad now */
     gst_qtdemux_push_tags (qtdemux, stream);
   }
 
+  /* in the fragmented case, we pick a fragment that starts before our
+   * desired position and rely on downstream to wait for a keyframe
+   * (FIXME: doesn't seem to work so well with ismv and wmv, as no parser; the
+   * tfra entries tells us which trun/sample the key unit is in, but we don't
+   * make use of this additional information at the moment) */
+  if (qtdemux->fragmented) {
+    stream->to_sample = G_MAXUINT32;
+    return TRUE;
+  }
+
   /* and move to the keyframe before the indicated media time of the
    * segment */
   if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
     if (qtdemux->segment.rate >= 0) {
       index = gst_qtdemux_find_index_linear (qtdemux, stream, start);
       stream->to_sample = G_MAXUINT32;
-      GST_DEBUG_OBJECT (qtdemux, "moving data pointer to %" GST_TIME_FORMAT
-          ", index: %u, pts %" GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
-          GST_TIME_ARGS (gst_util_uint64_scale (stream->
-                  samples[index].timestamp, GST_SECOND, stream->timescale)));
+      GST_DEBUG_OBJECT (stream->pad,
+          "moving data pointer to %" GST_TIME_FORMAT ", index: %u, pts %"
+          GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
+          GST_TIME_ARGS (QTSAMPLE_PTS (stream, &stream->samples[index])));
     } else {
       index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);
       stream->to_sample = index;
-      GST_DEBUG_OBJECT (qtdemux, "moving data pointer to %" GST_TIME_FORMAT
-          ", index: %u, pts %" GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
-          GST_TIME_ARGS (gst_util_uint64_scale (stream->
-                  samples[index].timestamp, GST_SECOND, stream->timescale)));
+      GST_DEBUG_OBJECT (stream->pad,
+          "moving data pointer to %" GST_TIME_FORMAT ", index: %u, pts %"
+          GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
+          GST_TIME_ARGS (QTSAMPLE_PTS (stream, &stream->samples[index])));
     }
   } else {
-    GST_DEBUG_OBJECT (qtdemux, "No need to look for keyframe, "
+    GST_DEBUG_OBJECT (stream->pad, "No need to look for keyframe, "
         "this is an empty segment");
     return TRUE;
   }
@@ -3539,7 +4261,7 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 
   /* we're at the right spot */
   if (index == stream->sample_index) {
-    GST_DEBUG_OBJECT (qtdemux, "we are at the right index");
+    GST_DEBUG_OBJECT (stream->pad, "we are at the right index");
     return TRUE;
   }
 
@@ -3555,26 +4277,22 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
   if (index > stream->sample_index) {
     /* moving forwards check if we move past a keyframe */
     if (kf_index > stream->sample_index) {
-      GST_DEBUG_OBJECT (qtdemux,
-          "moving forwards to keyframe at %u (pts %" GST_TIME_FORMAT, kf_index,
-          GST_TIME_ARGS (gst_util_uint64_scale (
-                  stream->samples[kf_index].timestamp,
-                  GST_SECOND, stream->timescale)));
+      GST_DEBUG_OBJECT (stream->pad,
+	   "moving forwards to keyframe at %u (pts %" GST_TIME_FORMAT " dts %"GST_TIME_FORMAT" )", kf_index,
+	   GST_TIME_ARGS (QTSAMPLE_PTS(stream, &stream->samples[kf_index])),
+	   GST_TIME_ARGS (QTSAMPLE_DTS(stream, &stream->samples[kf_index])));
       gst_qtdemux_move_stream (qtdemux, stream, kf_index);
     } else {
-      GST_DEBUG_OBJECT (qtdemux,
-          "moving forwards, keyframe at %u (pts %" GST_TIME_FORMAT
-          " already sent", kf_index,
-          GST_TIME_ARGS (gst_util_uint64_scale (
-                  stream->samples[kf_index].timestamp,
-                  GST_SECOND, stream->timescale)));
+      GST_DEBUG_OBJECT (stream->pad,
+          "moving forwards, keyframe at %u (pts %" GST_TIME_FORMAT " dts %"GST_TIME_FORMAT" ) already sent", kf_index,
+          GST_TIME_ARGS (QTSAMPLE_PTS (stream, &stream->samples[kf_index])),
+          GST_TIME_ARGS (QTSAMPLE_DTS (stream, &stream->samples[kf_index])));
     }
   } else {
-    GST_DEBUG_OBJECT (qtdemux,
-        "moving backwards to keyframe at %u (pts %" GST_TIME_FORMAT, kf_index,
-        GST_TIME_ARGS (gst_util_uint64_scale (
-                stream->samples[kf_index].timestamp,
-                GST_SECOND, stream->timescale)));
+    GST_DEBUG_OBJECT (stream->pad,
+        "moving backwards to keyframe at %u (pts %" GST_TIME_FORMAT " dts %"GST_TIME_FORMAT" )", kf_index,
+        GST_TIME_ARGS (QTSAMPLE_PTS(stream, &stream->samples[kf_index])),
+        GST_TIME_ARGS (QTSAMPLE_DTS(stream, &stream->samples[kf_index])));
     gst_qtdemux_move_stream (qtdemux, stream, kf_index);
   }
 
@@ -3588,20 +4306,23 @@ gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
  * This function will also prepare and send the segment when needed.
  *
  * Return FALSE if the stream is EOS.
+ *
+ * PULL-BASED
  */
 static gboolean
 gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
     QtDemuxStream * stream, gboolean * empty, guint64 * offset, guint * size,
-    guint64 * dts, guint64 * pts, guint64 * duration, gboolean * keyframe)
+    GstClockTime * dts, GstClockTime * pts, GstClockTime * duration,
+    gboolean * keyframe)
 {
   QtDemuxSample *sample;
-  guint64 time_position;
+  GstClockTime time_position;
   guint32 seg_idx;
 
   g_return_val_if_fail (stream != NULL, FALSE);
 
   time_position = stream->time_position;
-  if (G_UNLIKELY (time_position == -1))
+  if (G_UNLIKELY (time_position == GST_CLOCK_TIME_NONE))
     goto eos;
 
   seg_idx = stream->segment_index;
@@ -3609,18 +4330,14 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
     /* find segment corresponding to time_position if we are looking
      * for a segment. */
     seg_idx = gst_qtdemux_find_segment (qtdemux, stream, time_position);
-
-    /* nothing found, we're really eos */
-    if (seg_idx == -1)
-      goto eos;
   }
 
   /* different segment, activate it, sample_index will be set. */
   if (G_UNLIKELY (stream->segment_index != seg_idx))
     gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
 
-  if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&stream->
-              segments[stream->segment_index]))) {
+  if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&stream->segments[stream->
+                  segment_index]))) {
     QtDemuxSegment *seg = &stream->segments[stream->segment_index];
 
     GST_LOG_OBJECT (qtdemux, "Empty segment activated,"
@@ -3635,11 +4352,29 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
 
   *empty = FALSE;
 
+  if (stream->sample_index == -1)
+    stream->sample_index = 0;
+
   GST_LOG_OBJECT (qtdemux, "segment active, index = %u of %u",
       stream->sample_index, stream->n_samples);
 
-  if (G_UNLIKELY (stream->sample_index >= stream->n_samples))
-    goto eos;
+  if (G_UNLIKELY (stream->sample_index >= stream->n_samples)) {
+    if (!qtdemux->fragmented)
+      goto eos;
+
+    GST_INFO_OBJECT (qtdemux, "out of samples, trying to add more");
+    do {
+      GstFlowReturn flow;
+
+      GST_OBJECT_LOCK (qtdemux);
+      flow = qtdemux_add_fragmented_samples (qtdemux);
+      GST_OBJECT_UNLOCK (qtdemux);
+
+      if (flow != GST_FLOW_OK)
+        goto eos;
+    }
+    while (stream->sample_index >= stream->n_samples);
+  }
 
   if (!qtdemux_parse_samples (qtdemux, stream, stream->sample_index)) {
     GST_LOG_OBJECT (qtdemux, "Parsing of index %u failed!",
@@ -3662,7 +4397,7 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
   /* special cases */
 eos:
   {
-    stream->time_position = -1;
+    stream->time_position = GST_CLOCK_TIME_NONE;
     return FALSE;
   }
 }
@@ -3689,7 +4424,7 @@ gst_qtdemux_advance_sample (GstQTDemux * qtdemux, QtDemuxStream * stream)
     /* Mark the stream as EOS */
     GST_DEBUG_OBJECT (qtdemux,
         "reached max allowed sample %u, mark EOS", stream->to_sample);
-    stream->time_position = -1;
+    stream->time_position = GST_CLOCK_TIME_NONE;
     return;
   }
 
@@ -3711,17 +4446,14 @@ gst_qtdemux_advance_sample (GstQTDemux * qtdemux, QtDemuxStream * stream)
   sample = &stream->samples[stream->sample_index];
 
   /* see if we are past the segment */
-  if (G_UNLIKELY (gst_util_uint64_scale (sample->timestamp,
-              GST_SECOND, stream->timescale) >= segment->media_stop))
+  if (G_UNLIKELY (QTSAMPLE_DTS (stream, sample) >= segment->media_stop))
     goto next_segment;
 
-  if (gst_util_uint64_scale (sample->timestamp, GST_SECOND,
-          stream->timescale) >= segment->media_start) {
+  if (QTSAMPLE_DTS (stream, sample) >= segment->media_start) {
     /* inside the segment, update time_position, looks very familiar to
      * GStreamer segments, doesn't it? */
     stream->time_position =
-        (gst_util_uint64_scale (sample->timestamp, GST_SECOND,
-            stream->timescale) - segment->media_start) + segment->time;
+        QTSAMPLE_DTS (stream, sample) - segment->media_start + segment->time;
   } else {
     /* not yet in segment, time does not yet increment. This means
      * that we are still prerolling keyframes to the decoder so it can
@@ -3737,12 +4469,19 @@ next_segment:
 
     if (stream->segment_index == stream->n_segments - 1) {
       /* are we at the end of the last segment, we're EOS */
-      stream->time_position = -1;
+      stream->time_position = GST_CLOCK_TIME_NONE;
     } else {
       /* else we're only at the end of the current segment */
       stream->time_position = segment->stop_time;
     }
     /* make sure we select a new segment */
+
+    /* accumulate previous segments */
+    if (GST_CLOCK_TIME_IS_VALID (stream->segment.stop))
+      stream->accumulated_base +=
+          (stream->segment.stop -
+          stream->segment.start) / ABS (stream->segment.rate);
+
     stream->segment_index = -1;
   }
 }
@@ -3808,11 +4547,16 @@ gst_qtdemux_sync_streams (GstQTDemux * demux)
  *  GST_FLOW_EOS: when all pads EOS or NOT_LINKED.
  */
 static GstFlowReturn
-gst_qtdemux_combine_flows (GstQTDemux * demux, GstFlowReturn ret)
+gst_qtdemux_combine_flows (GstQTDemux * demux, QtDemuxStream * stream,
+    GstFlowReturn ret)
 {
   GST_LOG_OBJECT (demux, "flow return: %s", gst_flow_get_name (ret));
 
-  ret = gst_flow_combiner_update_flow (demux->flowcombiner, ret);
+  if (stream->pad)
+    ret = gst_flow_combiner_update_pad_flow (demux->flowcombiner, stream->pad,
+        ret);
+  else
+    ret = gst_flow_combiner_update_flow (demux->flowcombiner, ret);
 
   GST_LOG_OBJECT (demux, "combined flow return: %s", gst_flow_get_name (ret));
   return ret;
@@ -4009,8 +4753,8 @@ gst_qtdemux_process_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 static GstFlowReturn
 gst_qtdemux_decorate_and_push_buffer (GstQTDemux * qtdemux,
     QtDemuxStream * stream, GstBuffer * buf,
-    guint64 dts, guint64 pts, guint64 duration, gboolean keyframe,
-    guint64 position, guint64 byte_position)
+    GstClockTime dts, GstClockTime pts, GstClockTime duration,
+    gboolean keyframe, GstClockTime position, guint64 byte_position)
 {
   GstFlowReturn ret = GST_FLOW_OK;
 
@@ -4136,6 +4880,28 @@ gst_qtdemux_decorate_and_push_buffer (GstQTDemux * qtdemux,
       GST_TIME_ARGS (pts), GST_TIME_ARGS (duration),
       GST_PAD_NAME (stream->pad));
 
+  if (stream->protected && stream->protection_scheme_type == FOURCC_cenc) {
+    GstStructure *crypto_info;
+    QtDemuxCencSampleSetInfo *info =
+        (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+    gint index;
+    GstEvent *event;
+
+    while ((event = g_queue_pop_head (&stream->protection_scheme_event_queue))) {
+      gst_pad_push_event (stream->pad, event);
+    }
+
+    index = stream->sample_index - (stream->n_samples - info->crypto_info->len);
+    if (G_LIKELY (index >= 0 && index < info->crypto_info->len)) {
+      /* steal structure from array */
+      crypto_info = g_ptr_array_index (info->crypto_info, index);
+      g_ptr_array_index (info->crypto_info, index) = NULL;
+      GST_LOG_OBJECT (qtdemux, "attaching cenc metadata [%u]", index);
+      if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))
+        GST_ERROR_OBJECT (qtdemux, "failed to attach cenc metadata to buffer");
+    }
+  }
+
   ret = gst_pad_push (stream->pad, buf);
 
   if (GST_CLOCK_TIME_IS_VALID (pts) && GST_CLOCK_TIME_IS_VALID (duration)) {
@@ -4147,17 +4913,108 @@ exit:
   return ret;
 }
 
+static const QtDemuxRandomAccessEntry *
+gst_qtdemux_stream_seek_fragment (GstQTDemux * qtdemux, QtDemuxStream * stream,
+    GstClockTime pos, gboolean after)
+{
+  QtDemuxRandomAccessEntry *entries = stream->ra_entries;
+  guint n_entries = stream->n_ra_entries;
+  guint i;
+
+  /* we assume the table is sorted */
+  for (i = 0; i < n_entries; ++i) {
+    if (entries[i].ts > pos)
+      break;
+  }
+
+  /* FIXME: maybe save first moof_offset somewhere instead, but for now it's
+   * probably okay to assume that the index lists the very first fragment */
+  if (i == 0)
+    return &entries[0];
+
+  if (after)
+    return &entries[i];
+  else
+    return &entries[i - 1];
+}
+
+static gboolean
+gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
+{
+  const QtDemuxRandomAccessEntry *best_entry = NULL;
+  guint i;
+
+  GST_OBJECT_LOCK (qtdemux);
+
+  g_assert (qtdemux->n_streams > 0);
+
+  for (i = 0; i < qtdemux->n_streams; i++) {
+    const QtDemuxRandomAccessEntry *entry;
+    QtDemuxStream *stream;
+    gboolean is_audio_or_video;
+
+    stream = qtdemux->streams[i];
+
+    g_free (stream->samples);
+    stream->samples = NULL;
+    stream->n_samples = 0;
+    stream->stbl_index = -1;    /* no samples have yet been parsed */
+    stream->sample_index = -1;
+
+    if (stream->ra_entries == NULL)
+      continue;
+
+    if (stream->subtype == FOURCC_vide || stream->subtype == FOURCC_soun)
+      is_audio_or_video = TRUE;
+    else
+      is_audio_or_video = FALSE;
+
+    entry =
+        gst_qtdemux_stream_seek_fragment (qtdemux, stream,
+        stream->time_position, !is_audio_or_video);
+
+    GST_INFO_OBJECT (stream->pad, "%" GST_TIME_FORMAT " at offset "
+        "%" G_GUINT64_FORMAT, GST_TIME_ARGS (entry->ts), entry->moof_offset);
+
+    stream->pending_seek = entry;
+
+    /* decide position to jump to just based on audio/video tracks, not subs */
+    if (!is_audio_or_video)
+      continue;
+
+    if (best_entry == NULL || entry->moof_offset < best_entry->moof_offset)
+      best_entry = entry;
+  }
+
+  if (best_entry == NULL) {
+    GST_OBJECT_UNLOCK (qtdemux);
+    return FALSE;
+  }
+
+  GST_INFO_OBJECT (qtdemux, "seek to %" GST_TIME_FORMAT ", best fragment "
+      "moof offset: %" G_GUINT64_FORMAT ", ts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (qtdemux->streams[0]->time_position),
+      best_entry->moof_offset, GST_TIME_ARGS (best_entry->ts));
+
+  qtdemux->moof_offset = best_entry->moof_offset;
+
+  qtdemux_add_fragmented_samples (qtdemux);
+
+  GST_OBJECT_UNLOCK (qtdemux);
+  return TRUE;
+}
+
 static GstFlowReturn
 gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *buf = NULL;
   QtDemuxStream *stream;
-  guint64 min_time;
+  GstClockTime min_time;
   guint64 offset = 0;
-  guint64 dts = GST_CLOCK_TIME_NONE;
-  guint64 pts = GST_CLOCK_TIME_NONE;
-  guint64 duration = 0;
+  GstClockTime dts = GST_CLOCK_TIME_NONE;
+  GstClockTime pts = GST_CLOCK_TIME_NONE;
+  GstClockTime duration = 0;
   gboolean keyframe = FALSE;
   guint sample_size = 0;
   gboolean empty = 0;
@@ -4167,18 +5024,25 @@ gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
 
   gst_qtdemux_push_pending_newsegment (qtdemux);
 
+  if (qtdemux->fragmented_seek_pending) {
+    GST_INFO_OBJECT (qtdemux, "pending fragmented seek");
+    gst_qtdemux_do_fragmented_seek (qtdemux);
+    GST_INFO_OBJECT (qtdemux, "fragmented seek done!");
+    qtdemux->fragmented_seek_pending = FALSE;
+  }
+
   /* Figure out the next stream sample to output, min_time is expressed in
    * global time and runs over the edit list segments. */
   min_time = G_MAXUINT64;
   index = -1;
   for (i = 0; i < qtdemux->n_streams; i++) {
-    guint64 position;
+    GstClockTime position;
 
     stream = qtdemux->streams[i];
     position = stream->time_position;
 
     /* position of -1 is EOS */
-    if (position != -1 && position < min_time) {
+    if (position != GST_CLOCK_TIME_NONE && position < min_time) {
       min_time = position;
       index = i;
     }
@@ -4196,7 +5060,7 @@ gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
                   && qtdemux->segment.start > min_time))
           && qtdemux->streams[index]->on_keyframe)) {
     GST_DEBUG_OBJECT (qtdemux, "we reached the end of our segment.");
-    qtdemux->streams[index]->time_position = -1;
+    qtdemux->streams[index]->time_position = GST_CLOCK_TIME_NONE;
     goto eos_stream;
   }
 
@@ -4230,6 +5094,15 @@ gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
               &offset, &sample_size, &dts, &pts, &duration, &keyframe)))
     goto eos_stream;
 
+  /* If we're doing a keyframe-only trickmode, only push keyframes on video streams */
+  if (G_UNLIKELY (qtdemux->
+          segment.flags & GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {
+    if (stream->subtype == FOURCC_vide && !keyframe) {
+      GST_LOG_OBJECT (qtdemux, "Skipping non-keyframe on stream %d", index);
+      goto next;
+    }
+  }
+
   GST_DEBUG_OBJECT (qtdemux,
       "pushing from stream %d, empty %d offset %" G_GUINT64_FORMAT
       ", size %d, dts=%" GST_TIME_FORMAT ", pts=%" GST_TIME_FORMAT
@@ -4290,9 +5163,8 @@ gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
     QtDemuxSample *sample = &stream->samples[stream->sample_index];
     QtDemuxSegment *segment = &stream->segments[stream->segment_index];
 
-    GstClockTime time_position = gst_util_uint64_scale (sample->timestamp +
-        stream->offset_in_sample / stream->bytes_per_frame, GST_SECOND,
-        stream->timescale);
+    GstClockTime time_position = QTSTREAMTIME_TO_GSTTIME (stream,
+        sample->timestamp + stream->offset_in_sample / stream->bytes_per_frame);
     if (time_position >= segment->media_start) {
       /* inside the segment, update time_position, looks very familiar to
        * GStreamer segments, doesn't it? */
@@ -4307,7 +5179,7 @@ gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
   }
 
   /* combine flows */
-  ret = gst_qtdemux_combine_flows (qtdemux, ret);
+  ret = gst_qtdemux_combine_flows (qtdemux, stream, ret);
   /* ignore unlinked, we will not push on the pad anymore and we will EOS when
    * we have no more data for the pad to push */
   if (ret == GST_FLOW_EOS)
@@ -4611,13 +5483,47 @@ done:
   demux->upstream_size = seekable ? stop : -1;
 }
 
-/* FIXME, unverified after edit list updates */
+static void
+gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
+{
+  g_return_if_fail (bytes <= demux->todrop);
+
+  GST_LOG_OBJECT (demux, "Dropping %d bytes", bytes);
+  gst_adapter_flush (demux->adapter, bytes);
+  demux->neededbytes -= bytes;
+  demux->offset += bytes;
+  demux->todrop -= bytes;
+}
+
 static GstFlowReturn
 gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
 {
   GstQTDemux *demux;
 
   demux = GST_QTDEMUX (parent);
+
+  if (GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_DISCONT)) {
+    gint i;
+
+    GST_DEBUG_OBJECT (demux, "Got DISCONT, marking all streams as DISCONT");
+
+    for (i = 0; i < demux->n_streams; i++) {
+      demux->streams[i]->discont = TRUE;
+    }
+
+    /* Reverse fragmented playback, need to flush all we have before
+     * consuming a new fragment.
+     * The samples array have the timestamps calculated by accumulating the
+     * durations but this won't work for reverse playback of fragments as
+     * the timestamps of a subsequent fragment should be smaller than the
+     * previously received one. */
+    if (demux->fragmented && demux->segment.rate < 0) {
+      gst_qtdemux_process_adapter (demux, TRUE);
+      for (i = 0; i < demux->n_streams; i++)
+        gst_qtdemux_stream_flush_samples_data (demux, demux->streams[i]);
+    }
+  }
+
   gst_adapter_push (demux->adapter, inbuf);
 
   GST_DEBUG_OBJECT (demux,
@@ -4837,6 +5743,7 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
                   GST_TIME_ARGS (demux->fragment_start));
             }
 
+            demux->moof_offset = demux->offset;
             if (!qtdemux_parse_moof (demux, data, demux->neededbytes,
                     demux->offset, NULL)) {
               gst_adapter_unmap (demux->adapter);
@@ -4862,6 +5769,9 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
         } else if (fourcc == FOURCC_uuid) {
           GST_DEBUG_OBJECT (demux, "Parsing [uuid]");
           qtdemux_parse_uuid (demux, data, demux->neededbytes);
+        } else if (fourcc == FOURCC_sidx) {
+          GST_DEBUG_OBJECT (demux, "Parsing [sidx]");
+          qtdemux_parse_sidx (demux, data, demux->neededbytes);
         } else {
           GST_WARNING_OBJECT (demux,
               "Unknown fourcc while parsing header : %" GST_FOURCC_FORMAT,
@@ -4948,11 +5858,10 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
         break;
       }
       case QTDEMUX_STATE_MOVIE:{
-        GstBuffer *outbuf;
         QtDemuxStream *stream = NULL;
         QtDemuxSample *sample;
         int i = -1;
-        guint64 dts, pts, duration;
+        GstClockTime dts, pts, duration;
         gboolean keyframe;
 
         GST_DEBUG_OBJECT (demux,
@@ -4975,9 +5884,9 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
           } else {
             GST_DEBUG_OBJECT (demux, "data atom emptied; resuming atom scan");
             /* so we are dropping more than left in this atom */
-            demux->todrop -= demux->mdatleft;
-            demux->neededbytes -= demux->mdatleft;
+            gst_qtdemux_drop_data (demux, demux->mdatleft);
             demux->mdatleft = 0;
+
             /* need to resume atom parsing so we do not miss any other pieces */
             demux->state = QTDEMUX_STATE_INITIAL;
             demux->neededbytes = 16;
@@ -4996,10 +5905,7 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
         }
 
         if (demux->todrop) {
-          GST_LOG_OBJECT (demux, "Dropping %d bytes", demux->todrop);
-          gst_adapter_flush (demux->adapter, demux->todrop);
-          demux->neededbytes -= demux->todrop;
-          demux->offset += demux->todrop;
+          gst_qtdemux_drop_data (demux, demux->todrop);
         }
 
         /* first buffer? */
@@ -5046,12 +5952,9 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
         sample = &stream->samples[stream->sample_index];
 
         if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
-          outbuf = gst_adapter_take_buffer (demux->adapter, demux->neededbytes);
           GST_DEBUG_OBJECT (demux, "stream : %" GST_FOURCC_FORMAT,
               GST_FOURCC_ARGS (stream->fourcc));
 
-          g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
-
           dts = QTSAMPLE_DTS (stream, sample);
           pts = QTSAMPLE_PTS (stream, sample);
           duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
@@ -5061,7 +5964,10 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
           if (G_UNLIKELY (demux->segment.stop != -1
                   && demux->segment.stop <= pts && stream->on_keyframe)) {
             GST_DEBUG_OBJECT (demux, "we reached the end of our segment.");
-            stream->time_position = -1; /* this means EOS */
+            stream->time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
+
+            /* skip this data, stream is EOS */
+            gst_adapter_flush (demux->adapter, demux->neededbytes);
 
             /* check if all streams are eos */
             ret = GST_FLOW_EOS;
@@ -5077,12 +5983,20 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
               goto eos;
             }
           } else {
+            GstBuffer *outbuf;
+
+            outbuf =
+                gst_adapter_take_buffer (demux->adapter, demux->neededbytes);
+
+            /* FIXME: should either be an assert or a plain check */
+            g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
+
             ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,
                 dts, pts, duration, keyframe, dts, demux->offset);
           }
 
           /* combine flows */
-          ret = gst_qtdemux_combine_flows (demux, ret);
+          ret = gst_qtdemux_combine_flows (demux, stream, ret);
         } else {
           /* skip this data, stream is EOS */
           gst_adapter_flush (demux->adapter, demux->neededbytes);
@@ -5654,6 +6568,16 @@ qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node, const guint8 * buffer,
         qtdemux_parse_uuid (qtdemux, buffer, end - buffer);
         break;
       }
+      case FOURCC_encv:
+      {
+        qtdemux_parse_container (qtdemux, node, buffer + 86, end);
+        break;
+      }
+      case FOURCC_enca:
+      {
+        qtdemux_parse_container (qtdemux, node, buffer + 36, end);
+        break;
+      }
       default:
         if (!strcmp (type->name, "unknown"))
           GST_MEMDUMP ("Unknown tag", buffer + 4, end - buffer - 4);
@@ -5801,29 +6725,80 @@ qtdemux_do_allocation (GstQTDemux * qtdemux, QtDemuxStream * stream)
 }
 
 static gboolean
+gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
+    QtDemuxStream * stream)
+{
+  GstStructure *s;
+  const gchar *selected_system;
+
+  g_return_val_if_fail (qtdemux != NULL, FALSE);
+  g_return_val_if_fail (stream != NULL, FALSE);
+  g_return_val_if_fail (gst_caps_get_size (stream->caps) == 1, FALSE);
+
+  if (stream->protection_scheme_type != FOURCC_cenc) {
+    GST_ERROR_OBJECT (qtdemux, "unsupported protection scheme");
+    return FALSE;
+  }
+  if (qtdemux->protection_system_ids == NULL) {
+    GST_ERROR_OBJECT (qtdemux, "stream is protected using cenc, but no "
+        "cenc protection system information has been found");
+    return FALSE;
+  }
+  g_ptr_array_add (qtdemux->protection_system_ids, NULL);
+  selected_system = gst_protection_select_system ((const gchar **)
+      qtdemux->protection_system_ids->pdata);
+  g_ptr_array_remove_index (qtdemux->protection_system_ids,
+      qtdemux->protection_system_ids->len - 1);
+  if (!selected_system) {
+    GST_ERROR_OBJECT (qtdemux, "stream is protected, but no "
+        "suitable decryptor element has been found");
+    return FALSE;
+  }
+
+  s = gst_caps_get_structure (stream->caps, 0);
+  gst_structure_set (s,
+      "original-media-type", G_TYPE_STRING, gst_structure_get_name (s),
+      GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
+      NULL);
+  gst_structure_set_name (s, "application/x-cenc");
+  return TRUE;
+}
+
+static gboolean
 gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)
 {
   if (stream->subtype == FOURCC_vide) {
-    /* fps is calculated base on the duration of the first frames since
+    /* fps is calculated base on the duration of the average framerate since
      * qt does not have a fixed framerate. */
-    if ((stream->n_samples == 1) && (stream->min_duration == 0)) {
+    if ((stream->n_samples == 1) && (stream->first_duration == 0)) {
       /* still frame */
       stream->fps_n = 0;
       stream->fps_d = 1;
     } else {
-      /* we might need to scale the timescale to get precise framerate */
-      const int required_scale = rint (log (10000) / 2.303);    /* divide to get log10 */
-      int current_scale = rint (log (stream->timescale) / 2.303);
-      int factor = pow (10.0, MAX (0, required_scale - current_scale));
+      if (stream->duration == 0 || stream->n_samples < 2) {
+        stream->fps_n = stream->timescale;
+        stream->fps_d = 1;
+      } else {
+        /* Calculate a framerate, ignoring the first sample which is sometimes truncated */
+        /* stream->duration is guint64, timescale, n_samples are guint32 */
+        GstClockTime avg_duration =
+            gst_util_uint64_scale_round (stream->duration -
+            stream->first_duration, GST_SECOND,
+            (guint64) (stream->timescale) * (stream->n_samples - 1));
 
-      stream->fps_n = stream->timescale * factor;
+        GST_LOG_OBJECT (qtdemux,
+            "Calculating avg sample duration based on stream duration %"
+            G_GUINT64_FORMAT
+            " minus first sample %u, leaving %d samples gives %"
+            GST_TIME_FORMAT, stream->duration, stream->first_duration,
+            stream->n_samples - 1, GST_TIME_ARGS (avg_duration));
 
-      if (stream->duration == 0 || stream->n_samples == 0)
-        stream->fps_d = factor;
-      else
-        stream->fps_d =
-            gst_util_uint64_scale_int_round (stream->duration, factor,
-            stream->n_samples);
+        gst_video_guess_framerate (avg_duration, &stream->fps_n,
+            &stream->fps_d);
+      }
+      GST_DEBUG_OBJECT (qtdemux,
+          "Calculating framerate, timescale %u gave fps_n %d fps_d %d",
+          stream->timescale, stream->fps_n, stream->fps_d);
     }
 
     if (stream->caps) {
@@ -5838,8 +6813,12 @@ gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)
       GST_DEBUG_OBJECT (qtdemux,
           "video size %dx%d, target display size %dx%d", stream->width,
           stream->height, stream->display_width, stream->display_height);
-
-      if (stream->display_width > 0 && stream->display_height > 0 &&
+      /* qt file might have pasp atom */
+      if (stream->par_w > 0 && stream->par_h > 0) {
+        GST_DEBUG_OBJECT (qtdemux, "par %d:%d", stream->par_w, stream->par_h);
+        gst_caps_set_simple (stream->caps, "pixel-aspect-ratio",
+            GST_TYPE_FRACTION, stream->par_w, stream->par_h, NULL);
+      } else if (stream->display_width > 0 && stream->display_height > 0 &&
           stream->width > 0 && stream->height > 0) {
         gint n, d;
 
@@ -5849,18 +6828,35 @@ gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)
         if (n == d)
           n = d = 1;
         GST_DEBUG_OBJECT (qtdemux, "setting PAR to %d/%d", n, d);
+        stream->par_w = n;
+        stream->par_h = d;
         gst_caps_set_simple (stream->caps, "pixel-aspect-ratio",
-            GST_TYPE_FRACTION, n, d, NULL);
+            GST_TYPE_FRACTION, stream->par_w, stream->par_h, NULL);
       }
 
-      /* qt file might have pasp atom */
-      if (stream->par_w > 0 && stream->par_h > 0) {
-        GST_DEBUG_OBJECT (qtdemux, "par %d:%d", stream->par_w, stream->par_h);
-        gst_caps_set_simple (stream->caps, "pixel-aspect-ratio",
-            GST_TYPE_FRACTION, stream->par_w, stream->par_h, NULL);
+      if (stream->multiview_mode != GST_VIDEO_MULTIVIEW_MODE_NONE) {
+        guint par_w = 1, par_h = 1;
+
+        if (stream->par_w > 0 && stream->par_h > 0) {
+          par_w = stream->par_w;
+          par_h = stream->par_h;
+        }
+
+        if (gst_video_multiview_guess_half_aspect (stream->multiview_mode,
+                stream->width, stream->height, par_w, par_h)) {
+          stream->multiview_flags |= GST_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT;
+        }
+
+        gst_caps_set_simple (stream->caps,
+            "multiview-mode", G_TYPE_STRING,
+            gst_video_multiview_mode_to_caps_string (stream->multiview_mode),
+            "multiview-flags", GST_TYPE_VIDEO_MULTIVIEW_FLAGSET,
+            stream->multiview_flags, GST_FLAG_SET_MASK_EXACT, NULL);
       }
     }
-  } else if (stream->subtype == FOURCC_soun) {
+  }
+
+  else if (stream->subtype == FOURCC_soun) {
     if (stream->caps) {
       stream->caps = gst_caps_make_writable (stream->caps);
       if (stream->rate > 0)
@@ -5887,6 +6883,14 @@ gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)
 
     gst_pad_use_fixed_caps (stream->pad);
 
+    if (stream->protected) {
+      if (!gst_qtdemux_configure_protected_caps (qtdemux, stream)) {
+        GST_ERROR_OBJECT (qtdemux,
+            "Failed to configure protected stream caps.");
+        return FALSE;
+      }
+    }
+
     GST_DEBUG_OBJECT (qtdemux, "setting caps %" GST_PTR_FORMAT, stream->caps);
     if (stream->new_stream) {
       gchar *stream_id;
@@ -5956,7 +6960,7 @@ gst_qtdemux_add_stream (GstQTDemux * qtdemux,
   } else if (stream->subtype == FOURCC_strm) {
     GST_DEBUG_OBJECT (qtdemux, "stream type, not creating pad");
   } else if (stream->subtype == FOURCC_subp || stream->subtype == FOURCC_text
-      || stream->subtype == FOURCC_sbtl) {
+      || stream->subtype == FOURCC_sbtl || stream->subtype == FOURCC_subt) {
     gchar *name = g_strdup_printf ("subtitle_%u", qtdemux->n_sub_streams);
 
     stream->pad =
@@ -5978,6 +6982,8 @@ gst_qtdemux_add_stream (GstQTDemux * qtdemux,
   }
 
   if (stream->pad) {
+    GList *l;
+
     GST_DEBUG_OBJECT (qtdemux, "adding pad %s %p to qtdemux %p",
         GST_OBJECT_NAME (stream->pad), stream->pad, qtdemux);
     gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), stream->pad);
@@ -5986,10 +6992,17 @@ gst_qtdemux_add_stream (GstQTDemux * qtdemux,
     if (stream->pending_tags)
       gst_tag_list_unref (stream->pending_tags);
     stream->pending_tags = list;
+    list = NULL;
     /* global tags go on each pad anyway */
     stream->send_global_tags = TRUE;
+    /* send upstream GST_EVENT_PROTECTION events that were received before
+       this source pad was created */
+    for (l = qtdemux->protection_event_queue.head; l != NULL; l = l->next)
+      gst_pad_push_event (stream->pad, gst_event_ref (l->data));
   }
 done:
+  if (list)
+    gst_tag_list_unref (list);
   return TRUE;
 }
 
@@ -6286,6 +7299,7 @@ qtdemux_stbl_init (GstQTDemux * qtdemux, QtDemuxStream * stream, GNode * stbl)
     return FALSE;
   }
 
+  g_assert (stream->samples == NULL);
   stream->samples = g_try_new0 (QtDemuxSample, stream->n_samples);
   if (!stream->samples) {
     GST_WARNING_OBJECT (qtdemux, "failed to allocate %d samples",
@@ -6293,24 +7307,65 @@ qtdemux_stbl_init (GstQTDemux * qtdemux, QtDemuxStream * stream, GNode * stbl)
     return FALSE;
   }
 
-
   /* composition time-to-sample */
   if ((stream->ctts_present =
           ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_ctts,
               &stream->ctts) ? TRUE : FALSE) == TRUE) {
+    GstByteReader cslg = GST_BYTE_READER_INIT (NULL, 0);
+
     /* copy atom data into a new buffer for later use */
     stream->ctts.data = g_memdup (stream->ctts.data, stream->ctts.size);
 
-    /* skip version + flags */
-    if (!gst_byte_reader_skip (&stream->ctts, 1 + 3)
-        || !gst_byte_reader_get_uint32_be (&stream->ctts,
-            &stream->n_composition_times))
-      goto corrupt_file;
+    /* skip version + flags */
+    if (!gst_byte_reader_skip (&stream->ctts, 1 + 3)
+        || !gst_byte_reader_get_uint32_be (&stream->ctts,
+            &stream->n_composition_times))
+      goto corrupt_file;
+
+    /* make sure there's enough data */
+    if (!qt_atom_parser_has_chunks (&stream->ctts, stream->n_composition_times,
+            4 + 4))
+      goto corrupt_file;
+
+    /* This is optional, if missing we iterate the ctts */
+    if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &cslg)) {
+      if (!gst_byte_reader_skip (&cslg, 1 + 3)
+          || !gst_byte_reader_get_uint32_be (&cslg, &stream->cslg_shift)) {
+        g_free ((gpointer) cslg.data);
+        goto corrupt_file;
+      }
+    } else {
+      gint32 cslg_least = 0;
+      guint num_entries, pos;
+      gint i;
+
+      pos = gst_byte_reader_get_pos (&stream->ctts);
+      num_entries = stream->n_composition_times;
+
+      stream->cslg_shift = 0;
+
+      for (i = 0; i < num_entries; i++) {
+        gint32 offset;
+
+        gst_byte_reader_skip_unchecked (&stream->ctts, 4);
+        offset = gst_byte_reader_get_int32_be_unchecked (&stream->ctts);
+
+        if (offset < cslg_least)
+          cslg_least = offset;
+      }
+
+      if (cslg_least < 0)
+        stream->cslg_shift = ABS (cslg_least);
+      else
+        stream->cslg_shift = 0;
 
-    /* make sure there's enough data */
-    if (!qt_atom_parser_has_chunks (&stream->ctts, stream->n_composition_times,
-            4 + 4))
-      goto corrupt_file;
+      /* reset the reader so we can generate sample table */
+      gst_byte_reader_set_pos (&stream->ctts, pos);
+    }
+  } else {
+    /* Ensure the cslg_shift value is consistent so we can use it
+     * unconditionnally to produce TS and Segment */
+    stream->cslg_shift = 0;
   }
 
   return TRUE;
@@ -6485,8 +7540,8 @@ qtdemux_parse_samples (GstQTDemux * qtdemux, QtDemuxStream * stream, guint32 n)
 
         GST_DEBUG_OBJECT (qtdemux,
             "keyframe sample %d: timestamp %" GST_TIME_FORMAT ", size %u",
-            j, GST_TIME_ARGS (gst_util_uint64_scale (stream->stco_sample_index,
-                    GST_SECOND, stream->timescale)), cur->size);
+            j, GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
+                    stream->stco_sample_index)), cur->size);
 
         cur->timestamp = stream->stco_sample_index;
         cur->duration = stream->samples_per_chunk;
@@ -6512,7 +7567,7 @@ qtdemux_parse_samples (GstQTDemux * qtdemux, QtDemuxStream * stream, guint32 n)
         for (k = stream->stsc_sample_index; k < samples_per_chunk; k++) {
           GST_LOG_OBJECT (qtdemux, "creating entry %d with offset %"
               G_GUINT64_FORMAT " and size %d",
-              (guint) (cur - samples), stream->chunk_offset, cur->size);
+              (guint) (cur - samples), chunk_offset, cur->size);
 
           cur->offset = chunk_offset;
           chunk_offset += cur->size;
@@ -6569,8 +7624,7 @@ done2:
         GST_DEBUG_OBJECT (qtdemux,
             "sample %d: index %d, timestamp %" GST_TIME_FORMAT,
             (guint) (cur - samples), j,
-            GST_TIME_ARGS (gst_util_uint64_scale (stts_time, GST_SECOND,
-                    stream->timescale)));
+            GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, stts_time)));
 
         cur->timestamp = stts_time;
         cur->duration = stts_duration;
@@ -6599,8 +7653,7 @@ done2:
       GST_DEBUG_OBJECT (qtdemux,
           "fill sample %d: timestamp %" GST_TIME_FORMAT,
           (guint) (cur - samples),
-          GST_TIME_ARGS (gst_util_uint64_scale (stream->stts_time, GST_SECOND,
-                  stream->timescale)));
+          GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, stream->stts_time)));
       cur->timestamp = stream->stts_time;
       cur->duration = -1;
     }
@@ -6718,11 +7771,13 @@ done:
   /* if index has been completely parsed, free data that is no-longer needed */
   if (n + 1 == stream->n_samples) {
     gst_qtdemux_stbl_free (stream);
-    GST_DEBUG_OBJECT (qtdemux,
-        "parsed all available samples; checking for more");
-    while (n + 1 == stream->n_samples)
-      if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)
-        break;
+    GST_DEBUG_OBJECT (qtdemux, "parsed all available samples;");
+    if (qtdemux->pullbased) {
+      GST_DEBUG_OBJECT (qtdemux, "checking for more samples");
+      while (n + 1 == stream->n_samples)
+        if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)
+          break;
+    }
   }
   GST_OBJECT_UNLOCK (qtdemux);
 
@@ -6775,7 +7830,8 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
     GNode *elst;
     gint n_segments;
     gint i, count;
-    guint64 time, stime;
+    guint64 time;
+    GstClockTime stime;
     guint8 *buffer;
 
     GST_DEBUG_OBJECT (qtdemux, "looking for edit list");
@@ -6808,13 +7864,14 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
       segment->time = stime;
       /* add non scaled values so we don't cause roundoff errors */
       time += duration;
-      stime = gst_util_uint64_scale (time, GST_SECOND, qtdemux->timescale);
+      stime = QTTIME_TO_GSTTIME (qtdemux, time);
       segment->stop_time = stime;
       segment->duration = stime - segment->time;
+
+      segment->trak_media_start = media_time;
       /* media_time expressed in stream timescale */
       if (media_time != G_MAXUINT32) {
-        segment->media_start =
-            gst_util_uint64_scale (media_time, GST_SECOND, stream->timescale);
+        segment->media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
         segment->media_stop = segment->media_start + segment->duration;
       } else {
         segment->media_start = GST_CLOCK_TIME_NONE;
@@ -6833,10 +7890,23 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
       }
 
       GST_DEBUG_OBJECT (qtdemux, "created segment %d time %" GST_TIME_FORMAT
-          ", duration %" GST_TIME_FORMAT ", media_time %" GST_TIME_FORMAT
-          ", rate %g, (%d)", i, GST_TIME_ARGS (segment->time),
+          ", duration %" GST_TIME_FORMAT ", media_start %" GST_TIME_FORMAT
+          " (%" G_GUINT64_FORMAT ") , media_stop %" GST_TIME_FORMAT
+          " stop_time %" GST_TIME_FORMAT " rate %g, (%d) timescale %u",
+          i, GST_TIME_ARGS (segment->time),
           GST_TIME_ARGS (segment->duration),
-          GST_TIME_ARGS (segment->media_start), segment->rate, rate_int);
+          GST_TIME_ARGS (segment->media_start), media_time,
+          GST_TIME_ARGS (segment->media_stop),
+          GST_TIME_ARGS (segment->stop_time), segment->rate, rate_int,
+          stream->timescale);
+      if (segment->stop_time > qtdemux->segment.stop) {
+        GST_WARNING_OBJECT (qtdemux, "Segment %d "
+            " extends to %" GST_TIME_FORMAT
+            " past the end of the file duration %" GST_TIME_FORMAT
+            " it will be truncated", i, GST_TIME_ARGS (segment->stop_time),
+            GST_TIME_ARGS (qtdemux->segment.stop));
+        qtdemux->segment.stop = segment->stop_time;
+      }
     }
     GST_DEBUG_OBJECT (qtdemux, "found %d segments", count);
     stream->n_segments = count;
@@ -6856,14 +7926,14 @@ done:
   /* no segments, create one to play the complete trak */
   if (stream->n_segments == 0) {
     GstClockTime stream_duration =
-        gst_util_uint64_scale (stream->duration, GST_SECOND, stream->timescale);
+        QTSTREAMTIME_TO_GSTTIME (stream, stream->duration);
 
     if (stream->segments == NULL)
       stream->segments = g_new (QtDemuxSegment, 1);
 
     /* represent unknown our way */
     if (stream_duration == 0)
-      stream_duration = -1;
+      stream_duration = GST_CLOCK_TIME_NONE;
 
     stream->segments[0].time = 0;
     stream->segments[0].stop_time = stream_duration;
@@ -6871,10 +7941,12 @@ done:
     stream->segments[0].media_start = 0;
     stream->segments[0].media_stop = stream_duration;
     stream->segments[0].rate = 1.0;
+    stream->segments[0].trak_media_start = 0;
 
     GST_DEBUG_OBJECT (qtdemux, "created dummy segment %" GST_TIME_FORMAT,
         GST_TIME_ARGS (stream_duration));
     stream->n_segments = 1;
+    stream->dummy_segment = TRUE;
   }
   GST_DEBUG_OBJECT (qtdemux, "using %d segments", stream->n_segments);
 
@@ -7069,14 +8141,6 @@ qtdemux_get_rtsp_uri_from_hndl (GstQTDemux * qtdemux, GNode * minf)
   return uri;
 }
 
-static gint
-less_than (gconstpointer a, gconstpointer b)
-{
-  const guint32 *av = a, *bv = b;
-
-  return *av - *bv;
-}
-
 #define AMR_NB_ALL_MODES        0x81ff
 #define AMR_WB_ALL_MODES        0x83ff
 static guint
@@ -7188,25 +8252,21 @@ qtdemux_inspect_transformation_matrix (GstQTDemux * qtdemux,
  * This macro will only compare value abdegh, it expects cfi to have already
  * been checked
  */
-#define QTCHECK_MATRIX(m,a,b,d,e,g,h) ((m)[0] == (a << 16) && (m)[1] == (b << 16) && \
-                                       (m)[3] == (d << 16) && (m)[4] == (e << 16) && \
-                                       (m)[6] == (g << 16) && (m)[7] == (h << 16))
+#define QTCHECK_MATRIX(m,a,b,d,e) ((m)[0] == (a << 16) && (m)[1] == (b << 16) && \
+                                   (m)[3] == (d << 16) && (m)[4] == (e << 16))
 
   /* only handle the cases where the last column has standard values */
   if (matrix[2] == 0 && matrix[5] == 0 && matrix[8] == 1 << 30) {
     const gchar *rotation_tag = NULL;
 
     /* no rotation needed */
-    if (QTCHECK_MATRIX (matrix, 1, 0, 0, 1, 0, 0)) {
+    if (QTCHECK_MATRIX (matrix, 1, 0, 0, 1)) {
       /* NOP */
-    } else if (QTCHECK_MATRIX (matrix, 0, 1, G_MAXUINT16, 0,
-            stream->display_height, 0)) {
+    } else if (QTCHECK_MATRIX (matrix, 0, 1, G_MAXUINT16, 0)) {
       rotation_tag = "rotate-90";
-    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16,
-            stream->display_width, stream->display_height)) {
+    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16)) {
       rotation_tag = "rotate-180";
-    } else if (QTCHECK_MATRIX (matrix, 0, G_MAXUINT16, 1, 0, 0,
-            stream->display_width)) {
+    } else if (QTCHECK_MATRIX (matrix, 0, G_MAXUINT16, 1, 0)) {
       rotation_tag = "rotate-270";
     } else {
       GST_FIXME_OBJECT (qtdemux, "Unhandled transformation matrix values");
@@ -7225,6 +8285,108 @@ qtdemux_inspect_transformation_matrix (GstQTDemux * qtdemux,
   }
 }
 
+/* Parses the boxes defined in ISO/IEC 14496-12 that enable support for
+ * protected streams (sinf, frma, schm and schi); if the protection scheme is
+ * Common Encryption (cenc), the function will also parse the tenc box (defined
+ * in ISO/IEC 23001-7). @container points to the node that contains these boxes
+ * (typically an enc[v|a|t|s] sample entry); the function will set
+ * @original_fmt to the fourcc of the original unencrypted stream format.
+ * Returns TRUE if successful; FALSE otherwise. */
+static gboolean
+qtdemux_parse_protection_scheme_info (GstQTDemux * qtdemux,
+    QtDemuxStream * stream, GNode * container, guint32 * original_fmt)
+{
+  GNode *sinf;
+  GNode *frma;
+  GNode *schm;
+  GNode *schi;
+
+  g_return_val_if_fail (qtdemux != NULL, FALSE);
+  g_return_val_if_fail (stream != NULL, FALSE);
+  g_return_val_if_fail (container != NULL, FALSE);
+  g_return_val_if_fail (original_fmt != NULL, FALSE);
+
+  sinf = qtdemux_tree_get_child_by_type (container, FOURCC_sinf);
+  if (G_UNLIKELY (!sinf)) {
+    if (stream->protection_scheme_type == FOURCC_cenc) {
+      GST_ERROR_OBJECT (qtdemux, "sinf box does not contain schi box, which is "
+          "mandatory for Common Encryption");
+      return FALSE;
+    }
+    return TRUE;
+  }
+
+  frma = qtdemux_tree_get_child_by_type (sinf, FOURCC_frma);
+  if (G_UNLIKELY (!frma)) {
+    GST_ERROR_OBJECT (qtdemux, "sinf box does not contain mandatory frma box");
+    return FALSE;
+  }
+
+  *original_fmt = QT_FOURCC ((const guint8 *) frma->data + 8);
+  GST_DEBUG_OBJECT (qtdemux, "original stream format: '%" GST_FOURCC_FORMAT "'",
+      GST_FOURCC_ARGS (*original_fmt));
+
+  schm = qtdemux_tree_get_child_by_type (sinf, FOURCC_schm);
+  if (!schm) {
+    GST_DEBUG_OBJECT (qtdemux, "sinf box does not contain schm box");
+    return FALSE;
+  }
+  stream->protection_scheme_type = QT_FOURCC ((const guint8 *) schm->data + 12);
+  stream->protection_scheme_version =
+      QT_UINT32 ((const guint8 *) schm->data + 16);
+
+  GST_DEBUG_OBJECT (qtdemux,
+      "protection_scheme_type: %" GST_FOURCC_FORMAT ", "
+      "protection_scheme_version: %#010x",
+      GST_FOURCC_ARGS (stream->protection_scheme_type),
+      stream->protection_scheme_version);
+
+  schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
+  if (!schi) {
+    GST_DEBUG_OBJECT (qtdemux, "sinf box does not contain schi box");
+    return FALSE;
+  }
+  if (stream->protection_scheme_type == FOURCC_cenc) {
+    QtDemuxCencSampleSetInfo *info;
+    GNode *tenc;
+    const guint8 *tenc_data;
+    guint32 isEncrypted;
+    guint8 iv_size;
+    const guint8 *default_kid;
+    GstBuffer *kid_buf;
+
+    if (G_UNLIKELY (!stream->protection_scheme_info))
+      stream->protection_scheme_info =
+          g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));
+
+    info = (QtDemuxCencSampleSetInfo *) stream->protection_scheme_info;
+
+    tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
+    if (!tenc) {
+      GST_ERROR_OBJECT (qtdemux, "schi box does not contain tenc box, "
+          "which is mandatory for Common Encryption");
+      return FALSE;
+    }
+    tenc_data = (const guint8 *) tenc->data + 12;
+    isEncrypted = QT_UINT24 (tenc_data);
+    iv_size = QT_UINT8 (tenc_data + 3);
+    default_kid = (tenc_data + 4);
+    kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);
+    gst_buffer_fill (kid_buf, 0, default_kid, 16);
+    if (info->default_properties)
+      gst_structure_free (info->default_properties);
+    info->default_properties =
+        gst_structure_new ("application/x-cenc",
+        "iv_size", G_TYPE_UINT, iv_size,
+        "encrypted", G_TYPE_BOOLEAN, (isEncrypted == 1),
+        "kid", GST_TYPE_BUFFER, kid_buf, NULL);
+    GST_DEBUG_OBJECT (qtdemux, "default sample properties: "
+        "is_encrypted=%u, iv_size=%u", isEncrypted, iv_size);
+    gst_buffer_unref (kid_buf);
+  }
+  return TRUE;
+}
+
 /* parse the traks.
  * With each track we associate a new QtDemuxStream that contains all the info
  * about the trak.
@@ -7247,10 +8409,11 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
   GNode *esds;
   GNode *pasp;
   GNode *tref;
+  GNode *udta;
+  GNode *svmi;
 
   QtDemuxStream *stream = NULL;
   gboolean new_stream = FALSE;
-  GstTagList *list = NULL;
   gchar *codec = NULL;
   const guint8 *stsd_data;
   guint16 lang_code;            /* quicktime lang code or packed iso code */
@@ -7286,8 +8449,15 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       GST_WARNING_OBJECT (qtdemux, "Stream not found, going to ignore it");
       goto skip_track;
     }
+
+    /* flush samples data from this track from previous moov */
+    gst_qtdemux_stream_flush_segments_data (qtdemux, stream);
+    gst_qtdemux_stream_flush_samples_data (qtdemux, stream);
   }
 
+  if (stream->pending_tags == NULL)
+    stream->pending_tags = gst_tag_list_new_empty ();
+
   if ((tkhd_flags & 1) == 0)
     stream->disabled = TRUE;
 
@@ -7321,8 +8491,10 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     lang_code = QT_UINT16 ((guint8 *) mdhd->data + 28);
   }
 
-  if (lang_code < 0x800) {
+  if (lang_code < 0x400) {
     qtdemux_lang_map_qt_code_to_iso (stream->lang_id, lang_code);
+  } else if (lang_code == 0x7fff) {
+    stream->lang_id[0] = 0;     /* unspecified */
   } else {
     stream->lang_id[0] = 0x60 + ((lang_code >> 10) & 0x1F);
     stream->lang_id[1] = 0x60 + ((lang_code >> 5) & 0x1F);
@@ -7375,7 +8547,8 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           "found, assuming preview image or something; skipping track",
           stream->duration, stream->timescale, qtdemux->duration,
           qtdemux->timescale);
-      g_free (stream);
+      if (new_stream)
+        gst_qtdemux_stream_free (qtdemux, stream);
       return TRUE;
     }
   }
@@ -7398,6 +8571,51 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
   if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
     goto corrupt_file;
 
+  /*parse svmi header if existing */
+  svmi = qtdemux_tree_get_child_by_type (stbl, FOURCC_svmi);
+  if (svmi) {
+    len = QT_UINT32 ((guint8 *) svmi->data);
+    version = QT_UINT32 ((guint8 *) svmi->data + 8);
+    if (!version) {
+      GstVideoMultiviewMode mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
+      GstVideoMultiviewFlags flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
+      guint8 frame_type, frame_layout;
+
+      /* MPEG-A stereo video */
+      if (qtdemux->major_brand == FOURCC_ss02)
+        flags |= GST_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO;
+
+      frame_type = QT_UINT8 ((guint8 *) svmi->data + 12);
+      frame_layout = QT_UINT8 ((guint8 *) svmi->data + 13) & 0x01;
+      switch (frame_type) {
+        case 0:
+          mode = GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE;
+          break;
+        case 1:
+          mode = GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED;
+          break;
+        case 2:
+          mode = GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME;
+          break;
+        case 3:
+          /* mode 3 is primary/secondary view sequence, ie
+           * left/right views in separate tracks. See section 7.2
+           * of ISO/IEC 23000-11:2009 */
+          GST_FIXME_OBJECT (qtdemux,
+              "Implement stereo video in separate streams");
+      }
+
+      if ((frame_layout & 0x1) == 0)
+        flags |= GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST;
+
+      GST_LOG_OBJECT (qtdemux,
+          "StereoVideo: composition type: %u, is_left_first: %u",
+          frame_type, frame_layout);
+      stream->multiview_mode = mode;
+      stream->multiview_flags = flags;
+    }
+  }
+
   /* parse stsd */
   if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
     goto corrupt_file;
@@ -7408,7 +8626,8 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
   if (stsd_len < 24) {
     /* .. but skip stream with empty stsd produced by some Vivotek cameras */
     if (stream->subtype == FOURCC_vivo) {
-      g_free (stream);
+      if (new_stream)
+        gst_qtdemux_stream_free (qtdemux, stream);
       return TRUE;
     } else {
       goto corrupt_file;
@@ -7427,10 +8646,16 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       GST_FOURCC_ARGS (stream->fourcc));
   GST_LOG_OBJECT (qtdemux, "stsd type len:      %d", len);
 
-  if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi) ||
-      ((fourcc & 0x00FFFFFF) == GST_MAKE_FOURCC ('e', 'n', 'c', 0)))
+  if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
     goto error_encrypted;
 
+  if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
+    GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
+    stream->protected = TRUE;
+    if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &fourcc))
+      GST_ERROR_OBJECT (qtdemux, "Failed to parse protection scheme info");
+  }
+
   if (stream->subtype == FOURCC_vide) {
     guint32 w = 0, h = 0;
     gboolean gray;
@@ -7454,7 +8679,8 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     stream->display_width = w >> 16;
     stream->display_height = h >> 16;
 
-    qtdemux_inspect_transformation_matrix (qtdemux, stream, matrix, &list);
+    qtdemux_inspect_transformation_matrix (qtdemux, stream, matrix,
+        &stream->pending_tags);
 
     offset = 16;
     if (len < 86)
@@ -7551,6 +8777,9 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       }
     }
 
+    if (stream->caps)
+      gst_caps_unref (stream->caps);
+
     stream->caps =
         qtdemux_video_caps (qtdemux, stream, fourcc, stsd_data, &codec);
     if (G_UNLIKELY (!stream->caps)) {
@@ -7559,9 +8788,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     }
 
     if (codec) {
-      if (list == NULL)
-        list = gst_tag_list_new_empty ();
-      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
           GST_TAG_VIDEO_CODEC, codec, NULL);
       g_free (codec);
       codec = NULL;
@@ -7603,7 +8830,11 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     esds = NULL;
     pasp = NULL;
     /* pick 'the' stsd child */
-    mp4v = qtdemux_tree_get_child_by_type (stsd, fourcc);
+    if (!stream->protected)
+      mp4v = qtdemux_tree_get_child_by_type (stsd, fourcc);
+    else
+      mp4v = qtdemux_tree_get_child_by_type (stsd, FOURCC_encv);
+
     if (mp4v) {
       esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);
       pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);
@@ -7620,7 +8851,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     }
 
     if (esds) {
-      gst_qtdemux_handle_esds (qtdemux, stream, esds, list);
+      gst_qtdemux_handle_esds (qtdemux, stream, esds, stream->pending_tags);
     } else {
       switch (fourcc) {
         case FOURCC_H264:
@@ -7711,15 +8942,12 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
                   max_bitrate = temp;
                 }
 
-                if (!list)
-                  list = gst_tag_list_new_empty ();
-
                 if (max_bitrate > 0 && max_bitrate < G_MAXUINT32) {
-                  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+                  gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
                       GST_TAG_MAXIMUM_BITRATE, max_bitrate, NULL);
                 }
                 if (avg_bitrate > 0 && avg_bitrate < G_MAXUINT32) {
-                  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+                  gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
                       GST_TAG_BITRATE, avg_bitrate, NULL);
                 }
 
@@ -8079,6 +9307,45 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           gst_buffer_unref (buf);
           break;
         }
+        case GST_MAKE_FOURCC ('v', 'c', '-', '1'):
+        {
+          gint len = QT_UINT32 (stsd_data) - 0x66;
+          const guint8 *vc1_data = stsd_data + 0x66;
+
+          /* find dvc1 */
+          while (len >= 8) {
+            gint size;
+
+            if (QT_UINT32 (vc1_data) <= len)
+              size = QT_UINT32 (vc1_data) - 8;
+            else
+              size = len - 8;
+
+            if (size < 1)
+              /* No real data, so break out */
+              break;
+
+            switch (QT_FOURCC (vc1_data + 0x4)) {
+              case GST_MAKE_FOURCC ('d', 'v', 'c', '1'):
+              {
+                GstBuffer *buf;
+
+                GST_DEBUG_OBJECT (qtdemux, "found dvc1 codec_data in stsd");
+                buf = gst_buffer_new_and_alloc (size);
+                gst_buffer_fill (buf, 0, vc1_data + 8, size);
+                gst_caps_set_simple (stream->caps,
+                    "codec_data", GST_TYPE_BUFFER, buf, NULL);
+                gst_buffer_unref (buf);
+                break;
+              }
+              default:
+                break;
+            }
+            len -= size + 8;
+            vc1_data += size + 8;
+          }
+          break;
+        }
         default:
           break;
       }
@@ -8243,6 +9510,9 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       GST_WARNING_OBJECT (qtdemux, "unknown audio STSD version %08x", version);
     }
 
+    if (stream->caps)
+      gst_caps_unref (stream->caps);
+
     stream->caps = qtdemux_audio_caps (qtdemux, stream, fourcc,
         stsd_data + 32, len - 16, &codec);
 
@@ -8332,6 +9602,113 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
         }
         break;
       }
+      case GST_MAKE_FOURCC ('w', 'm', 'a', ' '):
+      {
+        gint len = QT_UINT32 (stsd_data) - offset;
+        const guint8 *wfex_data = stsd_data + offset;
+        const gchar *codec_name = NULL;
+        gint version = 1;
+        /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */
+        /* FIXME this should also be gst_riff_strf_auds,
+         * but the latter one is actually missing bits-per-sample :( */
+        typedef struct
+        {
+          gint16 wFormatTag;
+          gint16 nChannels;
+          gint32 nSamplesPerSec;
+          gint32 nAvgBytesPerSec;
+          gint16 nBlockAlign;
+          gint16 wBitsPerSample;
+          gint16 cbSize;
+        } WAVEFORMATEX;
+        WAVEFORMATEX wfex;
+
+        /* FIXME: unify with similar wavformatex parsing code above */
+        GST_DEBUG_OBJECT (qtdemux, "parse wma, looking for wfex");
+
+        /* find wfex */
+        while (len >= 8) {
+          gint size;
+
+          if (QT_UINT32 (wfex_data) <= len)
+            size = QT_UINT32 (wfex_data) - 8;
+          else
+            size = len - 8;
+
+          if (size < 1)
+            /* No real data, so break out */
+            break;
+
+          switch (QT_FOURCC (wfex_data + 4)) {
+            case GST_MAKE_FOURCC ('w', 'f', 'e', 'x'):
+            {
+              GST_DEBUG_OBJECT (qtdemux, "found wfex in stsd");
+
+              if (size < 8 + 18)
+                break;
+
+              wfex.wFormatTag = GST_READ_UINT16_LE (wfex_data + 8 + 0);
+              wfex.nChannels = GST_READ_UINT16_LE (wfex_data + 8 + 2);
+              wfex.nSamplesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 4);
+              wfex.nAvgBytesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 8);
+              wfex.nBlockAlign = GST_READ_UINT16_LE (wfex_data + 8 + 12);
+              wfex.wBitsPerSample = GST_READ_UINT16_LE (wfex_data + 8 + 14);
+              wfex.cbSize = GST_READ_UINT16_LE (wfex_data + 8 + 16);
+
+              GST_LOG_OBJECT (qtdemux, "Found wfex box in stsd:");
+              GST_LOG_OBJECT (qtdemux, "FormatTag = 0x%04x, Channels = %u, "
+                  "SamplesPerSec = %u, AvgBytesPerSec = %u, BlockAlign = %u, "
+                  "BitsPerSample = %u, Size = %u", wfex.wFormatTag,
+                  wfex.nChannels, wfex.nSamplesPerSec, wfex.nAvgBytesPerSec,
+                  wfex.nBlockAlign, wfex.wBitsPerSample, wfex.cbSize);
+
+              if (wfex.wFormatTag == 0x0161) {
+                codec_name = "Windows Media Audio";
+                version = 2;
+              } else if (wfex.wFormatTag == 0x0162) {
+                codec_name = "Windows Media Audio 9 Pro";
+                version = 3;
+              } else if (wfex.wFormatTag == 0x0163) {
+                codec_name = "Windows Media Audio 9 Lossless";
+                /* is that correct? gstffmpegcodecmap.c is missing it, but
+                 * fluendo codec seems to support it */
+                version = 4;
+              }
+
+              gst_caps_set_simple (stream->caps,
+                  "wmaversion", G_TYPE_INT, version,
+                  "block_align", G_TYPE_INT, wfex.nBlockAlign,
+                  "bitrate", G_TYPE_INT, wfex.nAvgBytesPerSec,
+                  "width", G_TYPE_INT, wfex.wBitsPerSample,
+                  "depth", G_TYPE_INT, wfex.wBitsPerSample, NULL);
+
+              if (size > wfex.cbSize) {
+                GstBuffer *buf;
+
+                buf = gst_buffer_new_and_alloc (size - wfex.cbSize);
+                gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,
+                    size - wfex.cbSize);
+                gst_caps_set_simple (stream->caps,
+                    "codec_data", GST_TYPE_BUFFER, buf, NULL);
+                gst_buffer_unref (buf);
+              } else {
+                GST_WARNING_OBJECT (qtdemux, "no codec data");
+              }
+
+              if (codec_name) {
+                g_free (codec);
+                codec = g_strdup (codec_name);
+              }
+              break;
+            }
+            default:
+              break;
+          }
+          len -= size + 8;
+          wfex_data += size + 8;
+        }
+        break;
+      }
       default:
         break;
     }
@@ -8340,9 +9717,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       GstStructure *s;
       gint bitrate = 0;
 
-      if (list == NULL)
-        list = gst_tag_list_new_empty ();
-      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
           GST_TAG_AUDIO_CODEC, codec, NULL);
       g_free (codec);
       codec = NULL;
@@ -8351,11 +9726,15 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       s = gst_caps_get_structure (stream->caps, 0);
       gst_structure_get_int (s, "bitrate", &bitrate);
       if (bitrate > 0)
-        gst_tag_list_add (list, GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE,
-            bitrate, NULL);
+        gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
+            GST_TAG_BITRATE, bitrate, NULL);
     }
 
-    mp4a = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4a);
+    if (stream->protected && fourcc == FOURCC_mp4a)
+      mp4a = qtdemux_tree_get_child_by_type (stsd, FOURCC_enca);
+    else
+      mp4a = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4a);
+
     wave = NULL;
     esds = NULL;
     if (mp4a) {
@@ -8422,7 +9801,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
         g_node_destroy (wavenode);
       }
     } else if (esds) {
-      gst_qtdemux_handle_esds (qtdemux, stream, esds, list);
+      gst_qtdemux_handle_esds (qtdemux, stream, esds, stream->pending_tags);
     } else {
       switch (fourcc) {
 #if 0
@@ -8509,9 +9888,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
              * the 3GPP container spec (26.244) for more details. */
             if ((len - 0x34) > 8 &&
                 (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {
-              if (!list)
-                list = gst_tag_list_new_empty ();
-              gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+              gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
                   GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);
             }
 
@@ -8521,6 +9898,39 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           }
           break;
         }
+        case FOURCC_mp4a:
+        {
+          /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
+          gint len = QT_UINT32 (stsd_data);
+
+          if (len >= 50) {
+            guint16 sound_version = QT_UINT16 (stsd_data + 32);
+
+            if (sound_version == 1) {
+              guint16 channels = QT_UINT16 (stsd_data + 40);
+              guint32 time_scale = QT_UINT32 (stsd_data + 46);
+              guint8 codec_data[2];
+              GstBuffer *buf;
+              gint profile = 2; /* FIXME: Can this be determined somehow? There doesn't seem to be anything in mp4a atom that specifis compression */
+
+              gint sample_rate_index =
+                  gst_codec_utils_aac_get_index_from_sample_rate (time_scale);
+
+              /* build AAC codec data */
+              codec_data[0] = profile << 3;
+              codec_data[0] |= ((sample_rate_index >> 1) & 0x7);
+              codec_data[1] = (sample_rate_index & 0x01) << 7;
+              codec_data[1] |= (channels & 0xF) << 3;
+
+              buf = gst_buffer_new_and_alloc (2);
+              gst_buffer_fill (buf, 0, codec_data, 2);
+              gst_caps_set_simple (stream->caps,
+                  "codec_data", GST_TYPE_BUFFER, buf, NULL);
+              gst_buffer_unref (buf);
+            }
+          }
+          break;
+        }
         default:
           GST_INFO_OBJECT (qtdemux,
               "unhandled type %" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
@@ -8541,18 +9951,15 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     }
     stream->sampled = TRUE;
   } else if (stream->subtype == FOURCC_subp || stream->subtype == FOURCC_text
-      || stream->subtype == FOURCC_sbtl) {
+      || stream->subtype == FOURCC_sbtl || stream->subtype == FOURCC_subt) {
 
     stream->sampled = TRUE;
     stream->sparse = TRUE;
 
-    offset = 16;
-
     stream->caps =
         qtdemux_sub_caps (qtdemux, stream, fourcc, stsd_data, &codec);
     if (codec) {
-      list = gst_tag_list_new_empty ();
-      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
           GST_TAG_SUBTITLE_CODEC, codec, NULL);
       g_free (codec);
       codec = NULL;
@@ -8575,7 +9982,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           break;
         }
 
-        gst_qtdemux_handle_esds (qtdemux, stream, esds, list);
+        gst_qtdemux_handle_esds (qtdemux, stream, esds, stream->pending_tags);
         break;
       }
       default:
@@ -8597,8 +10004,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       goto unknown_stream;
 
     if (codec) {
-      list = gst_tag_list_new_empty ();
-      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
           GST_TAG_SUBTITLE_CODEC, codec, NULL);
       g_free (codec);
       codec = NULL;
@@ -8641,8 +10047,8 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     /* movie duration more reliable in this case (e.g. mehd) */
     if (qtdemux->segment.duration &&
         GST_CLOCK_TIME_IS_VALID (qtdemux->segment.duration))
-      stream->duration = gst_util_uint64_scale (qtdemux->segment.duration,
-          stream->timescale, GST_SECOND);
+      stream->duration =
+          GSTTIME_TO_QTSTREAMTIME (stream, qtdemux->segment.duration);
     /* need defaults for fragments */
     qtdemux_parse_trex (qtdemux, stream, &dummy, &dummy, &dummy);
   }
@@ -8656,21 +10062,22 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       strcmp (stream->lang_id, "und")) {
     const gchar *lang_code;
 
-    if (!list)
-      list = gst_tag_list_new_empty ();
-
     /* convert ISO 639-2 code to ISO 639-1 */
     lang_code = gst_tag_get_language_code (stream->lang_id);
-    gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (stream->pending_tags, GST_TAG_MERGE_REPLACE,
         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream->lang_id, NULL);
   }
 
+  /* Check for UDTA tags */
+  if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
+    qtdemux_parse_udta (qtdemux, stream->pending_tags, udta);
+  }
+
   /* now we are ready to add the stream */
   if (qtdemux->n_streams >= GST_QTDEMUX_MAX_STREAMS)
     goto too_many_streams;
 
   if (!qtdemux->got_moov) {
-    stream->pending_tags = list;
     qtdemux->streams[qtdemux->n_streams] = stream;
     qtdemux->n_streams++;
     GST_DEBUG_OBJECT (qtdemux, "n_streams is now %d", qtdemux->n_streams);
@@ -8683,7 +10090,7 @@ skip_track:
   {
     GST_INFO_OBJECT (qtdemux, "skip disabled track");
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return TRUE;
   }
 corrupt_file:
@@ -8691,14 +10098,14 @@ corrupt_file:
     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
         (_("This file is corrupt and cannot be played.")), (NULL));
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return FALSE;
   }
 error_encrypted:
   {
     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return FALSE;
   }
 samples_failed:
@@ -8708,7 +10115,7 @@ segments_failed:
     /* free stbl sub-atoms */
     gst_qtdemux_stbl_free (stream);
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return FALSE;
   }
 existing_stream:
@@ -8716,7 +10123,7 @@ existing_stream:
     GST_INFO_OBJECT (qtdemux, "stream with track id %i already exists",
         track_id);
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return TRUE;
   }
 unknown_stream:
@@ -8724,7 +10131,7 @@ unknown_stream:
     GST_INFO_OBJECT (qtdemux, "unknown subtype %" GST_FOURCC_FORMAT,
         GST_FOURCC_ARGS (stream->subtype));
     if (new_stream)
-      g_free (stream);
+      gst_qtdemux_stream_free (qtdemux, stream);
     return TRUE;
   }
 too_many_streams:
@@ -8745,7 +10152,8 @@ static void
 gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
 {
   QtDemuxStream *stream = NULL;
-  gint64 size, duration, sys_bitrate, sum_bitrate = 0;
+  gint64 size, sys_bitrate, sum_bitrate = 0;
+  GstClockTime duration;
   gint i;
   guint bitrate;
 
@@ -8849,8 +10257,6 @@ qtdemux_prepare_streams (GstQTDemux * qtdemux)
   for (i = 0; ret == GST_FLOW_OK && i < qtdemux->n_streams; i++) {
     QtDemuxStream *stream = qtdemux->streams[i];
     guint32 sample_num = 0;
-    guint samples = 20;
-    GArray *durations;
 
     GST_DEBUG_OBJECT (qtdemux, "stream %d, id %d, fourcc %" GST_FOURCC_FORMAT,
         i, stream->track_id, GST_FOURCC_ARGS (stream->fourcc));
@@ -8881,25 +10287,16 @@ qtdemux_prepare_streams (GstQTDemux * qtdemux)
       continue;
     }
 
-    /* parse number of initial sample to set frame rate cap */
-    while (sample_num < stream->n_samples && sample_num < samples) {
+    /* parse the initial sample for use in setting the frame rate cap */
+    while (sample_num == 0 && sample_num < stream->n_samples) {
       if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
         break;
       ++sample_num;
     }
-    /* collect and sort durations */
-    samples = MIN (stream->stbl_index + 1, samples);
-    GST_DEBUG_OBJECT (qtdemux, "%d samples for framerate", samples);
-    if (samples) {
-      durations = g_array_sized_new (FALSE, FALSE, sizeof (guint32), samples);
-      sample_num = 0;
-      while (sample_num < samples) {
-        g_array_append_val (durations, stream->samples[sample_num].duration);
-        sample_num++;
-      }
-      g_array_sort (durations, less_than);
-      stream->min_duration = g_array_index (durations, guint32, samples / 2);
-      g_array_free (durations, TRUE);
+    if (stream->n_samples > 0 && stream->stbl_index >= 0) {
+      stream->first_duration = stream->samples[0].duration;
+      GST_LOG_OBJECT (qtdemux, "stream %d first duration %u",
+          stream->track_id, stream->first_duration);
     }
   }
 
@@ -9019,8 +10416,8 @@ qtdemux_is_string_tag_3gp (GstQTDemux * qtdemux, guint32 fourcc)
 }
 
 static void
-qtdemux_tag_add_location (GstQTDemux * qtdemux, const char *tag,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_location (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   const gchar *env_vars[] = { "GST_QT_TAG_ENCODING", "GST_TAG_ENCODING", NULL };
   int offset;
@@ -9047,7 +10444,7 @@ qtdemux_tag_add_location (GstQTDemux * qtdemux, const char *tag,
           "giving up", tag);
     }
   } else {
-    gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE,
         GST_TAG_GEO_LOCATION_NAME, name, NULL);
     offset += strlen (name);
     g_free (name);
@@ -9070,7 +10467,7 @@ qtdemux_tag_add_location (GstQTDemux * qtdemux, const char *tag,
   /* one invalid means all are invalid */
   if (longitude >= -180.0 && longitude <= 180.0 &&
       latitude >= -90.0 && latitude <= 90.0) {
-    gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
+    gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE,
         GST_TAG_GEO_LOCATION_LATITUDE, latitude,
         GST_TAG_GEO_LOCATION_LONGITUDE, longitude,
         GST_TAG_GEO_LOCATION_ELEVATION, altitude, NULL);
@@ -9090,8 +10487,8 @@ short_read:
 
 
 static void
-qtdemux_tag_add_year (GstQTDemux * qtdemux, const char *tag, const char *dummy,
-    GNode * node)
+qtdemux_tag_add_year (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   guint16 y;
   GDate *date;
@@ -9109,13 +10506,13 @@ qtdemux_tag_add_year (GstQTDemux * qtdemux, const char *tag, const char *dummy,
   GST_DEBUG_OBJECT (qtdemux, "year: %u", y);
 
   date = g_date_new_dmy (1, 1, y);
-  gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE, tag, date, NULL);
+  gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
   g_date_free (date);
 }
 
 static void
-qtdemux_tag_add_classification (GstQTDemux * qtdemux, const char *tag,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_classification (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   int offset;
   char *tag_str = NULL;
@@ -9154,8 +10551,7 @@ qtdemux_tag_add_classification (GstQTDemux * qtdemux, const char *tag,
   memcpy (tag_str, entity, 4);
   GST_DEBUG_OBJECT (qtdemux, "classification info: %s", tag_str);
 
-  gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_APPEND, tag,
-      tag_str, NULL);
+  gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND, tag, tag_str, NULL);
 
   g_free (tag_str);
 
@@ -9170,8 +10566,8 @@ short_read:
 }
 
 static gboolean
-qtdemux_tag_add_str_full (GstQTDemux * qtdemux, const char *tag,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_str_full (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   const gchar *env_vars[] = { "GST_QT_TAG_ENCODING", "GST_TAG_ENCODING", NULL };
   GNode *data;
@@ -9191,8 +10587,7 @@ qtdemux_tag_add_str_full (GstQTDemux * qtdemux, const char *tag,
           env_vars);
       if (s) {
         GST_DEBUG_OBJECT (qtdemux, "adding tag %s", GST_STR_NULL (s));
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE, tag, s,
-            NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
         g_free (s);
       } else {
         GST_DEBUG_OBJECT (qtdemux, "failed to convert %s tag to UTF-8", tag);
@@ -9264,7 +10659,7 @@ qtdemux_tag_add_str_full (GstQTDemux * qtdemux, const char *tag,
     }
     if (s) {
       GST_DEBUG_OBJECT (qtdemux, "adding tag %s", GST_STR_NULL (s));
-      gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE, tag, s, NULL);
+      gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
       g_free (s);
       ret = TRUE;
     } else {
@@ -9275,15 +10670,15 @@ qtdemux_tag_add_str_full (GstQTDemux * qtdemux, const char *tag,
 }
 
 static void
-qtdemux_tag_add_str (GstQTDemux * qtdemux, const char *tag,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_str (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
-  qtdemux_tag_add_str_full (qtdemux, tag, dummy, node);
+  qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node);
 }
 
 static void
-qtdemux_tag_add_keywords (GstQTDemux * qtdemux, const char *tag,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_keywords (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   const gchar *env_vars[] = { "GST_QT_TAG_ENCODING", "GST_TAG_ENCODING", NULL };
   guint8 *data;
@@ -9294,7 +10689,7 @@ qtdemux_tag_add_keywords (GstQTDemux * qtdemux, const char *tag,
 
   /* first try normal string tag if major brand not 3GP */
   if (!qtdemux_is_brand_3gp (qtdemux, TRUE)) {
-    if (!qtdemux_tag_add_str_full (qtdemux, tag, dummy, node)) {
+    if (!qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node)) {
       /* hm, that did not work, maybe 3gpp storage in non-3gpp major brand;
        * let's try it 3gpp way after minor safety check */
       data = node->data;
@@ -9344,7 +10739,7 @@ qtdemux_tag_add_keywords (GstQTDemux * qtdemux, const char *tag,
 done:
   if (k) {
     GST_DEBUG_OBJECT (qtdemux, "adding tag %s", GST_STR_NULL (k));
-    gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE, tag, k, NULL);
+    gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, k, NULL);
   }
   g_free (k);
 
@@ -9359,8 +10754,8 @@ short_read:
 }
 
 static void
-qtdemux_tag_add_num (GstQTDemux * qtdemux, const char *tag1,
-    const char *tag2, GNode * node)
+qtdemux_tag_add_num (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag1, const char *tag2, GNode * node)
 {
   GNode *data;
   int len;
@@ -9376,21 +10771,19 @@ qtdemux_tag_add_num (GstQTDemux * qtdemux, const char *tag1,
       n2 = QT_UINT16 ((guint8 *) data->data + 20);
       if (n1 > 0) {
         GST_DEBUG_OBJECT (qtdemux, "adding tag %s=%d", tag1, n1);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-            tag1, n1, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, n1, NULL);
       }
       if (n2 > 0) {
         GST_DEBUG_OBJECT (qtdemux, "adding tag %s=%d", tag2, n2);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-            tag2, n2, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag2, n2, NULL);
       }
     }
   }
 }
 
 static void
-qtdemux_tag_add_tmpo (GstQTDemux * qtdemux, const char *tag1, const char *dummy,
-    GNode * node)
+qtdemux_tag_add_tmpo (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag1, const char *dummy, GNode * node)
 {
   GNode *data;
   int len;
@@ -9408,16 +10801,16 @@ qtdemux_tag_add_tmpo (GstQTDemux * qtdemux, const char *tag1, const char *dummy,
       if (n1) {
         /* do not add bpm=0 */
         GST_DEBUG_OBJECT (qtdemux, "adding tag %d", n1);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-            tag1, (gdouble) n1, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, (gdouble) n1,
+            NULL);
       }
     }
   }
 }
 
 static void
-qtdemux_tag_add_uint32 (GstQTDemux * qtdemux, const char *tag1,
-    const char *dummy, GNode * node)
+qtdemux_tag_add_uint32 (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag1, const char *dummy, GNode * node)
 {
   GNode *data;
   int len;
@@ -9435,16 +10828,15 @@ qtdemux_tag_add_uint32 (GstQTDemux * qtdemux, const char *tag1,
       if (num) {
         /* do not add num=0 */
         GST_DEBUG_OBJECT (qtdemux, "adding tag %d", num);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-            tag1, num, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, num, NULL);
       }
     }
   }
 }
 
 static void
-qtdemux_tag_add_covr (GstQTDemux * qtdemux, const char *tag1, const char *dummy,
-    GNode * node)
+qtdemux_tag_add_covr (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag1, const char *dummy, GNode * node)
 {
   GNode *data;
   int len;
@@ -9461,8 +10853,7 @@ qtdemux_tag_add_covr (GstQTDemux * qtdemux, const char *tag1, const char *dummy,
               gst_tag_image_data_to_image_sample ((guint8 *) data->data + 16,
                   len - 16, GST_TAG_IMAGE_TYPE_NONE))) {
         GST_DEBUG_OBJECT (qtdemux, "adding tag size %d", len - 16);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-            tag1, sample, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, sample, NULL);
         gst_sample_unref (sample);
       }
     }
@@ -9470,8 +10861,8 @@ qtdemux_tag_add_covr (GstQTDemux * qtdemux, const char *tag1, const char *dummy,
 }
 
 static void
-qtdemux_tag_add_date (GstQTDemux * qtdemux, const char *tag, const char *dummy,
-    GNode * node)
+qtdemux_tag_add_date (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   GNode *data;
   char *s;
@@ -9493,8 +10884,7 @@ qtdemux_tag_add_date (GstQTDemux * qtdemux, const char *tag, const char *dummy,
         GDate *date;
 
         date = g_date_new_dmy (d, m, y);
-        gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE, tag,
-            date, NULL);
+        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
         g_date_free (date);
       } else {
         GST_DEBUG_OBJECT (qtdemux, "could not parse date string '%s'", s);
@@ -9505,8 +10895,8 @@ qtdemux_tag_add_date (GstQTDemux * qtdemux, const char *tag, const char *dummy,
 }
 
 static void
-qtdemux_tag_add_gnre (GstQTDemux * qtdemux, const char *tag, const char *dummy,
-    GNode * node)
+qtdemux_tag_add_gnre (GstQTDemux * qtdemux, GstTagList * taglist,
+    const char *tag, const char *dummy, GNode * node)
 {
   GNode *data;
 
@@ -9516,7 +10906,7 @@ qtdemux_tag_add_gnre (GstQTDemux * qtdemux, const char *tag, const char *dummy,
    * or no data atom and compatible brand suggests so */
   if (qtdemux_is_brand_3gp (qtdemux, TRUE) ||
       (qtdemux_is_brand_3gp (qtdemux, FALSE) && !data)) {
-    qtdemux_tag_add_str (qtdemux, tag, dummy, node);
+    qtdemux_tag_add_str (qtdemux, taglist, tag, dummy, node);
     return;
   }
 
@@ -9533,8 +10923,7 @@ qtdemux_tag_add_gnre (GstQTDemux * qtdemux, const char *tag, const char *dummy,
         genre = gst_tag_id3_genre_get (n - 1);
         if (genre != NULL) {
           GST_DEBUG_OBJECT (qtdemux, "adding %d [%s]", n, genre);
-          gst_tag_list_add (qtdemux->tag_list, GST_TAG_MERGE_REPLACE,
-              tag, genre, NULL);
+          gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, genre, NULL);
         }
       }
     }
@@ -9542,8 +10931,8 @@ qtdemux_tag_add_gnre (GstQTDemux * qtdemux, const char *tag, const char *dummy,
 }
 
 static void
-qtdemux_add_double_tag_from_str (GstQTDemux * demux, const gchar * tag,
-    guint8 * data, guint32 datasize)
+qtdemux_add_double_tag_from_str (GstQTDemux * demux, GstTagList * taglist,
+    const gchar * tag, guint8 * data, guint32 datasize)
 {
   gdouble value;
   gchar *datacopy;
@@ -9554,7 +10943,7 @@ qtdemux_add_double_tag_from_str (GstQTDemux * demux, const gchar * tag,
   /* convert the str to double */
   if (sscanf (datacopy, "%lf", &value) == 1) {
     GST_DEBUG_OBJECT (demux, "adding tag: %s [%s]", tag, datacopy);
-    gst_tag_list_add (demux->tag_list, GST_TAG_MERGE_REPLACE, tag, value, NULL);
+    gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, value, NULL);
   } else {
     GST_WARNING_OBJECT (demux, "Failed to parse double from string: %s",
         datacopy);
@@ -9564,8 +10953,8 @@ qtdemux_add_double_tag_from_str (GstQTDemux * demux, const gchar * tag,
 
 
 static void
-qtdemux_tag_add_revdns (GstQTDemux * demux, const char *tag,
-    const char *tag_bis, GNode * node)
+qtdemux_tag_add_revdns (GstQTDemux * demux, GstTagList * taglist,
+    const char *tag, const char *tag_bis, GNode * node)
 {
   GNode *mean;
   GNode *name;
@@ -9655,11 +11044,11 @@ qtdemux_tag_add_revdns (GstQTDemux * demux, const char *tag,
       if (!g_ascii_strncasecmp (tags[i].name, namestr, namesize)) {
         switch (gst_tag_get_type (tags[i].tag)) {
           case G_TYPE_DOUBLE:
-            qtdemux_add_double_tag_from_str (demux, tags[i].tag,
+            qtdemux_add_double_tag_from_str (demux, taglist, tags[i].tag,
                 ((guint8 *) data->data) + 16, datasize - 16);
             break;
           case G_TYPE_STRING:
-            qtdemux_tag_add_str (demux, tags[i].tag, NULL, node);
+            qtdemux_tag_add_str (demux, taglist, tags[i].tag, NULL, node);
             break;
           default:
             /* not reached */
@@ -9697,13 +11086,13 @@ unknown_tag:
 }
 
 static void
-qtdemux_tag_add_id32 (GstQTDemux * demux, const char *tag,
+qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
     const char *tag_bis, GNode * node)
 {
   guint8 *data;
   GstBuffer *buf;
   guint len;
-  GstTagList *taglist = NULL;
+  GstTagList *id32_taglist = NULL;
 
   GST_LOG_OBJECT (demux, "parsing ID32");
 
@@ -9717,21 +11106,19 @@ qtdemux_tag_add_id32 (GstQTDemux * demux, const char *tag,
   buf = gst_buffer_new_allocate (NULL, len - 14, NULL);
   gst_buffer_fill (buf, 0, data + 14, len - 14);
 
-  taglist = gst_tag_list_from_id3v2_tag (buf);
-  if (taglist) {
+  id32_taglist = gst_tag_list_from_id3v2_tag (buf);
+  if (id32_taglist) {
     GST_LOG_OBJECT (demux, "parsing ok");
-    gst_tag_list_insert (demux->tag_list, taglist, GST_TAG_MERGE_KEEP);
+    gst_tag_list_insert (taglist, id32_taglist, GST_TAG_MERGE_KEEP);
+    gst_tag_list_unref (id32_taglist);
   } else {
     GST_LOG_OBJECT (demux, "parsing failed");
   }
 
-  if (taglist)
-    gst_tag_list_unref (taglist);
-
   gst_buffer_unref (buf);
 }
 
-typedef void (*GstQTDemuxAddTagFunc) (GstQTDemux * demux,
+typedef void (*GstQTDemuxAddTagFunc) (GstQTDemux * demux, GstTagList * taglist,
     const char *tag, const char *tag_bis, GNode * node);
 
 /* unmapped tags
@@ -9808,8 +11195,15 @@ static const struct
   FOURCC_ID32, "", NULL, qtdemux_tag_add_id32}
 };
 
+struct _GstQtDemuxTagList
+{
+  GstQTDemux *demux;
+  GstTagList *taglist;
+};
+typedef struct _GstQtDemuxTagList GstQtDemuxTagList;
+
 static void
-qtdemux_tag_add_blob (GNode * node, GstQTDemux * demux)
+qtdemux_tag_add_blob (GNode * node, GstQtDemuxTagList * qtdemuxtaglist)
 {
   gint len;
   guint8 *data;
@@ -9820,6 +11214,8 @@ qtdemux_tag_add_blob (GNode * node, GstQTDemux * demux)
   GstStructure *s;
   guint i;
   guint8 ndata[4];
+  GstQTDemux *demux = qtdemuxtaglist->demux;
+  GstTagList *taglist = qtdemuxtaglist->taglist;
 
   data = node->data;
   len = QT_UINT32 (data);
@@ -9857,20 +11253,24 @@ qtdemux_tag_add_blob (GNode * node, GstQTDemux * demux)
   GST_DEBUG_OBJECT (demux, "adding private tag; size %d, info %" GST_PTR_FORMAT,
       len, s);
 
-  gst_tag_list_add (demux->tag_list, GST_TAG_MERGE_APPEND,
+  gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND,
       GST_QT_DEMUX_PRIVATE_TAG, sample, NULL);
 
   gst_sample_unref (sample);
 }
 
 static void
-qtdemux_parse_udta (GstQTDemux * qtdemux, GNode * udta)
+qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist, GNode * udta)
 {
   GNode *meta;
   GNode *ilst;
   GNode *xmp_;
   GNode *node;
   gint i;
+  GstQtDemuxTagList demuxtaglist;
+
+  demuxtaglist.demux = qtdemux;
+  demuxtaglist.taglist = taglist;
 
   meta = qtdemux_tree_get_child_by_type (udta, FOURCC_meta);
   if (meta != NULL) {
@@ -9884,14 +11284,6 @@ qtdemux_parse_udta (GstQTDemux * qtdemux, GNode * udta)
     GST_LOG_OBJECT (qtdemux, "no meta so using udta itself");
   }
 
-  GST_DEBUG_OBJECT (qtdemux, "new tag list");
-  if (!qtdemux->tag_list) {
-    qtdemux->tag_list = gst_tag_list_new_empty ();
-    gst_tag_list_set_scope (qtdemux->tag_list, GST_TAG_SCOPE_GLOBAL);
-  } else {
-    qtdemux->tag_list = gst_tag_list_make_writable (qtdemux->tag_list);
-  }
-
   i = 0;
   while (i < G_N_ELEMENTS (add_funcs)) {
     node = qtdemux_tree_get_child_by_type (ilst, add_funcs[i].fourcc);
@@ -9903,7 +11295,7 @@ qtdemux_parse_udta (GstQTDemux * qtdemux, GNode * udta)
         GST_DEBUG_OBJECT (qtdemux, "too small tag atom %" GST_FOURCC_FORMAT,
             GST_FOURCC_ARGS (add_funcs[i].fourcc));
       } else {
-        add_funcs[i].func (qtdemux, add_funcs[i].gst_tag,
+        add_funcs[i].func (qtdemux, taglist, add_funcs[i].gst_tag,
             add_funcs[i].gst_tag_bis, node);
       }
       g_node_destroy (node);
@@ -9914,24 +11306,23 @@ qtdemux_parse_udta (GstQTDemux * qtdemux, GNode * udta)
 
   /* parsed nodes have been removed, pass along remainder as blob */
   g_node_children_foreach (ilst, G_TRAVERSE_ALL,
-      (GNodeForeachFunc) qtdemux_tag_add_blob, qtdemux);
+      (GNodeForeachFunc) qtdemux_tag_add_blob, &demuxtaglist);
 
   /* parse up XMP_ node if existing */
   xmp_ = qtdemux_tree_get_child_by_type (udta, FOURCC_XMP_);
   if (xmp_ != NULL) {
     GstBuffer *buf;
-    GstTagList *taglist;
+    GstTagList *xmptaglist;
 
     buf = _gst_buffer_new_wrapped (((guint8 *) xmp_->data) + 8,
         QT_UINT32 ((guint8 *) xmp_->data) - 8, NULL);
-    taglist = gst_tag_list_from_xmp_buffer (buf);
+    xmptaglist = gst_tag_list_from_xmp_buffer (buf);
     gst_buffer_unref (buf);
 
-    qtdemux_handle_xmp_taglist (qtdemux, taglist);
+    qtdemux_handle_xmp_taglist (qtdemux, taglist, xmptaglist);
   } else {
     GST_DEBUG_OBJECT (qtdemux, "No XMP_ node found");
   }
-
 }
 
 typedef struct
@@ -10062,32 +11453,44 @@ qtdemux_parse_redirects (GstQTDemux * qtdemux)
       if (rdrf) {
         guint32 ref_type;
         guint8 *ref_data;
-
-        ref_type = QT_FOURCC ((guint8 *) rdrf->data + 12);
-        ref_data = (guint8 *) rdrf->data + 20;
-        if (ref_type == FOURCC_alis) {
-          guint record_len, record_version, fn_len;
-
-          /* MacOSX alias record, google for alias-layout.txt */
-          record_len = QT_UINT16 (ref_data + 4);
-          record_version = QT_UINT16 (ref_data + 4 + 2);
-          fn_len = QT_UINT8 (ref_data + 50);
-          if (record_len > 50 && record_version == 2 && fn_len > 0) {
-            ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);
+        guint ref_len;
+
+        ref_len = QT_UINT32 ((guint8 *) rdrf->data);
+        if (ref_len > 20) {
+          ref_type = QT_FOURCC ((guint8 *) rdrf->data + 12);
+          ref_data = (guint8 *) rdrf->data + 20;
+          if (ref_type == FOURCC_alis) {
+            guint record_len, record_version, fn_len;
+
+            if (ref_len > 70) {
+              /* MacOSX alias record, google for alias-layout.txt */
+              record_len = QT_UINT16 (ref_data + 4);
+              record_version = QT_UINT16 (ref_data + 4 + 2);
+              fn_len = QT_UINT8 (ref_data + 50);
+              if (record_len > 50 && record_version == 2 && fn_len > 0) {
+                ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);
+              }
+            } else {
+              GST_WARNING_OBJECT (qtdemux, "Invalid rdrf/alis size (%u < 70)",
+                  ref_len);
+            }
+          } else if (ref_type == FOURCC_url_) {
+            ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
+          } else {
+            GST_DEBUG_OBJECT (qtdemux,
+                "unknown rdrf reference type %" GST_FOURCC_FORMAT,
+                GST_FOURCC_ARGS (ref_type));
+          }
+          if (ref.location != NULL) {
+            GST_INFO_OBJECT (qtdemux, "New location: %s", ref.location);
+            redirects =
+                g_list_prepend (redirects, g_memdup (&ref, sizeof (ref)));
+          } else {
+            GST_WARNING_OBJECT (qtdemux,
+                "Failed to extract redirect location from rdrf atom");
           }
-        } else if (ref_type == FOURCC_url_) {
-          ref.location = g_strdup ((gchar *) ref_data);
-        } else {
-          GST_DEBUG_OBJECT (qtdemux,
-              "unknown rdrf reference type %" GST_FOURCC_FORMAT,
-              GST_FOURCC_ARGS (ref_type));
-        }
-        if (ref.location != NULL) {
-          GST_INFO_OBJECT (qtdemux, "New location: %s", ref.location);
-          redirects = g_list_prepend (redirects, g_memdup (&ref, sizeof (ref)));
         } else {
-          GST_WARNING_OBJECT (qtdemux,
-              "Failed to extract redirect location from rdrf atom");
+          GST_WARNING_OBJECT (qtdemux, "Invalid rdrf size (%u < 20)", ref_len);
         }
       }
 
@@ -10143,7 +11546,8 @@ qtdemux_parse_tree (GstQTDemux * qtdemux)
   GNode *trak;
   GNode *udta;
   GNode *mvex;
-  gint64 duration;
+  GstClockTime duration;
+  GNode *pssh;
   guint64 creation_time;
   GstDateTime *datetime = NULL;
   gint version;
@@ -10227,14 +11631,6 @@ qtdemux_parse_tree (GstQTDemux * qtdemux)
       qtdemux_parse_mehd (qtdemux, &mehd_data);
   }
 
-  /* parse all traks */
-  trak = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_trak);
-  while (trak) {
-    qtdemux_parse_trak (qtdemux, trak);
-    /* iterate all siblings */
-    trak = qtdemux_tree_get_sibling_by_type (trak, FOURCC_trak);
-  }
-
   /* set duration in the segment info */
   gst_qtdemux_get_duration (qtdemux, &duration);
   if (duration) {
@@ -10245,10 +11641,26 @@ qtdemux_parse_tree (GstQTDemux * qtdemux)
     qtdemux->segment.stop = duration;
   }
 
+  /* parse all traks */
+  trak = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_trak);
+  while (trak) {
+    qtdemux_parse_trak (qtdemux, trak);
+    /* iterate all siblings */
+    trak = qtdemux_tree_get_sibling_by_type (trak, FOURCC_trak);
+  }
+
+  if (!qtdemux->tag_list) {
+    GST_DEBUG_OBJECT (qtdemux, "new tag list");
+    qtdemux->tag_list = gst_tag_list_new_empty ();
+    gst_tag_list_set_scope (qtdemux->tag_list, GST_TAG_SCOPE_GLOBAL);
+  } else {
+    qtdemux->tag_list = gst_tag_list_make_writable (qtdemux->tag_list);
+  }
+
   /* find tags */
   udta = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_udta);
   if (udta) {
-    qtdemux_parse_udta (qtdemux, udta);
+    qtdemux_parse_udta (qtdemux, qtdemux->tag_list, udta);
   } else {
     GST_LOG_OBJECT (qtdemux, "No udta node found.");
   }
@@ -10257,11 +11669,19 @@ qtdemux_parse_tree (GstQTDemux * qtdemux)
   udta = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_meta);
   if (udta) {
     GST_DEBUG_OBJECT (qtdemux, "Parsing meta box for tags.");
-    qtdemux_parse_udta (qtdemux, udta);
+    qtdemux_parse_udta (qtdemux, qtdemux->tag_list, udta);
   } else {
     GST_LOG_OBJECT (qtdemux, "No meta node found.");
   }
 
+  /* parse any protection system info */
+  pssh = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_pssh);
+  while (pssh) {
+    GST_LOG_OBJECT (qtdemux, "Parsing pssh box.");
+    qtdemux_parse_pssh (qtdemux, pssh);
+    pssh = qtdemux_tree_get_sibling_by_type (pssh, FOURCC_pssh);
+  }
+
   qtdemux->tag_list = qtdemux_add_container_format (qtdemux, qtdemux->tag_list);
 
   return TRUE;
@@ -10473,11 +11893,15 @@ gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
           "systemstream", G_TYPE_BOOLEAN, FALSE, NULL);
       break;
     case 0x6C:                 /* MJPEG */
-      caps = gst_caps_new_empty_simple ("image/jpeg");
+      caps =
+          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          NULL);
       codec_name = "Motion-JPEG";
       break;
     case 0x6D:                 /* PNG */
-      caps = gst_caps_new_empty_simple ("image/png");
+      caps =
+          gst_caps_new_simple ("image/png", "parsed", G_TYPE_BOOLEAN, TRUE,
+          NULL);
       codec_name = "PNG still images";
       break;
     case 0x6E:                 /* JPEG2000 */
@@ -10556,14 +11980,18 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       break;
     case GST_MAKE_FOURCC ('j', 'p', 'e', 'g'):
       _codec ("JPEG still images");
-      caps = gst_caps_new_empty_simple ("image/jpeg");
+      caps =
+          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          NULL);
       break;
     case GST_MAKE_FOURCC ('m', 'j', 'p', 'a'):
     case GST_MAKE_FOURCC ('A', 'V', 'D', 'J'):
     case GST_MAKE_FOURCC ('M', 'J', 'P', 'G'):
     case GST_MAKE_FOURCC ('d', 'm', 'b', '1'):
       _codec ("Motion-JPEG");
-      caps = gst_caps_new_empty_simple ("image/jpeg");
+      caps =
+          gst_caps_new_simple ("image/jpeg", "parsed", G_TYPE_BOOLEAN, TRUE,
+          NULL);
       break;
     case GST_MAKE_FOURCC ('m', 'j', 'p', 'b'):
       _codec ("Motion-JPEG format B");
@@ -10624,12 +12052,31 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       break;
     case GST_MAKE_FOURCC ('2', 'v', 'u', 'y'):
     case GST_MAKE_FOURCC ('2', 'V', 'u', 'y'):
-    case GST_MAKE_FOURCC ('v', '2', '1', '0'):
       format = GST_VIDEO_FORMAT_UYVY;
       break;
+    case GST_MAKE_FOURCC ('v', '3', '0', '8'):
+      format = GST_VIDEO_FORMAT_v308;
+      break;
+    case GST_MAKE_FOURCC ('v', '2', '1', '6'):
+      format = GST_VIDEO_FORMAT_v216;
+      break;
+    case GST_MAKE_FOURCC ('v', '2', '1', '0'):
+      format = GST_VIDEO_FORMAT_v210;
+      break;
     case GST_MAKE_FOURCC ('r', '2', '1', '0'):
       format = GST_VIDEO_FORMAT_r210;
       break;
+      /* Packed YUV 4:4:4 10 bit in 32 bits, complex
+         case GST_MAKE_FOURCC ('v', '4', '1', '0'):
+         format = GST_VIDEO_FORMAT_v410;
+         break;
+       */
+      /* Packed YUV 4:4:4:4 8 bit in 32 bits
+       * but different order than AYUV
+       case GST_MAKE_FOURCC ('v', '4', '0', '8'):
+       format = GST_VIDEO_FORMAT_v408;
+       break;
+       */
     case GST_MAKE_FOURCC ('m', 'p', 'e', 'g'):
     case GST_MAKE_FOURCC ('m', 'p', 'g', '1'):
       _codec ("MPEG-1 video");
@@ -10893,6 +12340,7 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
           gst_caps_new_simple ("video/x-prores", "variant", G_TYPE_STRING,
           "4444", NULL);
       break;
+    case GST_MAKE_FOURCC ('v', 'c', '-', '1'):
     case FOURCC_ovc1:
       _codec ("VC-1");
       caps = gst_caps_new_simple ("video/x-wmv",
@@ -10915,6 +12363,7 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
 
     gst_video_info_init (&info);
     gst_video_info_set_format (&info, format, stream->width, stream->height);
+
     caps = gst_video_info_to_caps (&info);
     *codec_name = gst_pb_utils_get_codec_description (caps);
 
@@ -10933,31 +12382,32 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
   const GstStructure *s;
   const gchar *name;
   gint endian = 0;
+  GstAudioFormat format = 0;
+  gint depth;
+
+  GST_DEBUG_OBJECT (qtdemux, "resolve fourcc 0x%08x", GUINT32_TO_BE (fourcc));
 
-  GST_DEBUG_OBJECT (qtdemux, "resolve fourcc %08x", fourcc);
+  depth = stream->bytes_per_packet * 8;
 
   switch (fourcc) {
     case GST_MAKE_FOURCC ('N', 'O', 'N', 'E'):
     case GST_MAKE_FOURCC ('r', 'a', 'w', ' '):
-      _codec ("Raw 8-bit PCM audio");
-      caps = gst_caps_new_simple ("audio/x-raw",
-          "format", G_TYPE_STRING, "U8",
-          "layout", G_TYPE_STRING, "interleaved", NULL);
-      break;
+      /* 8-bit audio is unsigned */
+      if (depth == 8)
+        format = GST_AUDIO_FORMAT_U8;
+      /* otherwise it's signed and big-endian just like 'twos' */
     case GST_MAKE_FOURCC ('t', 'w', 'o', 's'):
       endian = G_BIG_ENDIAN;
       /* fall-through */
     case GST_MAKE_FOURCC ('s', 'o', 'w', 't'):
     {
       gchar *str;
-      gint depth;
-      GstAudioFormat format;
 
       if (!endian)
         endian = G_LITTLE_ENDIAN;
 
-      depth = stream->bytes_per_packet * 8;
-      format = gst_audio_format_build_integer (TRUE, endian, depth, depth);
+      if (!format)
+        format = gst_audio_format_build_integer (TRUE, endian, depth, depth);
 
       str = g_strdup_printf ("Raw %d-bit PCM audio", depth);
       _codec (str);
@@ -11124,6 +12574,7 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       _codec ("QualComm PureVoice");
       caps = gst_caps_from_string ("audio/qcelp");
       break;
+    case GST_MAKE_FOURCC ('w', 'm', 'a', ' '):
     case FOURCC_owma:
       _codec ("WMA");
       caps = gst_caps_new_empty_simple ("audio/x-wma");
@@ -11163,8 +12614,6 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
             "layout", G_TYPE_STRING, (flags & FLAG_IS_NON_INTERLEAVED) ?
             "non-interleaved" : "interleaved", NULL);
       } else {
-        if (depth == 0)
-          depth = 32;
         if (width == 0)
           width = 32;
         if (width == 64) {
@@ -11224,7 +12673,7 @@ qtdemux_sub_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
 {
   GstCaps *caps;
 
-  GST_DEBUG_OBJECT (qtdemux, "resolve fourcc %08x", fourcc);
+  GST_DEBUG_OBJECT (qtdemux, "resolve fourcc 0x%08x", GUINT32_TO_BE (fourcc));
 
   switch (fourcc) {
     case GST_MAKE_FOURCC ('m', 'p', '4', 's'):
@@ -11274,3 +12723,24 @@ qtdemux_generic_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
   }
   return caps;
 }
+
+static void
+gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
+    const gchar * system_id)
+{
+  gint i;
+
+  if (!qtdemux->protection_system_ids)
+    qtdemux->protection_system_ids =
+        g_ptr_array_new_with_free_func ((GDestroyNotify) g_free);
+  /* Check whether we already have an entry for this system ID. */
+  for (i = 0; i < qtdemux->protection_system_ids->len; ++i) {
+    const gchar *id = g_ptr_array_index (qtdemux->protection_system_ids, i);
+    if (g_ascii_strcasecmp (system_id, id) == 0) {
+      return;
+    }
+  }
+  GST_DEBUG_OBJECT (qtdemux, "Adding cenc protection system ID %s", system_id);
+  g_ptr_array_add (qtdemux->protection_system_ids, g_ascii_strdown (system_id,
+          -1));
+}
diff --git a/gst/isomp4/qtdemux.h b/gst/isomp4/qtdemux.h
index 47c8202..8f0553b 100644
--- a/gst/isomp4/qtdemux.h
+++ b/gst/isomp4/qtdemux.h
@@ -24,6 +24,7 @@
 #include <gst/gst.h>
 #include <gst/base/gstadapter.h>
 #include <gst/base/gstflowcombiner.h>
+#include "gstisoff.h"
 
 G_BEGIN_DECLS
 
@@ -76,11 +77,10 @@ struct _GstQTDemux {
   GNode *moov_node_compressed;
 
   guint32 timescale;
-  guint64 duration;
+  GstClockTime duration;
 
   gboolean fragmented;
-  /* offset of the mfra atom */
-  guint64 mfra_offset;
+  gboolean fragmented_seek_pending;
   guint64 moof_offset;
 
   gint state;
@@ -117,16 +117,13 @@ struct _GstQTDemux {
   /* configured playback region */
   GstSegment segment;
   GstEvent *pending_newsegment;
-  gboolean upstream_newsegment; /* qtdemux received upstream
-                                 * newsegment in TIME format which likely
-                                 * means that upstream is driving the pipeline
-                                 * (adaptive demuxers) */
+  gboolean upstream_format_is_time; /* qtdemux received upstream
+                                     * newsegment in TIME format which likely
+                                     * means that upstream is driving the pipeline
+                                     * (adaptive demuxers / dlna) */
   gint64 seek_offset;
   gint64 push_seek_start;
   gint64 push_seek_stop;
-  guint64 segment_base; /* The offset from which playback was started, needs to
-                         * be subtracted from GstSegment.base to get a correct
-                         * running time whenever a new QtSegment is activated */
 
 #if 0
   /* gst index support */
@@ -148,6 +145,10 @@ struct _GstQTDemux {
   guint64 fragment_start_offset;
     
   gint64 chapters_track_id;
+
+  /* protection support */
+  GPtrArray *protection_system_ids; /* Holds identifiers of all content protection systems for all tracks */
+  GQueue protection_event_queue; /* holds copy of upstream protection events */
 };
 
 struct _GstQTDemuxClass {
diff --git a/gst/isomp4/qtdemux_dump.c b/gst/isomp4/qtdemux_dump.c
index c76b0f2..880bb74 100644
--- a/gst/isomp4/qtdemux_dump.c
+++ b/gst/isomp4/qtdemux_dump.c
@@ -499,14 +499,16 @@ qtdemux_dump_stco (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 gboolean
 qtdemux_dump_ctts (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 {
-  guint32 ver_flags = 0, num_entries = 0, i, count, offset;
+  guint32 ver_flags = 0, num_entries = 0, i, count;
+  gint32 offset;
+
 
   if (!gst_byte_reader_get_uint32_be (data, &ver_flags) ||
       !gst_byte_reader_get_uint32_be (data, &num_entries))
     return FALSE;
 
   GST_LOG ("%*s  version/flags: %08x", depth, "", ver_flags);
-  GST_LOG ("%*s  n entries:     %d", depth, "", num_entries);
+  GST_LOG ("%*s  n entries:     %u", depth, "", num_entries);
 
   if (!qt_atom_parser_has_chunks (data, num_entries, 4 + 4))
     return FALSE;
@@ -520,6 +522,28 @@ qtdemux_dump_ctts (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 }
 
 gboolean
+qtdemux_dump_cslg (GstQTDemux * qtdemux, GstByteReader * data, int depth)
+{
+  guint32 ver_flags = 0, shift = 0;
+  gint32 least_offset = 0, start_time = 0, end_time = 0;
+
+  if (!gst_byte_reader_get_uint32_be (data, &ver_flags) ||
+      !gst_byte_reader_get_uint32_be (data, &shift) ||
+      !gst_byte_reader_get_int32_be (data, &least_offset) ||
+      !gst_byte_reader_get_int32_be (data, &start_time) ||
+      !gst_byte_reader_get_int32_be (data, &end_time))
+    return FALSE;
+
+  GST_LOG ("%*s  version/flags: %08x", depth, "", ver_flags);
+  GST_LOG ("%*s  shift:         %u", depth, "", shift);
+  GST_LOG ("%*s  least offset:  %d", depth, "", least_offset);
+  GST_LOG ("%*s  start time:    %d", depth, "", start_time);
+  GST_LOG ("%*s  end time:      %d", depth, "", end_time);
+
+  return TRUE;
+}
+
+gboolean
 qtdemux_dump_co64 (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 {
   guint32 ver_flags = 0, num_entries = 0, i;
@@ -568,11 +592,23 @@ qtdemux_dump_mfro (GstQTDemux * qtdemux, GstByteReader * data, int depth)
   if (!qt_atom_parser_has_remaining (data, 4))
     return FALSE;
 
+  GST_LOG ("%*s  version/flags: %08x", depth, "", GET_UINT32 (data));
   GST_LOG ("%*s  size: %d", depth, "", GET_UINT32 (data));
   return TRUE;
 }
 
 gboolean
+qtdemux_dump_mfhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
+{
+  if (!qt_atom_parser_has_remaining (data, 4))
+    return FALSE;
+
+  GST_LOG ("%*s  version/flags: %08x", depth, "", GET_UINT32 (data));
+  GST_LOG ("%*s  sequence_number: %d", depth, "", GET_UINT32 (data));
+  return TRUE;
+}
+
+gboolean
 qtdemux_dump_tfra (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 {
   guint64 time = 0, moof_offset = 0;
@@ -585,8 +621,8 @@ qtdemux_dump_tfra (GstQTDemux * qtdemux, GstByteReader * data, int depth)
   GST_LOG ("%*s  version/flags: %08x", depth, "", ver_flags);
 
   if (!gst_byte_reader_get_uint32_be (data, &track_id) ||
-      gst_byte_reader_get_uint32_be (data, &len) ||
-      gst_byte_reader_get_uint32_be (data, &num_entries))
+      !gst_byte_reader_get_uint32_be (data, &len) ||
+      !gst_byte_reader_get_uint32_be (data, &num_entries))
     return FALSE;
 
   GST_LOG ("%*s  track ID:      %u", depth, "", track_id);
@@ -825,6 +861,36 @@ qtdemux_dump_sdtp (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 }
 
 gboolean
+qtdemux_dump_svmi (GstQTDemux * qtdemux, GstByteReader * data, int depth)
+{
+  guint32 version;
+  guint stereo_mono_change_count;
+  guint i;
+
+  version = GET_UINT32 (data);
+  GST_LOG ("%*s  version/flags: %08x", depth, "", version);
+
+  if (!version) {
+    /* stereoscopic visual type information */
+    GST_LOG ("%*s     stereo_composition_type: %d", depth, "",
+        GET_UINT8 (data));
+    GST_LOG ("%*s     is_left_first: %d", depth, "",
+        ((guint8) GET_UINT8 (data)) & 0x01);
+
+    /* stereo_mono_change information */
+    stereo_mono_change_count = GET_UINT32 (data);
+    GST_LOG ("%*s     stereo_mono_change_count: %d", depth, "",
+        stereo_mono_change_count);
+    for (i = 1; i <= stereo_mono_change_count; i++) {
+      GST_LOG ("%*s     sample_count: %d", depth, "", GET_UINT32 (data));
+      GST_LOG ("%*s     stereo_flag: %d", depth, "",
+          ((guint8) GET_UINT8 (data)) & 0x01);
+    }
+  }
+  return TRUE;
+}
+
+gboolean
 qtdemux_dump_unknown (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 {
   int len;
@@ -877,10 +943,13 @@ qtdemux_node_dump_foreach (GNode * node, gpointer qtdemux)
 gboolean
 qtdemux_node_dump (GstQTDemux * qtdemux, GNode * node)
 {
-  if (_gst_debug_min < GST_LEVEL_LOG)
+#ifndef GST_DISABLE_GST_DEBUG
+  /* Only traverse/dump if we know it will be outputted in the end */
+  if (qtdemux_debug->threshold < GST_LEVEL_LOG)
     return TRUE;
 
   g_node_traverse (node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
       qtdemux_node_dump_foreach, qtdemux);
+#endif
   return TRUE;
 }
diff --git a/gst/isomp4/qtdemux_dump.h b/gst/isomp4/qtdemux_dump.h
index 0003ac1..4234023 100644
--- a/gst/isomp4/qtdemux_dump.h
+++ b/gst/isomp4/qtdemux_dump.h
@@ -61,8 +61,12 @@ gboolean qtdemux_dump_cmvd (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
 gboolean qtdemux_dump_ctts (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
+gboolean qtdemux_dump_cslg (GstQTDemux * qtdemux, GstByteReader * data,
+    int depth);
 gboolean qtdemux_dump_mfro (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
+gboolean qtdemux_dump_mfhd (GstQTDemux * qtdemux, GstByteReader * data,
+    int depth);
 gboolean qtdemux_dump_tfra (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
 gboolean qtdemux_dump_tfhd (GstQTDemux * qtdemux, GstByteReader * data,
@@ -79,6 +83,8 @@ gboolean qtdemux_dump_tfdt (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
 gboolean qtdemux_dump_unknown (GstQTDemux * qtdemux, GstByteReader * data,
     int depth);
+gboolean qtdemux_dump_svmi (GstQTDemux *qtdemux, GstByteReader *data,
+    int depth);
 
 gboolean qtdemux_node_dump (GstQTDemux * qtdemux, GNode * node);
 
diff --git a/gst/isomp4/qtdemux_lang.c b/gst/isomp4/qtdemux_lang.c
index 0c7a5d9..59a78d7 100644
--- a/gst/isomp4/qtdemux_lang.c
+++ b/gst/isomp4/qtdemux_lang.c
@@ -189,7 +189,7 @@ qtdemux_lang_map_qt_code_to_iso (gchar id[4], guint16 qt_lang_code)
 {
   const gchar *iso_code;
 
-  g_assert (qt_lang_code < 0x800);
+  g_assert (qt_lang_code < 0x400);
 
   if (qt_lang_code < G_N_ELEMENTS (qt_lang_map))
     iso_code = qt_lang_map[qt_lang_code];
diff --git a/gst/isomp4/qtdemux_types.c b/gst/isomp4/qtdemux_types.c
index a47d5ae..8e8189d 100644
--- a/gst/isomp4/qtdemux_types.c
+++ b/gst/isomp4/qtdemux_types.c
@@ -146,6 +146,7 @@ static const QtNodeType qt_node_types[] = {
   {FOURCC_rdrf, "rdrf", 0,},
   {FOURCC__gen, "Custom Genre", QT_FLAG_CONTAINER,},
   {FOURCC_ctts, "Composition time to sample", 0, qtdemux_dump_ctts},
+  {FOURCC_cslg, "Composition Shift Least Greatest", 0, qtdemux_dump_cslg},
   {FOURCC_XiTh, "XiTh", 0},
   {FOURCC_XdxT, "XdxT", 0},
   {FOURCC_loci, "loci", 0},
@@ -157,7 +158,7 @@ static const QtNodeType qt_node_types[] = {
   {FOURCC_mfro, "movie fragment random access offset", 0,
       qtdemux_dump_mfro},
   {FOURCC_moof, "movie fragment", QT_FLAG_CONTAINER,},
-  {FOURCC_mfhd, "movie fragment header", 0,},
+  {FOURCC_mfhd, "movie fragment header", 0, qtdemux_dump_mfhd},
   {FOURCC_traf, "track fragment", QT_FLAG_CONTAINER,},
   {FOURCC_tfhd, "track fragment header", 0,
       qtdemux_dump_tfhd},
@@ -182,6 +183,24 @@ static const QtNodeType qt_node_types[] = {
   {FOURCC_chap, "Chapter Reference"},
   {FOURCC_btrt, "Bitrate information", 0},
   {FOURCC_frma, "Audio codec format", 0},
+  {FOURCC_name, "name", 0},
+  {FOURCC_mean, "mean", 0},
+  {FOURCC_svmi, "Stereoscopic Video Media Information", 0,
+      qtdemux_dump_svmi},
+  {FOURCC_scdi, "Stereoscopic Camera and Display Information", 0,
+      qtdemux_dump_unknown},
+  {FOURCC_saiz, "sample auxiliary information sizes", 0},
+  {FOURCC_saio, "sample auxiliary information offsets", 0},
+  {FOURCC_encv, "encrypted visual sample entry", 0},
+  {FOURCC_enca, "encrypted audio sample entry", 0},
+  {FOURCC_enct, "encrypted text sample entry", 0},
+  {FOURCC_encs, "encrypted system sample entry", 0},
+  {FOURCC_sinf, "protection scheme information", QT_FLAG_CONTAINER},
+  {FOURCC_frma, "original format", 0},
+  {FOURCC_schm, "scheme type", 0},
+  {FOURCC_schi, "scheme information", QT_FLAG_CONTAINER},
+  {FOURCC_pssh, "protection system specific header", 0},
+  {FOURCC_tenc, "track encryption", 0},
   {0, "unknown", 0,},
 };
 
diff --git a/gst/isomp4/qtdemux_types.h b/gst/isomp4/qtdemux_types.h
index 57ab4f0..43ef77c 100644
--- a/gst/isomp4/qtdemux_types.h
+++ b/gst/isomp4/qtdemux_types.h
@@ -62,7 +62,8 @@ enum TfFlags
   TF_DEFAULT_SAMPLE_DURATION  = 0x000008,   /* default-sample-duration-present */
   TF_DEFAULT_SAMPLE_SIZE      = 0x000010,   /* default-sample-size-present */
   TF_DEFAULT_SAMPLE_FLAGS     = 0x000020,   /* default-sample-flags-present */
-  TF_DURATION_IS_EMPTY        = 0x100000    /* duration-is-empty */
+  TF_DURATION_IS_EMPTY        = 0x010000,   /* duration-is-empty */
+  TF_DEFAULT_BASE_IS_MOOF     = 0x020000    /* default-base-is-moof */
 };
 
 enum TrFlags
