Date: Jan 03, 2020 04:34 PM
From: 58319057b7847667f0c9585b9de0e8932b0fdb08
Subject: BACKPORT Support Ambient capabilities in Kernel 4.1
Source: Open Source
License: GPLv2
Upstream-Status: Pending
Signed-off-by: Christoph Lameter <cl@linux.com> # Original author
Signed-off-by: Andy Lutomirski <luto@kernel.org>
Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Acked-by: Kees Cook <keescook@chromium.org>
Cc: Jonathan Corbet <corbet@lwn.net>
Cc: Aaron Jones <aaronmdjones@gmail.com>
Cc: Ted Ts'o <tytso@mit.edu>
Cc: Andrew G. Morgan <morgan@kernel.org>
Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
Cc: Austin S Hemmelgarn <ahferroin7@gmail.com>
Cc: Markku Savela <msa@moth.iki.fi>
Cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Cc: Michael Kerrisk <mtk.manpages@gmail.com>
Cc: James Morris <james.l.morris@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Index: kernel-source/fs/proc/array.c
===================================================================
--- kernel-source.orig/fs/proc/array.c
+++ kernel-source/fs/proc/array.c
@@ -300,7 +300,7 @@ static void render_cap_t(struct seq_file
 static inline void task_cap(struct seq_file *m, struct task_struct *p)
 {
 	const struct cred *cred;
-	kernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;
+	kernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset, cap_ambient;
 
 	rcu_read_lock();
 	cred = __task_cred(p);
@@ -308,12 +308,14 @@ static inline void task_cap(struct seq_f
 	cap_permitted	= cred->cap_permitted;
 	cap_effective	= cred->cap_effective;
 	cap_bset	= cred->cap_bset;
+        cap_ambient    = cred->cap_ambient;
 	rcu_read_unlock();
 
 	render_cap_t(m, "CapInh:\t", &cap_inheritable);
 	render_cap_t(m, "CapPrm:\t", &cap_permitted);
 	render_cap_t(m, "CapEff:\t", &cap_effective);
 	render_cap_t(m, "CapBnd:\t", &cap_bset);
+        render_cap_t(m, "CapAmb:\t", &cap_ambient);
 }
 
 static inline void task_seccomp(struct seq_file *m, struct task_struct *p)
Index: kernel-source/include/linux/cred.h
===================================================================
--- kernel-source.orig/include/linux/cred.h
+++ kernel-source/include/linux/cred.h
@@ -138,6 +138,7 @@ struct cred {
 	kernel_cap_t	cap_permitted;	/* caps we're permitted */
 	kernel_cap_t	cap_effective;	/* caps we can actually use */
 	kernel_cap_t	cap_bset;	/* capability bounding set */
+        kernel_cap_t   cap_ambient;    /* Ambient capability set */
 #ifdef CONFIG_KEYS
 	unsigned char	jit_keyring;	/* default keyring to attach requested
 					 * keys to */
@@ -212,6 +213,13 @@ static inline void validate_process_cred
 {
 }
 #endif
+static inline bool cap_ambient_invariant_ok(const struct cred *cred)
+{
+        return cap_issubset(cred->cap_ambient,
+                            cap_intersect(cred->cap_permitted,
+                                          cred->cap_inheritable));
+}
+
 
 /**
  * get_new_cred - Get a reference on a new set of credentials
Index: kernel-source/include/uapi/linux/prctl.h
===================================================================
--- kernel-source.orig/include/uapi/linux/prctl.h
+++ kernel-source/include/uapi/linux/prctl.h
@@ -190,4 +190,11 @@ struct prctl_mm_map {
 # define PR_FP_MODE_FR		(1 << 0)	/* 64b FP registers */
 # define PR_FP_MODE_FRE		(1 << 1)	/* 32b compatibility */
 
+/* Control the ambient capability set */
+#define PR_CAP_AMBIENT                 47
+# define PR_CAP_AMBIENT_IS_SET         1
+# define PR_CAP_AMBIENT_RAISE          2
+# define PR_CAP_AMBIENT_LOWER          3
+# define PR_CAP_AMBIENT_CLEAR_ALL      4
+
 #endif /* _LINUX_PRCTL_H */
Index: kernel-source/kernel/user_namespace.c
===================================================================
--- kernel-source.orig/kernel/user_namespace.c
+++ kernel-source/kernel/user_namespace.c
@@ -40,6 +40,7 @@ static void set_cred_user_ns(struct cred
 	cred->cap_permitted = CAP_FULL_SET;
 	cred->cap_effective = CAP_FULL_SET;
 	cred->cap_bset = CAP_FULL_SET;
+        cred->cap_ambient = CAP_EMPTY_SET;
 #ifdef CONFIG_KEYS
 	key_put(cred->request_key_auth);
 	cred->request_key_auth = NULL;
Index: kernel-source/security/commoncap.c
===================================================================
--- kernel-source.orig/security/commoncap.c
+++ kernel-source/security/commoncap.c
@@ -277,6 +277,16 @@ int cap_capset(struct cred *new,
 	new->cap_effective   = *effective;
 	new->cap_inheritable = *inheritable;
 	new->cap_permitted   = *permitted;
+        /*
+        * Mask off ambient bits that are no longer both permitted and
+        * inheritable.
+        */
+        new->cap_ambient = cap_intersect(new->cap_ambient,
+                                        cap_intersect(*permitted,
+                                                      *inheritable));
+        if (WARN_ON(!cap_ambient_invariant_ok(new)))
+               return -EINVAL;
+
 	return 0;
 }
 
@@ -357,6 +367,7 @@ static inline int bprm_caps_from_vfs_cap
 
 		/*
 		 * pP' = (X & fP) | (pI & fI)
+                 * The addition of pA' is handled later.
 		 */
 		new->cap_permitted.cap[i] =
 			(new->cap_bset.cap[i] & permitted) |
@@ -484,9 +495,12 @@ int cap_bprm_set_creds(struct linux_binp
 {
 	const struct cred *old = current_cred();
 	struct cred *new = bprm->cred;
-	bool effective, has_cap = false;
+	bool effective, has_cap = false, is_setid;
 	int ret;
 	kuid_t root_uid;
+        if (WARN_ON(!cap_ambient_invariant_ok(old)))
+               return -EPERM;
+
 
 	effective = false;
 	ret = get_file_caps(bprm, &effective, &has_cap);
@@ -532,9 +546,8 @@ skip:
 	 *
 	 * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.
 	 */
-	if ((!uid_eq(new->euid, old->uid) ||
-	     !gid_eq(new->egid, old->gid) ||
-	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
+	  is_setid = !uid_eq(new->euid, old->uid) || !gid_eq(new->egid, old->gid);
+          if ((is_setid || !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
 	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
 		/* downgrade; they get no more than they had, and maybe less */
 		if (!capable(CAP_SETUID) ||
@@ -549,10 +562,29 @@ skip:
 	new->suid = new->fsuid = new->euid;
 	new->sgid = new->fsgid = new->egid;
 
+        /* File caps or setid cancels ambient. */
+       if (has_cap || is_setid)
+               cap_clear(new->cap_ambient);
+
+       /*
+        * Now that we've computed pA', update pP' to give:
+        *   pP' = (X & fP) | (pI & fI) | pA'
+        */
+       new->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);
+
+       /*
+        * Set pE' = (fE ? pP' : pA').  Because pA' is zero if fE is set,
+        * this is the same as pE' = (fE ? pP' : 0) | pA'.
+        */
+
+
 	if (effective)
 		new->cap_effective = new->cap_permitted;
 	else
-		cap_clear(new->cap_effective);
+                new->cap_effective = new->cap_ambient;
+
+               if (WARN_ON(!cap_ambient_invariant_ok(new)))
+               return -EPERM;
 	bprm->cap_effective = effective;
 
 	/*
@@ -567,7 +599,7 @@ skip:
 	 * Number 1 above might fail if you don't have a full bset, but I think
 	 * that is interesting information to audit.
 	 */
-	if (!cap_isclear(new->cap_effective)) {
+	 if (!cap_issubset(new->cap_effective, new->cap_ambient)) {
 		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
 		    !uid_eq(new->euid, root_uid) || !uid_eq(new->uid, root_uid) ||
 		    issecure(SECURE_NOROOT)) {
@@ -578,6 +610,11 @@ skip:
 	}
 
 	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
+
+               if (WARN_ON(!cap_ambient_invariant_ok(new)))
+               return -EPERM;
+
+
 	return 0;
 }
 
@@ -599,7 +636,7 @@ int cap_bprm_secureexec(struct linux_bin
 	if (!uid_eq(cred->uid, root_uid)) {
 		if (bprm->cap_effective)
 			return 1;
-		if (!cap_isclear(cred->cap_permitted))
+		if (!cap_issubset(cred->cap_permitted, cred->cap_ambient))
 			return 1;
 	}
 
@@ -701,10 +738,19 @@ static inline void cap_emulate_setxuid(s
 	     uid_eq(old->suid, root_uid)) &&
 	    (!uid_eq(new->uid, root_uid) &&
 	     !uid_eq(new->euid, root_uid) &&
-	     !uid_eq(new->suid, root_uid)) &&
-	    !issecure(SECURE_KEEP_CAPS)) {
-		cap_clear(new->cap_permitted);
-		cap_clear(new->cap_effective);
+             !uid_eq(new->suid, root_uid))) {
+               if (!issecure(SECURE_KEEP_CAPS)) {
+                       cap_clear(new->cap_permitted);
+                       cap_clear(new->cap_effective);
+               }
+
+               /*
+                * Pre-ambient programs expect setresuid to nonroot followed
+                * by exec to drop capabilities.  We should make sure that
+                * this remains the case.
+                */
+               cap_clear(new->cap_ambient);
+
 	}
 	if (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))
 		cap_clear(new->cap_effective);
@@ -933,6 +979,43 @@ int cap_task_prctl(int option, unsigned
 		else
 			new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
 		return commit_creds(new);
+        case PR_CAP_AMBIENT:
+               if (arg2 == PR_CAP_AMBIENT_CLEAR_ALL) {
+                       if (arg3 | arg4 | arg5)
+                               return -EINVAL;
+
+                       new = prepare_creds();
+                       if (!new)
+                               return -ENOMEM;
+                       cap_clear(new->cap_ambient);
+                       return commit_creds(new);
+               }
+
+               if (((!cap_valid(arg3)) | arg4 | arg5))
+                       return -EINVAL;
+
+               if (arg2 == PR_CAP_AMBIENT_IS_SET) {
+                       return !!cap_raised(current_cred()->cap_ambient, arg3);
+               } else if (arg2 != PR_CAP_AMBIENT_RAISE &&
+                          arg2 != PR_CAP_AMBIENT_LOWER) {
+                       return -EINVAL;
+               } else {
+                       if (arg2 == PR_CAP_AMBIENT_RAISE &&
+                           (!cap_raised(current_cred()->cap_permitted, arg3) ||
+                            !cap_raised(current_cred()->cap_inheritable,
+                                        arg3)))
+                               return -EPERM;
+
+
+                       new = prepare_creds();
+                       if (!new)
+                               return -ENOMEM;
+                       if (arg2 == PR_CAP_AMBIENT_RAISE)
+                               cap_raise(new->cap_ambient, arg3);
+                       else
+                               cap_lower(new->cap_ambient, arg3);
+                       return commit_creds(new);
+               }
 
 	default:
 		/* No functionality available - continue with default */
Index: kernel-source/security/keys/process_keys.c
===================================================================
--- kernel-source.orig/security/keys/process_keys.c
+++ kernel-source/security/keys/process_keys.c
@@ -864,6 +864,7 @@ void key_change_session_keyring(struct c
 	new->cap_permitted	= old->cap_permitted;
 	new->cap_effective	= old->cap_effective;
 	new->cap_bset		= old->cap_bset;
+        new->cap_ambient       = old->cap_ambient;
 
 	new->jit_keyring	= old->jit_keyring;
 	new->thread_keyring	= key_get(old->thread_keyring);
